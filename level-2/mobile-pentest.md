# 📱 Mobil Penetrasyon Testi (Mobile Penetration Testing)

## 🎯 Öğrenme Hedefleri

### 📚 Teorik Bilgi
- **Mobil Güvenlik Temelleri**: iOS ve Android güvenlik mimarileri
- **Mobil Uygulama Güvenliği**: OWASP Mobile Top 10
- **Platform Güvenliği**: Sandboxing, kod imzalama, izin modelleri
- **Ağ Güvenliği**: Mobil ağ protokolleri ve güvenlik
- **Veri Güvenliği**: Şifreleme, anahtar yönetimi, güvenli depolama

### 🛠️ Pratik Beceriler
- **Statik Analiz**: Kaynak kod ve bytecode analizi
- **Dinamik Analiz**: Runtime analiz ve debugging
- **Ağ Analizi**: Trafik yakalama ve analiz
- **Reverse Engineering**: APK/IPA dosya analizi
- **Exploit Geliştirme**: Mobil zafiyet istismarı

### 🔧 Teknik Yetkinlikler
- **Android Penetrasyon Testi**: ADB, Frida, Objection
- **iOS Penetrasyon Testi**: Xcode, Cycript, class-dump
- **Mobil Ağ Analizi**: Burp Suite Mobile, OWASP ZAP
- **Emülatör/Simülatör Kullanımı**: Genymotion, Android Studio
- **Mobil Malware Analizi**: Sandboxing ve behavioral analysis

## 🌍 Gerçek Dünya Uygulamaları

### 📱 Mobil Uygulama Güvenlik Testi
- **Finansal Uygulamalar**: Banking ve payment app security
- **Sosyal Medya Uygulamaları**: Privacy ve data protection
- **IoT Mobil Kontrolleri**: Smart home ve wearable security
- **Enterprise Uygulamalar**: MDM ve corporate app security

### 🔒 Mobil Cihaz Güvenliği
- **Device Management**: BYOD ve enterprise mobility
- **Jailbreak/Root Detection**: Anti-tampering mechanisms
- **Mobile Forensics**: Digital evidence collection
- **Incident Response**: Mobile security breach handling

## 🔬 Mobil Penetrasyon Testi Framework'ü

```python
#!/usr/bin/env python3
"""
Mobile Penetration Testing Framework
Author: ibrahimsql
Description: Kapsamlı mobil penetrasyon testi çerçevesi
"""

import os
import sys
import json
import subprocess
import requests
import hashlib
import zipfile
import xml.etree.ElementTree as ET
from datetime import datetime
import re
import base64
from pathlib import Path

class MobilePentestFramework:
    def __init__(self):
        self.platform = None  # 'android' or 'ios'
        self.target_app = None
        self.device_id = None
        self.test_results = []
        
        # OWASP Mobile Top 10 2016
        self.owasp_mobile_top10 = {
            'M1': 'Improper Platform Usage',
            'M2': 'Insecure Data Storage',
            'M3': 'Insecure Communication',
            'M4': 'Insecure Authentication',
            'M5': 'Insufficient Cryptography',
            'M6': 'Insecure Authorization',
            'M7': 'Client Code Quality',
            'M8': 'Code Tampering',
            'M9': 'Reverse Engineering',
            'M10': 'Extraneous Functionality'
        }
        
        # Test kategorileri
        self.test_categories = {
            'static_analysis': 'Statik Kod Analizi',
            'dynamic_analysis': 'Dinamik Analiz',
            'network_analysis': 'Ağ Trafiği Analizi',
            'runtime_analysis': 'Runtime Manipülasyon',
            'reverse_engineering': 'Tersine Mühendislik'
        }
    
    def setup_android_environment(self, device_id=None):
        """Android test ortamını hazırla"""
        self.platform = 'android'
        self.device_id = device_id
        
        print("[+] Android test ortamı hazırlanıyor...")
        
        # ADB bağlantısını kontrol et
        if not self._check_adb_connection():
            print("[-] ADB bağlantısı kurulamadı!")
            return False
        
        # Root kontrolü
        root_status = self._check_root_access()
        print(f"[+] Root erişimi: {'Var' if root_status else 'Yok'}")
        
        # Frida server kurulumu kontrolü
        frida_status = self._check_frida_server()
        print(f"[+] Frida server: {'Çalışıyor' if frida_status else 'Kurulu değil'}")
        
        return True
    
    def setup_ios_environment(self, device_id=None):
        """iOS test ortamını hazırla"""
        self.platform = 'ios'
        self.device_id = device_id
        
        print("[+] iOS test ortamı hazırlanıyor...")
        
        # iOS device bağlantısını kontrol et
        if not self._check_ios_connection():
            print("[-] iOS cihaz bağlantısı kurulamadı!")
            return False
        
        # Jailbreak kontrolü
        jailbreak_status = self._check_jailbreak_status()
        print(f"[+] Jailbreak durumu: {'Var' if jailbreak_status else 'Yok'}")
        
        return True
    
    def _check_adb_connection(self):
        """ADB bağlantısını kontrol et"""
        try:
            result = subprocess.run(['adb', 'devices'], 
                                  capture_output=True, text=True)
            return 'device' in result.stdout
        except FileNotFoundError:
            return False
    
    def _check_root_access(self):
        """Android root erişimini kontrol et"""
        try:
            cmd = ['adb', 'shell', 'su', '-c', 'id']
            if self.device_id:
                cmd = ['adb', '-s', self.device_id, 'shell', 'su', '-c', 'id']
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=5)
            return 'uid=0' in result.stdout
        except:
            return False
    
    def _check_frida_server(self):
        """Frida server durumunu kontrol et"""
        try:
            cmd = ['adb', 'shell', 'ps', '|', 'grep', 'frida']
            if self.device_id:
                cmd = ['adb', '-s', self.device_id, 'shell', 'ps', '|', 'grep', 'frida']
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            return 'frida-server' in result.stdout
        except:
            return False
    
    def _check_ios_connection(self):
        """iOS cihaz bağlantısını kontrol et"""
        try:
            result = subprocess.run(['idevice_id', '-l'], 
                                  capture_output=True, text=True)
            return len(result.stdout.strip()) > 0
        except FileNotFoundError:
            return False
    
    def _check_jailbreak_status(self):
        """iOS jailbreak durumunu kontrol et"""
        # Simulated jailbreak check
        jailbreak_indicators = [
            '/Applications/Cydia.app',
            '/usr/sbin/sshd',
            '/etc/apt',
            '/private/var/lib/apt/'
        ]
        
        # Bu gerçek bir implementasyonda SSH veya libimobiledevice kullanılır
        return False  # Simulated
    
    def analyze_apk(self, apk_path):
        """Android APK dosyasını analiz et"""
        if not os.path.exists(apk_path):
            print(f"[-] APK dosyası bulunamadı: {apk_path}")
            return None
        
        print(f"[+] APK analizi başlatılıyor: {apk_path}")
        
        analysis_results = {
            'file_info': self._get_apk_file_info(apk_path),
            'manifest_analysis': self._analyze_android_manifest(apk_path),
            'permission_analysis': self._analyze_permissions(apk_path),
            'component_analysis': self._analyze_components(apk_path),
            'security_analysis': self._analyze_apk_security(apk_path),
            'code_analysis': self._analyze_apk_code(apk_path)
        }
        
        return analysis_results
    
    def _get_apk_file_info(self, apk_path):
        """APK dosya bilgilerini al"""
        file_info = {
            'file_path': apk_path,
            'file_size': os.path.getsize(apk_path),
            'md5_hash': self._calculate_file_hash(apk_path, 'md5'),
            'sha256_hash': self._calculate_file_hash(apk_path, 'sha256')
        }
        
        return file_info
    
    def _calculate_file_hash(self, file_path, algorithm):
        """Dosya hash değerini hesapla"""
        hash_obj = hashlib.new(algorithm)
        
        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_obj.update(chunk)
        
        return hash_obj.hexdigest()
    
    def _analyze_android_manifest(self, apk_path):
        """AndroidManifest.xml dosyasını analiz et"""
        manifest_analysis = {
            'package_name': None,
            'version_code': None,
            'version_name': None,
            'min_sdk_version': None,
            'target_sdk_version': None,
            'permissions': [],
            'activities': [],
            'services': [],
            'receivers': [],
            'providers': []
        }
        
        try:
            # APK'yı geçici olarak extract et
            with zipfile.ZipFile(apk_path, 'r') as apk_zip:
                # AndroidManifest.xml'i oku (binary format)
                manifest_data = apk_zip.read('AndroidManifest.xml')
                
                # Gerçek implementasyonda aapt veya androguard kullanılır
                # Bu örnekte simulated data
                manifest_analysis.update({
                    'package_name': 'com.example.testapp',
                    'version_code': '1',
                    'version_name': '1.0',
                    'min_sdk_version': '21',
                    'target_sdk_version': '30'
                })
        
        except Exception as e:
            print(f"[-] Manifest analizi hatası: {e}")
        
        return manifest_analysis
    
    def _analyze_permissions(self, apk_path):
        """APK izinlerini analiz et"""
        # Simulated permission analysis
        dangerous_permissions = [
            'android.permission.READ_CONTACTS',
            'android.permission.WRITE_CONTACTS',
            'android.permission.READ_SMS',
            'android.permission.SEND_SMS',
            'android.permission.ACCESS_FINE_LOCATION',
            'android.permission.ACCESS_COARSE_LOCATION',
            'android.permission.CAMERA',
            'android.permission.RECORD_AUDIO',
            'android.permission.READ_EXTERNAL_STORAGE',
            'android.permission.WRITE_EXTERNAL_STORAGE'
        ]
        
        permission_analysis = {
            'total_permissions': 15,
            'dangerous_permissions': dangerous_permissions[:5],  # Simulated
            'custom_permissions': [],
            'permission_risks': self._assess_permission_risks(dangerous_permissions[:5])
        }
        
        return permission_analysis
    
    def _assess_permission_risks(self, permissions):
        """İzin risklerini değerlendir"""
        risk_assessment = []
        
        risk_mapping = {
            'android.permission.READ_CONTACTS': 'high',
            'android.permission.READ_SMS': 'critical',
            'android.permission.ACCESS_FINE_LOCATION': 'high',
            'android.permission.CAMERA': 'medium',
            'android.permission.RECORD_AUDIO': 'high'
        }
        
        for permission in permissions:
            risk_level = risk_mapping.get(permission, 'low')
            risk_assessment.append({
                'permission': permission,
                'risk_level': risk_level,
                'description': f'{permission} izni {risk_level} risk taşıyor'
            })
        
        return risk_assessment
    
    def _analyze_components(self, apk_path):
        """APK bileşenlerini analiz et"""
        # Simulated component analysis
        component_analysis = {
            'exported_activities': [
                {'name': 'MainActivity', 'exported': True, 'intent_filters': ['android.intent.action.MAIN']},
                {'name': 'LoginActivity', 'exported': False, 'intent_filters': []}
            ],
            'exported_services': [
                {'name': 'BackgroundService', 'exported': True, 'intent_filters': ['com.example.CUSTOM_ACTION']}
            ],
            'exported_receivers': [
                {'name': 'BootReceiver', 'exported': True, 'intent_filters': ['android.intent.action.BOOT_COMPLETED']}
            ],
            'content_providers': [
                {'name': 'DataProvider', 'exported': False, 'authorities': ['com.example.provider']}
            ]
        }
        
        return component_analysis
    
    def _analyze_apk_security(self, apk_path):
        """APK güvenlik analizini yap"""
        security_analysis = {
            'code_obfuscation': self._check_code_obfuscation(apk_path),
            'anti_debugging': self._check_anti_debugging(apk_path),
            'root_detection': self._check_root_detection(apk_path),
            'ssl_pinning': self._check_ssl_pinning(apk_path),
            'encryption_usage': self._check_encryption_usage(apk_path),
            'hardcoded_secrets': self._check_hardcoded_secrets(apk_path)
        }
        
        return security_analysis
    
    def _check_code_obfuscation(self, apk_path):
        """Kod obfuscation kontrolü"""
        # Simulated obfuscation check
        return {
            'is_obfuscated': True,
            'obfuscation_level': 'medium',
            'obfuscation_tools': ['ProGuard']
        }
    
    def _check_anti_debugging(self, apk_path):
        """Anti-debugging kontrolü"""
        # Simulated anti-debugging check
        return {
            'has_anti_debugging': True,
            'detection_methods': ['ptrace_check', 'debugger_detection'],
            'bypass_difficulty': 'medium'
        }
    
    def _check_root_detection(self, apk_path):
        """Root detection kontrolü"""
        # Simulated root detection check
        return {
            'has_root_detection': True,
            'detection_methods': ['su_binary_check', 'test_keys_check'],
            'bypass_difficulty': 'easy'
        }
    
    def _check_ssl_pinning(self, apk_path):
        """SSL pinning kontrolü"""
        # Simulated SSL pinning check
        return {
            'has_ssl_pinning': False,
            'pinning_method': None,
            'certificates_pinned': []
        }
    
    def _check_encryption_usage(self, apk_path):
        """Şifreleme kullanımı kontrolü"""
        # Simulated encryption check
        return {
            'uses_encryption': True,
            'encryption_algorithms': ['AES', 'RSA'],
            'weak_algorithms': ['DES'],
            'key_management': 'hardcoded'  # Risk!
        }
    
    def _check_hardcoded_secrets(self, apk_path):
        """Hardcoded secret kontrolü"""
        # Simulated secret detection
        return {
            'has_hardcoded_secrets': True,
            'secret_types': ['api_keys', 'passwords'],
            'secrets_found': [
                {'type': 'api_key', 'value': 'AIza***', 'location': 'strings.xml'},
                {'type': 'password', 'value': 'admin123', 'location': 'LoginActivity.java'}
            ]
        }
    
    def _analyze_apk_code(self, apk_path):
        """APK kod analizini yap"""
        code_analysis = {
            'total_classes': 150,
            'total_methods': 1200,
            'vulnerable_patterns': self._find_vulnerable_patterns(apk_path),
            'insecure_apis': self._find_insecure_apis(apk_path),
            'code_quality_issues': self._find_code_quality_issues(apk_path)
        }
        
        return code_analysis
    
    def _find_vulnerable_patterns(self, apk_path):
        """Zafiyet desenlerini bul"""
        # Simulated vulnerable pattern detection
        return [
            {
                'pattern': 'SQL Injection',
                'location': 'DatabaseHelper.java:45',
                'severity': 'high',
                'description': 'Kullanıcı girdisi doğrudan SQL sorgusunda kullanılıyor'
            },
            {
                'pattern': 'Path Traversal',
                'location': 'FileManager.java:23',
                'severity': 'medium',
                'description': 'Dosya yolu doğrulaması yapılmıyor'
            }
        ]
    
    def _find_insecure_apis(self, apk_path):
        """Güvensiz API kullanımlarını bul"""
        # Simulated insecure API detection
        return [
            {
                'api': 'HttpURLConnection',
                'location': 'NetworkManager.java:67',
                'issue': 'HTTP kullanımı (HTTPS olmalı)',
                'severity': 'medium'
            },
            {
                'api': 'SharedPreferences',
                'location': 'UserManager.java:34',
                'issue': 'Hassas veri şifrelenmeden saklanıyor',
                'severity': 'high'
            }
        ]
    
    def _find_code_quality_issues(self, apk_path):
        """Kod kalitesi sorunlarını bul"""
        # Simulated code quality analysis
        return [
            {
                'issue': 'Unused imports',
                'count': 25,
                'severity': 'low'
            },
            {
                'issue': 'Empty catch blocks',
                'count': 8,
                'severity': 'medium'
            },
            {
                'issue': 'Hardcoded strings',
                'count': 45,
                'severity': 'low'
            }
        ]
    
    def dynamic_analysis(self, package_name):
        """Dinamik analiz yap"""
        if self.platform != 'android':
            print("[-] Dinamik analiz sadece Android için destekleniyor")
            return None
        
        print(f"[+] Dinamik analiz başlatılıyor: {package_name}")
        
        # Uygulamayı başlat
        self._start_application(package_name)
        
        # Frida ile runtime analiz
        frida_results = self._run_frida_analysis(package_name)
        
        # Network trafiği yakala
        network_results = self._capture_network_traffic(package_name)
        
        # Log analizi
        log_results = self._analyze_application_logs(package_name)
        
        dynamic_results = {
            'frida_analysis': frida_results,
            'network_analysis': network_results,
            'log_analysis': log_results,
            'runtime_vulnerabilities': self._detect_runtime_vulnerabilities(package_name)
        }
        
        return dynamic_results
    
    def _start_application(self, package_name):
        """Uygulamayı başlat"""
        try:
            cmd = ['adb', 'shell', 'monkey', '-p', package_name, '-c', 
                   'android.intent.category.LAUNCHER', '1']
            if self.device_id:
                cmd = ['adb', '-s', self.device_id] + cmd[1:]
            
            subprocess.run(cmd, capture_output=True)
            print(f"[+] Uygulama başlatıldı: {package_name}")
        except Exception as e:
            print(f"[-] Uygulama başlatma hatası: {e}")
    
    def _run_frida_analysis(self, package_name):
        """Frida ile runtime analiz"""
        # Simulated Frida analysis
        frida_results = {
            'hooked_functions': [
                'javax.crypto.Cipher.doFinal',
                'java.net.URL.openConnection',
                'android.telephony.TelephonyManager.getDeviceId'
            ],
            'intercepted_calls': [
                {
                    'function': 'javax.crypto.Cipher.doFinal',
                    'arguments': ['encrypted_data'],
                    'return_value': 'decrypted_data',
                    'timestamp': datetime.now().isoformat()
                }
            ],
            'memory_dumps': [
                {
                    'address': '0x12345678',
                    'size': 1024,
                    'content': 'base64_encoded_memory_dump'
                }
            ]
        }
        
        return frida_results
    
    def _capture_network_traffic(self, package_name):
        """Network trafiğini yakala"""
        # Simulated network traffic capture
        network_results = {
            'total_requests': 25,
            'http_requests': 5,
            'https_requests': 20,
            'insecure_connections': [
                {
                    'url': 'http://api.example.com/login',
                    'method': 'POST',
                    'data': 'username=admin&password=123456',
                    'risk': 'high'
                }
            ],
            'certificate_issues': [
                {
                    'host': 'api.example.com',
                    'issue': 'self_signed_certificate',
                    'severity': 'medium'
                }
            ]
        }
        
        return network_results
    
    def _analyze_application_logs(self, package_name):
        """Uygulama loglarını analiz et"""
        try:
            cmd = ['adb', 'logcat', '-d', '--pid', f'$(pidof {package_name})']
            if self.device_id:
                cmd = ['adb', '-s', self.device_id] + cmd[1:]
            
            # Simulated log analysis
            log_results = {
                'total_log_entries': 150,
                'error_entries': 12,
                'warning_entries': 8,
                'sensitive_data_leaks': [
                    {
                        'type': 'password',
                        'log_entry': 'Login attempt with password: 123456',
                        'severity': 'critical'
                    },
                    {
                        'type': 'api_key',
                        'log_entry': 'API Key: AIzaSyC...',
                        'severity': 'high'
                    }
                ]
            }
            
            return log_results
        
        except Exception as e:
            print(f"[-] Log analizi hatası: {e}")
            return {}
    
    def _detect_runtime_vulnerabilities(self, package_name):
        """Runtime zafiyetlerini tespit et"""
        # Simulated runtime vulnerability detection
        return [
            {
                'vulnerability': 'Insecure Random Number Generation',
                'location': 'CryptoUtils.generateKey()',
                'description': 'Zayıf rastgele sayı üreteci kullanılıyor',
                'severity': 'medium',
                'owasp_category': 'M5'
            },
            {
                'vulnerability': 'Insecure Data Storage',
                'location': 'SharedPreferences',
                'description': 'Hassas veriler şifrelenmeden saklanıyor',
                'severity': 'high',
                'owasp_category': 'M2'
            }
        ]
    
    def network_security_test(self, package_name):
        """Ağ güvenliği testini yap"""
        print(f"[+] Ağ güvenliği testi başlatılıyor: {package_name}")
        
        network_tests = {
            'ssl_tls_test': self._test_ssl_tls_security(package_name),
            'certificate_pinning_test': self._test_certificate_pinning(package_name),
            'man_in_the_middle_test': self._test_mitm_vulnerability(package_name),
            'data_leakage_test': self._test_data_leakage(package_name)
        }
        
        return network_tests
    
    def _test_ssl_tls_security(self, package_name):
        """SSL/TLS güvenliği testi"""
        # Simulated SSL/TLS test
        return {
            'supports_tls_1_3': True,
            'supports_tls_1_2': True,
            'supports_tls_1_1': False,
            'supports_tls_1_0': False,
            'weak_ciphers': [],
            'certificate_validation': 'proper',
            'hsts_enabled': False
        }
    
    def _test_certificate_pinning(self, package_name):
        """Certificate pinning testi"""
        # Simulated certificate pinning test
        return {
            'pinning_implemented': False,
            'pinning_bypass_possible': True,
            'pinned_certificates': [],
            'pinning_method': None
        }
    
    def _test_mitm_vulnerability(self, package_name):
        """Man-in-the-Middle zafiyet testi"""
        # Simulated MITM test
        return {
            'vulnerable_to_mitm': True,
            'accepts_invalid_certificates': True,
            'accepts_self_signed_certificates': True,
            'hostname_verification': False
        }
    
    def _test_data_leakage(self, package_name):
        """Veri sızıntısı testi"""
        # Simulated data leakage test
        return {
            'sensitive_data_in_logs': True,
            'sensitive_data_in_network': True,
            'data_types_leaked': ['passwords', 'api_keys', 'personal_info'],
            'leakage_severity': 'high'
        }
    
    def generate_mobile_pentest_report(self, test_results):
        """Mobil penetrasyon testi raporu oluştur"""
        report = {
            'metadata': {
                'platform': self.platform,
                'target_app': self.target_app,
                'test_date': datetime.now().isoformat(),
                'framework_version': '1.0'
            },
            'executive_summary': {
                'total_vulnerabilities': self._count_vulnerabilities(test_results),
                'critical_vulnerabilities': self._count_critical_vulnerabilities(test_results),
                'owasp_mobile_coverage': self._calculate_owasp_coverage(test_results),
                'overall_security_rating': self._calculate_security_rating(test_results)
            },
            'detailed_findings': test_results,
            'recommendations': self._generate_recommendations(test_results),
            'owasp_mobile_mapping': self._map_to_owasp_mobile(test_results)
        }
        
        # Raporu dosyaya kaydet
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_file = f'mobile_pentest_report_{timestamp}.json'
        
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"[+] Mobil Penetrasyon Testi Raporu oluşturuldu: {report_file}")
        return report_file
    
    def _count_vulnerabilities(self, test_results):
        """Toplam zafiyet sayısını hesapla"""
        count = 0
        
        # Static analysis vulnerabilities
        if 'static_analysis' in test_results:
            static = test_results['static_analysis']
            if 'vulnerable_patterns' in static.get('code_analysis', {}):
                count += len(static['code_analysis']['vulnerable_patterns'])
        
        # Dynamic analysis vulnerabilities
        if 'dynamic_analysis' in test_results:
            dynamic = test_results['dynamic_analysis']
            if 'runtime_vulnerabilities' in dynamic:
                count += len(dynamic['runtime_vulnerabilities'])
        
        return count
    
    def _count_critical_vulnerabilities(self, test_results):
        """Kritik zafiyet sayısını hesapla"""
        count = 0
        
        # Check all vulnerabilities for critical severity
        for category in test_results.values():
            if isinstance(category, dict):
                for subcategory in category.values():
                    if isinstance(subcategory, list):
                        for item in subcategory:
                            if isinstance(item, dict) and item.get('severity') == 'critical':
                                count += 1
        
        return count
    
    def _calculate_owasp_coverage(self, test_results):
        """OWASP Mobile Top 10 kapsama oranını hesapla"""
        covered_categories = set()
        
        # Map vulnerabilities to OWASP categories
        for category in test_results.values():
            if isinstance(category, dict):
                for subcategory in category.values():
                    if isinstance(subcategory, list):
                        for item in subcategory:
                            if isinstance(item, dict) and 'owasp_category' in item:
                                covered_categories.add(item['owasp_category'])
        
        coverage_percentage = (len(covered_categories) / len(self.owasp_mobile_top10)) * 100
        return round(coverage_percentage, 2)
    
    def _calculate_security_rating(self, test_results):
        """Genel güvenlik puanını hesapla"""
        total_vulns = self._count_vulnerabilities(test_results)
        critical_vulns = self._count_critical_vulnerabilities(test_results)
        
        if critical_vulns > 0:
            return 'Poor'
        elif total_vulns > 10:
            return 'Fair'
        elif total_vulns > 5:
            return 'Good'
        else:
            return 'Excellent'
    
    def _generate_recommendations(self, test_results):
        """Güvenlik önerilerini oluştur"""
        recommendations = []
        
        # Generic recommendations based on common findings
        recommendations.extend([
            "Hassas verileri şifreleyerek saklayın",
            "SSL/TLS sertifika pinning implementasyonu yapın",
            "Root/Jailbreak detection mekanizmaları ekleyin",
            "Code obfuscation ve anti-tampering korumaları uygulayın",
            "API anahtarlarını ve şifreleri hardcode etmeyin",
            "Güvenli iletişim protokolleri kullanın (HTTPS)",
            "Input validation ve output encoding uygulayın",
            "Minimum privilege principle'ını takip edin",
            "Düzenli güvenlik testleri yapın",
            "OWASP Mobile Security Testing Guide'ı takip edin"
        ])
        
        return recommendations
    
    def _map_to_owasp_mobile(self, test_results):
        """Bulguları OWASP Mobile Top 10'a eşle"""
        owasp_mapping = {}
        
        for category_id, category_name in self.owasp_mobile_top10.items():
            owasp_mapping[category_id] = {
                'name': category_name,
                'vulnerabilities_found': [],
                'risk_level': 'low'
            }
        
        # Map specific vulnerabilities to OWASP categories
        # This would be more sophisticated in a real implementation
        
        return owasp_mapping

# Kullanım örneği
if __name__ == "__main__":
    # Mobile Pentest Framework başlat
    mobile_pentester = MobilePentestFramework()
    
    # Android ortamını hazırla
    if mobile_pentester.setup_android_environment():
        print("[+] Android test ortamı hazır")
        
        # APK analizi
        apk_path = "/path/to/test.apk"
        if os.path.exists(apk_path):
            static_results = mobile_pentester.analyze_apk(apk_path)
            print(f"[+] Statik analiz tamamlandı")
            
            # Dinamik analiz
            package_name = "com.example.testapp"
            dynamic_results = mobile_pentester.dynamic_analysis(package_name)
            print(f"[+] Dinamik analiz tamamlandı")
            
            # Ağ güvenliği testi
            network_results = mobile_pentester.network_security_test(package_name)
            print(f"[+] Ağ güvenliği testi tamamlandı")
            
            # Tüm sonuçları birleştir
            all_results = {
                'static_analysis': static_results,
                'dynamic_analysis': dynamic_results,
                'network_analysis': network_results
            }
            
            # Rapor oluştur
            report_file = mobile_pentester.generate_mobile_pentest_report(all_results)
            print(f"[+] Mobil penetrasyon testi tamamlandı!")
            print(f"[+] Rapor dosyası: {report_file}")
        else:
            print(f"[-] APK dosyası bulunamadı: {apk_path}")
    else:
        print("[-] Android test ortamı hazırlanamadı")
```

## 📱 Android Güvenlik Analiz Araçları

### Android Static Analysis Toolkit

```python
#!/usr/bin/env python3
"""
Android Static Analysis Toolkit
Author: ibrahimsql
Description: Android uygulamaları için statik analiz araçları
"""

import os
import re
import json
import zipfile
import subprocess
from pathlib import Path
import xml.etree.ElementTree as ET

class AndroidStaticAnalyzer:
    def __init__(self):
        self.dangerous_permissions = [
            'android.permission.READ_CONTACTS',
            'android.permission.WRITE_CONTACTS',
            'android.permission.READ_SMS',
            'android.permission.SEND_SMS',
            'android.permission.RECEIVE_SMS',
            'android.permission.ACCESS_FINE_LOCATION',
            'android.permission.ACCESS_COARSE_LOCATION',
            'android.permission.CAMERA',
            'android.permission.RECORD_AUDIO',
            'android.permission.READ_PHONE_STATE',
            'android.permission.CALL_PHONE',
            'android.permission.READ_CALL_LOG',
            'android.permission.WRITE_CALL_LOG',
            'android.permission.READ_EXTERNAL_STORAGE',
            'android.permission.WRITE_EXTERNAL_STORAGE'
        ]
        
        self.vulnerable_patterns = {
            'sql_injection': r'(SELECT|INSERT|UPDATE|DELETE).*\+.*',
            'path_traversal': r'\.\.[\\/]',
            'hardcoded_secrets': r'(password|secret|key|token)\s*=\s*["\'][^"\'
]{8,}["\']',
            'weak_crypto': r'(DES|MD5|SHA1)\(',
            'insecure_random': r'Random\(\)',
            'debug_enabled': r'android:debuggable\s*=\s*["\']true["\']',
            'backup_enabled': r'android:allowBackup\s*=\s*["\']true["\']'
        }
    
    def analyze_apk_comprehensive(self, apk_path):
        """Kapsamlı APK analizi"""
        print(f"[+] Kapsamlı APK analizi başlatılıyor: {apk_path}")
        
        # APK'yı geçici dizine extract et
        extract_dir = self._extract_apk(apk_path)
        
        if not extract_dir:
            return None
        
        analysis_results = {
            'basic_info': self._get_basic_apk_info(apk_path),
            'manifest_analysis': self._deep_manifest_analysis(extract_dir),
            'permission_analysis': self._comprehensive_permission_analysis(extract_dir),
            'component_security': self._analyze_component_security(extract_dir),
            'code_analysis': self._deep_code_analysis(extract_dir),
            'resource_analysis': self._analyze_resources(extract_dir),
            'native_library_analysis': self._analyze_native_libraries(extract_dir),
            'certificate_analysis': self._analyze_certificate(apk_path)
        }
        
        # Geçici dosyaları temizle
        self._cleanup_temp_files(extract_dir)
        
        return analysis_results
    
    def _extract_apk(self, apk_path):
        """APK dosyasını extract et"""
        try:
            extract_dir = f"/tmp/apk_analysis_{os.path.basename(apk_path)}"
            
            with zipfile.ZipFile(apk_path, 'r') as apk_zip:
                apk_zip.extractall(extract_dir)
            
            print(f"[+] APK extract edildi: {extract_dir}")
            return extract_dir
        
        except Exception as e:
            print(f"[-] APK extract hatası: {e}")
            return None
    
    def _get_basic_apk_info(self, apk_path):
        """Temel APK bilgilerini al"""
        try:
            # aapt kullanarak APK bilgilerini al
            cmd = ['aapt', 'dump', 'badging', apk_path]
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                return self._parse_aapt_output(result.stdout)
            else:
                # aapt yoksa simulated data
                return {
                    'package_name': 'com.example.app',
                    'version_code': '1',
                    'version_name': '1.0',
                    'min_sdk': '21',
                    'target_sdk': '30'
                }
        
        except FileNotFoundError:
            # aapt bulunamadı, simulated data döndür
            return {
                'package_name': 'com.example.app',
                'version_code': '1',
                'version_name': '1.0',
                'min_sdk': '21',
                'target_sdk': '30'
            }
    
    def _parse_aapt_output(self, aapt_output):
        """aapt çıktısını parse et"""
        info = {}
        
        # Package name
        package_match = re.search(r"package: name='([^']+)'", aapt_output)
        if package_match:
            info['package_name'] = package_match.group(1)
        
        # Version code
        version_code_match = re.search(r"versionCode='([^']+)'", aapt_output)
        if version_code_match:
            info['version_code'] = version_code_match.group(1)
        
        # Version name
        version_name_match = re.search(r"versionName='([^']+)'", aapt_output)
        if version_name_match:
            info['version_name'] = version_name_match.group(1)
        
        # SDK versions
        min_sdk_match = re.search(r"sdkVersion:'([^']+)'", aapt_output)
        if min_sdk_match:
            info['min_sdk'] = min_sdk_match.group(1)
        
        target_sdk_match = re.search(r"targetSdkVersion:'([^']+)'", aapt_output)
        if target_sdk_match:
            info['target_sdk'] = target_sdk_match.group(1)
        
        return info
    
    def _deep_manifest_analysis(self, extract_dir):
        """Derinlemesine manifest analizi"""
        manifest_path = os.path.join(extract_dir, 'AndroidManifest.xml')
        
        if not os.path.exists(manifest_path):
            return {'error': 'AndroidManifest.xml bulunamadı'}
        
        # Gerçek implementasyonda binary XML parser kullanılır
        # Bu örnekte simulated analysis
        
        manifest_analysis = {
            'security_issues': self._find_manifest_security_issues(manifest_path),
            'exported_components': self._find_exported_components(manifest_path),
            'intent_filters': self._analyze_intent_filters(manifest_path),
            'custom_permissions': self._find_custom_permissions(manifest_path),
            'backup_settings': self._check_backup_settings(manifest_path),
            'debug_settings': self._check_debug_settings(manifest_path)
        }
        
        return manifest_analysis
    
    def _find_manifest_security_issues(self, manifest_path):
        """Manifest güvenlik sorunlarını bul"""
        # Simulated security issue detection
        return [
            {
                'issue': 'Debug mode enabled',
                'severity': 'medium',
                'description': 'android:debuggable="true" production\'da güvenlik riski'
            },
            {
                'issue': 'Backup allowed',
                'severity': 'low',
                'description': 'android:allowBackup="true" veri sızıntısı riski'
            }
        ]
    
    def _find_exported_components(self, manifest_path):
        """Export edilen bileşenleri bul"""
        # Simulated exported component detection
        return {
            'activities': [
                {'name': 'MainActivity', 'exported': True, 'protected': False},
                {'name': 'DeepLinkActivity', 'exported': True, 'protected': False}
            ],
            'services': [
                {'name': 'BackgroundService', 'exported': True, 'protected': False}
            ],
            'receivers': [
                {'name': 'BootReceiver', 'exported': True, 'protected': False}
            ],
            'providers': []
        }
    
    def _analyze_intent_filters(self, manifest_path):
        """Intent filter'ları analiz et"""
        # Simulated intent filter analysis
        return [
            {
                'component': 'DeepLinkActivity',
                'action': 'android.intent.action.VIEW',
                'data_scheme': 'myapp',
                'security_risk': 'medium',
                'description': 'Deep link güvenlik kontrolü gerekli'
            }
        ]
    
    def _find_custom_permissions(self, manifest_path):
        """Özel izinleri bul"""
        # Simulated custom permission detection
        return [
            {
                'name': 'com.example.app.CUSTOM_PERMISSION',
                'protection_level': 'normal',
                'description': 'Custom permission for app communication'
            }
        ]
    
    def _check_backup_settings(self, manifest_path):
        """Backup ayarlarını kontrol et"""
        return {
            'backup_allowed': True,
            'backup_agent': None,
            'full_backup_content': None,
            'security_risk': 'medium'
        }
    
    def _check_debug_settings(self, manifest_path):
        """Debug ayarlarını kontrol et"""
        return {
            'debuggable': True,
            'security_risk': 'high',
            'recommendation': 'Production build\'de debug mode\'u devre dışı bırakın'
        }
    
    def _comprehensive_permission_analysis(self, extract_dir):
        """Kapsamlı izin analizi"""
        # Simulated comprehensive permission analysis
        return {
            'requested_permissions': [
                'android.permission.INTERNET',
                'android.permission.ACCESS_FINE_LOCATION',
                'android.permission.CAMERA',
                'android.permission.READ_CONTACTS'
            ],
            'dangerous_permissions': [
                'android.permission.ACCESS_FINE_LOCATION',
                'android.permission.CAMERA',
                'android.permission.READ_CONTACTS'
            ],
            'permission_usage_analysis': self._analyze_permission_usage(extract_dir),
            'over_privileged_permissions': self._find_over_privileged_permissions(extract_dir)
        }
    
    def _analyze_permission_usage(self, extract_dir):
        """İzin kullanımını analiz et"""
        # Simulated permission usage analysis
        return [
            {
                'permission': 'android.permission.CAMERA',
                'used_in_code': True,
                'usage_locations': ['CameraActivity.java:45', 'PhotoUtils.java:23'],
                'justified': True
            },
            {
                'permission': 'android.permission.READ_CONTACTS',
                'used_in_code': False,
                'usage_locations': [],
                'justified': False,
                'recommendation': 'Kullanılmayan izni kaldırın'
            }
        ]
    
    def _find_over_privileged_permissions(self, extract_dir):
        """Gereksiz izinleri bul"""
        # Simulated over-privileged permission detection
        return [
            {
                'permission': 'android.permission.READ_CONTACTS',
                'reason': 'Kod içinde kullanım bulunamadı',
                'recommendation': 'İzni manifest\'ten kaldırın'
            }
        ]
    
    def _analyze_component_security(self, extract_dir):
        """Bileşen güvenliğini analiz et"""
        return {
            'exported_activities': self._analyze_exported_activities(extract_dir),
            'exported_services': self._analyze_exported_services(extract_dir),
            'exported_receivers': self._analyze_exported_receivers(extract_dir),
            'content_providers': self._analyze_content_providers(extract_dir)
        }
    
    def _analyze_exported_activities(self, extract_dir):
        """Export edilen activity'leri analiz et"""
        # Simulated exported activity analysis
        return [
            {
                'name': 'DeepLinkActivity',
                'security_issues': [
                    'Input validation eksik',
                    'Intent data doğrulaması yok'
                ],
                'risk_level': 'high'
            }
        ]
    
    def _analyze_exported_services(self, extract_dir):
        """Export edilen service'leri analiz et"""
        # Simulated exported service analysis
        return [
            {
                'name': 'BackgroundService',
                'security_issues': [
                    'Authentication kontrolü yok',
                    'Herhangi bir uygulama erişebilir'
                ],
                'risk_level': 'medium'
            }
        ]
    
    def _analyze_exported_receivers(self, extract_dir):
        """Export edilen receiver'ları analiz et"""
        # Simulated exported receiver analysis
        return [
            {
                'name': 'BootReceiver',
                'security_issues': [
                    'Broadcast intent doğrulaması yok'
                ],
                'risk_level': 'low'
            }
        ]
    
    def _analyze_content_providers(self, extract_dir):
        """Content provider'ları analiz et"""
        # Simulated content provider analysis
        return []
    
    def _deep_code_analysis(self, extract_dir):
        """Derinlemesine kod analizi"""
        # DEX dosyalarını bul
        dex_files = self._find_dex_files(extract_dir)
        
        code_analysis = {
            'dex_files': dex_files,
            'vulnerable_patterns': self._scan_for_vulnerable_patterns(extract_dir),
            'crypto_analysis': self._analyze_cryptographic_usage(extract_dir),
            'network_security': self._analyze_network_security_code(extract_dir),
            'data_storage': self._analyze_data_storage_code(extract_dir)
        }
        
        return code_analysis
    
    def _find_dex_files(self, extract_dir):
        """DEX dosyalarını bul"""
        dex_files = []
        
        for root, dirs, files in os.walk(extract_dir):
            for file in files:
                if file.endswith('.dex'):
                    dex_files.append(os.path.join(root, file))
        
        return dex_files
    
    def _scan_for_vulnerable_patterns(self, extract_dir):
        """Zafiyet desenlerini tara"""
        vulnerabilities = []
        
        # Simulated vulnerable pattern scanning
        vulnerabilities.extend([
            {
                'pattern': 'SQL Injection',
                'file': 'DatabaseHelper.smali',
                'line': 45,
                'code': 'SELECT * FROM users WHERE id = " + userId',
                'severity': 'high'
            },
            {
                'pattern': 'Hardcoded Secret',
                'file': 'ApiClient.smali',
                'line': 23,
                'code': 'const-string v0, "secret_api_key_12345"',
                'severity': 'critical'
            }
        ])
        
        return vulnerabilities
    
    def _analyze_cryptographic_usage(self, extract_dir):
        """Kriptografik kullanımı analiz et"""
        # Simulated crypto analysis
        return {
            'encryption_algorithms': ['AES', 'DES'],
            'weak_algorithms': ['DES'],
            'key_management_issues': [
                'Hardcoded encryption key',
                'Weak key generation'
            ],
            'random_number_generation': 'insecure'
        }
    
    def _analyze_network_security_code(self, extract_dir):
        """Ağ güvenliği kodunu analiz et"""
        # Simulated network security analysis
        return {
            'http_usage': True,
            'certificate_validation': 'disabled',
            'hostname_verification': 'disabled',
            'ssl_pinning': False,
            'security_issues': [
                'HTTP kullanımı tespit edildi',
                'SSL sertifika doğrulaması devre dışı',
                'Hostname verification devre dışı'
            ]
        }
    
    def _analyze_data_storage_code(self, extract_dir):
        """Veri depolama kodunu analiz et"""
        # Simulated data storage analysis
        return {
            'shared_preferences_usage': True,
            'database_usage': True,
            'file_storage_usage': True,
            'encryption_used': False,
            'security_issues': [
                'Hassas veriler şifrelenmeden SharedPreferences\'te saklanıyor',
                'Database şifrelenmemiş',
                'External storage\'da hassas dosyalar'
            ]
        }
    
    def _analyze_resources(self, extract_dir):
        """Kaynak dosyalarını analiz et"""
        return {
            'strings_analysis': self._analyze_strings(extract_dir),
            'assets_analysis': self._analyze_assets(extract_dir),
            'raw_resources': self._analyze_raw_resources(extract_dir)
        }
    
    def _analyze_strings(self, extract_dir):
        """String kaynaklarını analiz et"""
        # Simulated string analysis
        return {
            'hardcoded_secrets': [
                {'string': 'api_key_12345', 'file': 'strings.xml', 'risk': 'high'},
                {'string': 'admin_password', 'file': 'strings.xml', 'risk': 'critical'}
            ],
            'sensitive_urls': [
                {'url': 'http://api.example.com', 'file': 'strings.xml', 'risk': 'medium'}
            ]
        }
    
    def _analyze_assets(self, extract_dir):
        """Asset dosyalarını analiz et"""
        assets_dir = os.path.join(extract_dir, 'assets')
        
        if not os.path.exists(assets_dir):
            return {'assets_found': False}
        
        # Simulated asset analysis
        return {
            'assets_found': True,
            'sensitive_files': [
                {'file': 'config.json', 'contains_secrets': True},
                {'file': 'database.db', 'encrypted': False}
            ]
        }
    
    def _analyze_raw_resources(self, extract_dir):
        """Raw kaynaklarını analiz et"""
        raw_dir = os.path.join(extract_dir, 'res', 'raw')
        
        if not os.path.exists(raw_dir):
            return {'raw_resources_found': False}
        
        # Simulated raw resource analysis
        return {
            'raw_resources_found': True,
            'sensitive_files': []
        }
    
    def _analyze_native_libraries(self, extract_dir):
        """Native kütüphaneleri analiz et"""
        lib_dir = os.path.join(extract_dir, 'lib')
        
        if not os.path.exists(lib_dir):
            return {'native_libraries_found': False}
        
        # Simulated native library analysis
        return {
            'native_libraries_found': True,
            'architectures': ['arm64-v8a', 'armeabi-v7a'],
            'libraries': [
                {'name': 'libnative.so', 'architecture': 'arm64-v8a', 'stripped': True}
            ],
            'security_analysis': {
                'stack_protection': 'enabled',
                'fortify_source': 'enabled',
                'relro': 'full',
                'nx_bit': 'enabled'
            }
        }
    
    def _analyze_certificate(self, apk_path):
        """APK sertifikasını analiz et"""
        try:
            # jarsigner ile sertifika bilgilerini al
            cmd = ['jarsigner', '-verify', '-verbose', '-certs', apk_path]
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            # Simulated certificate analysis
            return {
                'is_signed': True,
                'signature_algorithm': 'SHA256withRSA',
                'certificate_valid': True,
                'certificate_issues': [],
                'debug_certificate': False
            }
        
        except FileNotFoundError:
            # jarsigner bulunamadı
            return {
                'is_signed': True,
                'signature_algorithm': 'SHA256withRSA',
                'certificate_valid': True,
                'certificate_issues': [],
                'debug_certificate': False
            }
    
    def _cleanup_temp_files(self, extract_dir):
        """Geçici dosyaları temizle"""
        try:
            import shutil
            shutil.rmtree(extract_dir)
            print(f"[+] Geçici dosyalar temizlendi: {extract_dir}")
        except Exception as e:
            print(f"[-] Geçici dosya temizleme hatası: {e}")

# Kullanım örneği
if __name__ == "__main__":
    analyzer = AndroidStaticAnalyzer()
    
    apk_path = "/path/to/test.apk"
    if os.path.exists(apk_path):
        results = analyzer.analyze_apk_comprehensive(apk_path)
        
        if results:
            print("[+] Android Statik Analiz Sonuçları:")
            print(json.dumps(results, indent=2))
        else:
            print("[-] Analiz başarısız")
    else:
        print(f"[-] APK dosyası bulunamadı: {apk_path}")
```

## 🍎 iOS Güvenlik Analiz Araçları

### iOS Application Security Analyzer

```python
#!/usr/bin/env python3
"""
iOS Application Security Analyzer
Author: ibrahimsql
Description: iOS uygulamaları için güvenlik analiz araçları
"""

import os
import re
import json
import plistlib
import subprocess
from pathlib import Path
import zipfile

class iOSSecurityAnalyzer:
    def __init__(self):
        self.sensitive_entitlements = [
            'com.apple.developer.healthkit',
            'com.apple.developer.homekit',
            'com.apple.security.application-groups',
            'keychain-access-groups',
            'com.apple.developer.networking.wifi-info',
            'com.apple.developer.location'
        ]
        
        self.dangerous_apis = [
            'CC_MD5',
            'CC_SHA1',
            'kSecAttrAccessibleAlways',
            'NSAllowsArbitraryLoads',
            'UIWebView'
        ]
    
    def analyze_ipa(self, ipa_path):
        """IPA dosyasını analiz et"""
        print(f"[+] iOS IPA analizi başlatılıyor: {ipa_path}")
        
        # IPA'yı extract et
        extract_dir = self._extract_ipa(ipa_path)
        
        if not extract_dir:
            return None
        
        analysis_results = {
            'basic_info': self._get_basic_ipa_info(extract_dir),
            'plist_analysis': self._analyze_info_plist(extract_dir),
            'entitlements_analysis': self._analyze_entitlements(extract_dir),
            'binary_analysis': self._analyze_binary(extract_dir),
            'code_signing': self._analyze_code_signing(extract_dir),
            'security_features': self._analyze_security_features(extract_dir),
            'privacy_analysis': self._analyze_privacy_usage(extract_dir)
        }
        
        # Geçici dosyaları temizle
        self._cleanup_temp_files(extract_dir)
        
        return analysis_results
    
    def _extract_ipa(self, ipa_path):
        """IPA dosyasını extract et"""
        try:
            extract_dir = f"/tmp/ipa_analysis_{os.path.basename(ipa_path)}"
            
            with zipfile.ZipFile(ipa_path, 'r') as ipa_zip:
                ipa_zip.extractall(extract_dir)
            
            print(f"[+] IPA extract edildi: {extract_dir}")
            return extract_dir
        
        except Exception as e:
            print(f"[-] IPA extract hatası: {e}")
            return None
    
    def _get_basic_ipa_info(self, extract_dir):
        """Temel IPA bilgilerini al"""
        # Payload dizinini bul
        payload_dir = os.path.join(extract_dir, 'Payload')
        
        if not os.path.exists(payload_dir):
            return {'error': 'Payload dizini bulunamadı'}
        
        # .app dizinini bul
        app_dirs = [d for d in os.listdir(payload_dir) if d.endswith('.app')]
        
        if not app_dirs:
            return {'error': '.app dizini bulunamadı'}
        
        app_dir = os.path.join(payload_dir, app_dirs[0])
        
        return {
            'app_name': app_dirs[0].replace('.app', ''),
            'app_directory': app_dir,
            'bundle_size': self._get_directory_size(app_dir)
        }
    
    def _get_directory_size(self, directory):
        """Dizin boyutunu hesapla"""
        total_size = 0
        for dirpath, dirnames, filenames in os.walk(directory):
            for filename in filenames:
                filepath = os.path.join(dirpath, filename)
                total_size += os.path.getsize(filepath)
        return total_size
    
    def _analyze_info_plist(self, extract_dir):
        """Info.plist dosyasını analiz et"""
        # .app dizinini bul
        payload_dir = os.path.join(extract_dir, 'Payload')
        app_dirs = [d for d in os.listdir(payload_dir) if d.endswith('.app')]
        
        if not app_dirs:
            return {'error': '.app dizini bulunamadı'}
        
        app_dir = os.path.join(payload_dir, app_dirs[0])
        plist_path = os.path.join(app_dir, 'Info.plist')
        
        if not os.path.exists(plist_path):
            return {'error': 'Info.plist bulunamadı'}
        
        try:
            with open(plist_path, 'rb') as f:
                plist_data = plistlib.load(f)
            
            plist_analysis = {
                'bundle_identifier': plist_data.get('CFBundleIdentifier'),
                'bundle_version': plist_data.get('CFBundleVersion'),
                'bundle_short_version': plist_data.get('CFBundleShortVersionString'),
                'minimum_os_version': plist_data.get('MinimumOSVersion'),
                'supported_platforms': plist_data.get('CFBundleSupportedPlatforms', []),
                'url_schemes': self._extract_url_schemes(plist_data),
                'ats_settings': self._analyze_ats_settings(plist_data),
                'privacy_permissions': self._extract_privacy_permissions(plist_data),
                'security_issues': self._find_plist_security_issues(plist_data)
            }
            
            return plist_analysis
        
        except Exception as e:
            return {'error': f'Info.plist analiz hatası: {e}'}
    
    def _extract_url_schemes(self, plist_data):
        """URL scheme'lerini çıkar"""
        url_schemes = []
        
        url_types = plist_data.get('CFBundleURLTypes', [])
        for url_type in url_types:
            schemes = url_type.get('CFBundleURLSchemes', [])
            url_schemes.extend(schemes)
        
        return url_schemes
    
    def _analyze_ats_settings(self, plist_data):
        """App Transport Security ayarlarını analiz et"""
        ats_settings = plist_data.get('NSAppTransportSecurity', {})
        
        analysis = {
            'allows_arbitrary_loads': ats_settings.get('NSAllowsArbitraryLoads', False),
            'allows_local_networking': ats_settings.get('NSAllowsLocalNetworking', False),
            'exception_domains': list(ats_settings.get('NSExceptionDomains', {}).keys()),
            'security_risk': 'high' if ats_settings.get('NSAllowsArbitraryLoads') else 'low'
        }
        
        return analysis
    
    def _extract_privacy_permissions(self, plist_data):
        """Gizlilik izinlerini çıkar"""
        privacy_keys = {
            'NSCameraUsageDescription': 'Camera',
            'NSMicrophoneUsageDescription': 'Microphone',
            'NSLocationWhenInUseUsageDescription': 'Location (When in Use)',
            'NSLocationAlwaysAndWhenInUseUsageDescription': 'Location (Always)',
            'NSContactsUsageDescription': 'Contacts',
            'NSCalendarsUsageDescription': 'Calendars',
            'NSRemindersUsageDescription': 'Reminders',
            'NSPhotoLibraryUsageDescription': 'Photo Library',
            'NSHealthShareUsageDescription': 'Health (Read)',
            'NSHealthUpdateUsageDescription': 'Health (Write)',
            'NSFaceIDUsageDescription': 'Face ID',
            'NSBluetoothPeripheralUsageDescription': 'Bluetooth'
        }
        
        permissions = {}
        for key, description in privacy_keys.items():
            if key in plist_data:
                permissions[description] = plist_data[key]
        
        return permissions
    
    def _find_plist_security_issues(self, plist_data):
        """Info.plist güvenlik sorunlarını bul"""
        issues = []
        
        # ATS devre dışı kontrolü
        if plist_data.get('NSAppTransportSecurity', {}).get('NSAllowsArbitraryLoads'):
            issues.append({
                'issue': 'App Transport Security Disabled',
                'severity': 'high',
                'description': 'NSAllowsArbitraryLoads=true güvenlik riski'
            })
        
        # UIWebView kullanımı
        if 'UIWebView' in str(plist_data):
            issues.append({
                'issue': 'UIWebView Usage',
                'severity': 'medium',
                'description': 'UIWebView deprecated, WKWebView kullanın'
            })
        
        return issues
    
    def _analyze_entitlements(self, extract_dir):
        """Entitlement dosyasını analiz et"""
        # .app dizinini bul
        payload_dir = os.path.join(extract_dir, 'Payload')
        app_dirs = [d for d in os.listdir(payload_dir) if d.endswith('.app')]
        
        if not app_dirs:
            return {'error': '.app dizini bulunamadı'}
        
        app_dir = os.path.join(payload_dir, app_dirs[0])
        entitlements_path = os.path.join(app_dir, 'entitlements.plist')
        
        # Simulated entitlements analysis
        return {
            'entitlements_found': True,
            'sensitive_entitlements': [
                'keychain-access-groups',
                'com.apple.developer.healthkit'
            ],
            'security_risks': [
                {
                    'entitlement': 'keychain-access-groups',
                    'risk': 'medium',
                    'description': 'Keychain erişimi hassas veri sızıntısı riski'
                }
            ]
        }
    
    def _analyze_binary(self, extract_dir):
        """Binary dosyayı analiz et"""
        # Simulated binary analysis
        return {
            'architecture': 'arm64',
            'encryption': True,
            'pie_enabled': True,
            'arc_enabled': True,
            'stack_canary': True,
            'fortify_source': True,
            'vulnerable_functions': [
                {'function': 'strcpy', 'location': '0x1000', 'risk': 'high'},
                {'function': 'gets', 'location': '0x2000', 'risk': 'critical'}
            ]
        }
    
    def _analyze_code_signing(self, extract_dir):
        """Code signing analizi"""
        # Simulated code signing analysis
        return {
            'is_signed': True,
            'signature_valid': True,
            'provisioning_profile': 'distribution',
            'certificate_type': 'App Store',
            'team_id': 'ABC123DEF4'
        }
    
    def _analyze_security_features(self, extract_dir):
        """Güvenlik özelliklerini analiz et"""
        # Simulated security features analysis
        return {
            'jailbreak_detection': False,
            'anti_debugging': False,
            'obfuscation': False,
            'ssl_pinning': False,
            'runtime_protection': False
        }
    
    def _analyze_privacy_usage(self, extract_dir):
        """Gizlilik kullanımını analiz et"""
        # Simulated privacy analysis
        return {
            'location_usage': True,
            'camera_usage': True,
            'microphone_usage': False,
            'contacts_usage': True,
            'privacy_risks': [
                {
                    'feature': 'Location',
                    'risk': 'medium',
                    'description': 'Konum verisi sürekli toplanıyor'
                }
            ]
        }
    
    def _cleanup_temp_files(self, extract_dir):
        """Geçici dosyaları temizle"""
        try:
            import shutil
            shutil.rmtree(extract_dir)
            print(f"[+] Geçici dosyalar temizlendi: {extract_dir}")
        except Exception as e:
            print(f"[-] Geçici dosya temizleme hatası: {e}")

# Kullanım örneği
if __name__ == "__main__":
    analyzer = iOSSecurityAnalyzer()
    
    ipa_path = "/path/to/test.ipa"
    if os.path.exists(ipa_path):
        results = analyzer.analyze_ipa(ipa_path)
        
        if results:
            print("[+] iOS Güvenlik Analiz Sonuçları:")
            print(json.dumps(results, indent=2))
        else:
            print("[-] Analiz başarısız")
    else:
        print(f"[-] IPA dosyası bulunamadı: {ipa_path}")
```

## 🔬 Gerçek Dünya Vaka Çalışmaları

### 📱 Vaka 1: Finansal Uygulama Güvenlik Testi

**Senaryo**: Bir mobil bankacılık uygulamasının güvenlik değerlendirmesi

**Bulgular**:
- SSL pinning bypass edilebiliyor
- PIN kodu SharedPreferences'te plain text olarak saklanıyor
- Root detection kolayca bypass edilebiliyor
- API anahtarları hardcoded

**Çözümler**:
- Certificate pinning implementasyonu
- Keychain kullanarak güvenli veri saklama
- Gelişmiş root detection mekanizmaları
- Runtime application self-protection (RASP)

### 📱 Vaka 2: Sosyal Medya Uygulaması Privacy Testi

**Senaryo**: Popüler sosyal medya uygulamasının gizlilik analizi

**Bulgular**:
- Konum verisi sürekli toplanıyor
- Kişi listesi şifrelenmeden saklanıyor
- Third-party SDK'lar hassas veri topluyor
- Deep link zafiyetleri mevcut

**Çözümler**:
- Minimal veri toplama politikası
- End-to-end encryption
- SDK güvenlik değerlendirmesi
- Deep link input validation

### 📱 Vaka 3: IoT Mobil Kontrol Uygulaması

**Senaryo**: Smart home kontrol uygulamasının güvenlik testi

**Bulgular**:
- Cihaz parolaları hardcoded
- Ağ trafiği şifrelenmemiş
- Firmware update mekanizması güvensiz
- Device authentication zayıf

**Çözümler**:
- Secure device pairing
- TLS 1.3 kullanımı
- Signed firmware updates
- Mutual authentication

## ❓ Bilgi Kontrol Soruları

### 📚 Teorik Sorular

1. **OWASP Mobile Top 10'da yer alan ana güvenlik riskleri nelerdir?**
2. **Android ve iOS arasındaki güvenlik mimarisi farkları nelerdir?**
3. **Certificate pinning nedir ve neden önemlidir?**
4. **Mobil uygulamalarda veri şifreleme best practice'leri nelerdir?**
5. **Root/Jailbreak detection teknikleri nelerdir?**

### 🛠️ Pratik Sorular

1. **Bir APK dosyasını statik olarak nasıl analiz edersiniz?**
2. **Frida ile runtime manipulation nasıl yapılır?**
3. **Mobil ağ trafiğini nasıl yakalayıp analiz edersiniz?**
4. **iOS uygulamasının binary'sini nasıl reverse engineer edersiniz?**
5. **Mobil malware detection için hangi teknikleri kullanırsınız?**

## 📋 Pratik Ödevler

### 🎯 Ödev 1: Android Uygulama Güvenlik Analizi

**Hedef**: Verilen Android uygulamasının kapsamlı güvenlik analizi

**Görevler**:
1. APK dosyasını statik olarak analiz edin
2. Manifest dosyasındaki güvenlik sorunlarını tespit edin
3. Hardcoded secret'ları bulun
4. Dinamik analiz ile runtime davranışları inceleyin
5. Detaylı güvenlik raporu hazırlayın

**Teslim Edilecekler**:
- Analiz raporu (PDF)
- Kullanılan araçların listesi
- Bulunan zafiyetlerin PoC'leri
- Düzeltme önerileri

### 🎯 Ödev 2: iOS Penetrasyon Testi

**Hedef**: iOS uygulamasının güvenlik değerlendirmesi

**Görevler**:
1. IPA dosyasını analiz edin
2. Info.plist güvenlik ayarlarını kontrol edin
3. Binary protection mekanizmalarını test edin
4. Network security testleri yapın
5. Privacy compliance kontrolü yapın

**Teslim Edilecekler**:
- iOS güvenlik test raporu
- Jailbreak detection bypass teknikleri
- SSL pinning bypass yöntemleri
- Privacy risk assessment

### 🎯 Ödev 3: Mobil Malware Analizi

**Hedef**: Mobil malware örneğinin analizi

**Görevler**:
1. Malware sample'ını güvenli ortamda analiz edin
2. Behavioral analysis yapın
3. C&C communication'ı tespit edin
4. Persistence mekanizmalarını analiz edin
5. IOC'leri çıkarın

**Teslim Edilecekler**:
- Malware analiz raporu
- Behavioral indicators
- Network signatures
- Mitigation strategies

## 📊 Performans Metrikleri

```python
#!/usr/bin/env python3
"""
Mobile Penetration Testing Performance Tracker
Author: ibrahimsql
Description: Mobil penetrasyon testi performans izleme sistemi
"""

import time
import json
from datetime import datetime, timedelta
from collections import defaultdict

class MobilePentestPerformanceTracker:
    def __init__(self):
        self.test_sessions = []
        self.vulnerability_stats = defaultdict(int)
        self.tool_usage_stats = defaultdict(int)
        self.platform_stats = defaultdict(int)
        
    def start_test_session(self, platform, app_name, test_type):
        """Test oturumu başlat"""
        session = {
            'session_id': f"mobile_test_{int(time.time())}",
            'platform': platform,
            'app_name': app_name,
            'test_type': test_type,
            'start_time': datetime.now(),
            'end_time': None,
            'vulnerabilities_found': [],
            'tools_used': [],
            'test_coverage': {},
            'performance_metrics': {}
        }
        
        self.test_sessions.append(session)
        return session['session_id']
    
    def end_test_session(self, session_id):
        """Test oturumu sonlandır"""
        session = self._get_session(session_id)
        if session:
            session['end_time'] = datetime.now()
            session['duration'] = (session['end_time'] - session['start_time']).total_seconds()
            
            # İstatistikleri güncelle
            self.platform_stats[session['platform']] += 1
            for vuln in session['vulnerabilities_found']:
                self.vulnerability_stats[vuln['type']] += 1
            for tool in session['tools_used']:
                self.tool_usage_stats[tool] += 1
    
    def add_vulnerability(self, session_id, vuln_type, severity, description):
        """Zafiyet ekle"""
        session = self._get_session(session_id)
        if session:
            vulnerability = {
                'type': vuln_type,
                'severity': severity,
                'description': description,
                'found_at': datetime.now(),
                'owasp_category': self._map_to_owasp_mobile(vuln_type)
            }
            session['vulnerabilities_found'].append(vulnerability)
    
    def add_tool_usage(self, session_id, tool_name, usage_duration):
        """Araç kullanımı ekle"""
        session = self._get_session(session_id)
        if session:
            tool_usage = {
                'tool': tool_name,
                'duration': usage_duration,
                'used_at': datetime.now()
            }
            session['tools_used'].append(tool_usage)
    
    def update_test_coverage(self, session_id, coverage_data):
        """Test kapsamını güncelle"""
        session = self._get_session(session_id)
        if session:
            session['test_coverage'].update(coverage_data)
    
    def calculate_performance_metrics(self, session_id):
        """Performans metriklerini hesapla"""
        session = self._get_session(session_id)
        if not session or not session['end_time']:
            return None
        
        metrics = {
            'total_duration': session['duration'],
            'vulnerabilities_per_hour': len(session['vulnerabilities_found']) / (session['duration'] / 3600),
            'critical_vulnerabilities': len([v for v in session['vulnerabilities_found'] if v['severity'] == 'critical']),
            'high_vulnerabilities': len([v for v in session['vulnerabilities_found'] if v['severity'] == 'high']),
            'medium_vulnerabilities': len([v for v in session['vulnerabilities_found'] if v['severity'] == 'medium']),
            'low_vulnerabilities': len([v for v in session['vulnerabilities_found'] if v['severity'] == 'low']),
            'tools_efficiency': self._calculate_tools_efficiency(session),
            'owasp_coverage': self._calculate_owasp_coverage(session),
            'security_score': self._calculate_security_score(session)
        }
        
        session['performance_metrics'] = metrics
        return metrics
    
    def _get_session(self, session_id):
        """Session'ı bul"""
        for session in self.test_sessions:
            if session['session_id'] == session_id:
                return session
        return None
    
    def _map_to_owasp_mobile(self, vuln_type):
        """Zafiyeti OWASP Mobile kategorisine eşle"""
        mapping = {
            'insecure_data_storage': 'M2',
            'insecure_communication': 'M3',
            'insecure_authentication': 'M4',
            'insufficient_cryptography': 'M5',
            'insecure_authorization': 'M6',
            'client_code_quality': 'M7',
            'code_tampering': 'M8',
            'reverse_engineering': 'M9',
            'extraneous_functionality': 'M10'
        }
        return mapping.get(vuln_type, 'M1')
    
    def _calculate_tools_efficiency(self, session):
        """Araç verimliliğini hesapla"""
        if not session['tools_used']:
            return 0
        
        total_tool_time = sum(tool['duration'] for tool in session['tools_used'])
        vulnerabilities_found = len(session['vulnerabilities_found'])
        
        if total_tool_time == 0:
            return 0
        
        return vulnerabilities_found / (total_tool_time / 3600)  # vulns per hour
    
    def _calculate_owasp_coverage(self, session):
        """OWASP Mobile Top 10 kapsama oranını hesapla"""
        covered_categories = set()
        for vuln in session['vulnerabilities_found']:
            covered_categories.add(vuln['owasp_category'])
        
        return (len(covered_categories) / 10) * 100  # OWASP Mobile Top 10
    
    def _calculate_security_score(self, session):
        """Güvenlik puanını hesapla (0-100)"""
        if not session['vulnerabilities_found']:
            return 100
        
        severity_weights = {
            'critical': 10,
            'high': 7,
            'medium': 4,
            'low': 1
        }
        
        total_weight = sum(severity_weights[vuln['severity']] for vuln in session['vulnerabilities_found'])
        max_possible_weight = len(session['vulnerabilities_found']) * 10
        
        security_score = max(0, 100 - (total_weight / max_possible_weight * 100))
        return round(security_score, 2)
    
    def generate_performance_report(self, time_period_days=30):
        """Performans raporu oluştur"""
        cutoff_date = datetime.now() - timedelta(days=time_period_days)
        recent_sessions = [s for s in self.test_sessions if s['start_time'] >= cutoff_date]
        
        if not recent_sessions:
            return {'error': 'Belirtilen dönemde test oturumu bulunamadı'}
        
        report = {
            'period': f'Son {time_period_days} gün',
            'total_sessions': len(recent_sessions),
            'total_vulnerabilities': sum(len(s['vulnerabilities_found']) for s in recent_sessions),
            'platform_distribution': self._calculate_platform_distribution(recent_sessions),
            'vulnerability_trends': self._calculate_vulnerability_trends(recent_sessions),
            'tool_effectiveness': self._calculate_tool_effectiveness(recent_sessions),
            'average_session_duration': self._calculate_average_duration(recent_sessions),
            'top_vulnerability_types': self._get_top_vulnerability_types(recent_sessions),
            'security_score_trend': self._calculate_security_score_trend(recent_sessions)
        }
        
        return report
    
    def _calculate_platform_distribution(self, sessions):
        """Platform dağılımını hesapla"""
        platform_count = defaultdict(int)
        for session in sessions:
            platform_count[session['platform']] += 1
        return dict(platform_count)
    
    def _calculate_vulnerability_trends(self, sessions):
        """Zafiyet trendlerini hesapla"""
        trends = defaultdict(lambda: defaultdict(int))
        
        for session in sessions:
            date_key = session['start_time'].strftime('%Y-%m-%d')
            for vuln in session['vulnerabilities_found']:
                trends[date_key][vuln['severity']] += 1
        
        return dict(trends)
    
    def _calculate_tool_effectiveness(self, sessions):
        """Araç etkinliğini hesapla"""
        tool_stats = defaultdict(lambda: {'usage_count': 0, 'total_vulns': 0, 'total_time': 0})
        
        for session in sessions:
            for tool in session['tools_used']:
                tool_name = tool['tool']
                tool_stats[tool_name]['usage_count'] += 1
                tool_stats[tool_name]['total_time'] += tool['duration']
            
            # Her session'daki vulnerability'leri araçlara eşitle
            vulns_per_tool = len(session['vulnerabilities_found']) / max(len(session['tools_used']), 1)
            for tool in session['tools_used']:
                tool_stats[tool['tool']]['total_vulns'] += vulns_per_tool
        
        # Etkinlik skorunu hesapla
        effectiveness = {}
        for tool, stats in tool_stats.items():
            if stats['total_time'] > 0:
                effectiveness[tool] = {
                    'vulns_per_hour': stats['total_vulns'] / (stats['total_time'] / 3600),
                    'usage_count': stats['usage_count'],
                    'avg_session_time': stats['total_time'] / stats['usage_count']
                }
        
        return effectiveness
    
    def _calculate_average_duration(self, sessions):
        """Ortalama oturum süresini hesapla"""
        completed_sessions = [s for s in sessions if s.get('duration')]
        if not completed_sessions:
            return 0
        
        total_duration = sum(s['duration'] for s in completed_sessions)
        return total_duration / len(completed_sessions)
    
    def _get_top_vulnerability_types(self, sessions, top_n=10):
        """En sık bulunan zafiyet tiplerini al"""
        vuln_count = defaultdict(int)
        
        for session in sessions:
            for vuln in session['vulnerabilities_found']:
                vuln_count[vuln['type']] += 1
        
        return dict(sorted(vuln_count.items(), key=lambda x: x[1], reverse=True)[:top_n])
    
    def _calculate_security_score_trend(self, sessions):
        """Güvenlik puanı trendini hesapla"""
        score_trend = {}
        
        for session in sessions:
            if 'performance_metrics' in session and 'security_score' in session['performance_metrics']:
                date_key = session['start_time'].strftime('%Y-%m-%d')
                if date_key not in score_trend:
                    score_trend[date_key] = []
                score_trend[date_key].append(session['performance_metrics']['security_score'])
        
        # Günlük ortalama skorları hesapla
        daily_averages = {}
        for date, scores in score_trend.items():
            daily_averages[date] = sum(scores) / len(scores)
        
        return daily_averages
    
    def export_metrics(self, filename):
        """Metrikleri dosyaya aktar"""
        export_data = {
            'export_date': datetime.now().isoformat(),
            'test_sessions': self.test_sessions,
            'vulnerability_stats': dict(self.vulnerability_stats),
            'tool_usage_stats': dict(self.tool_usage_stats),
            'platform_stats': dict(self.platform_stats)
        }
        
        with open(filename, 'w') as f:
            json.dump(export_data, f, indent=2, default=str)
        
        print(f"[+] Metrikler dışa aktarıldı: {filename}")

# Kullanım örneği
if __name__ == "__main__":
    tracker = MobilePentestPerformanceTracker()
    
    # Test oturumu başlat
    session_id = tracker.start_test_session('android', 'TestApp', 'security_assessment')
    
    # Zafiyet ekle
    tracker.add_vulnerability(session_id, 'insecure_data_storage', 'high', 'Hassas veriler şifrelenmeden saklanıyor')
    tracker.add_vulnerability(session_id, 'insecure_communication', 'medium', 'HTTP kullanımı tespit edildi')
    
    # Araç kullanımı ekle
    tracker.add_tool_usage(session_id, 'Frida', 1800)  # 30 dakika
    tracker.add_tool_usage(session_id, 'Burp Suite', 3600)  # 1 saat
    
    # Test kapsamını güncelle
    tracker.update_test_coverage(session_id, {
        'static_analysis': True,
        'dynamic_analysis': True,
        'network_analysis': True
    })
    
    # Oturumu sonlandır
    time.sleep(2)  # Simulated test duration
    tracker.end_test_session(session_id)
    
    # Performans metriklerini hesapla
    metrics = tracker.calculate_performance_metrics(session_id)
    print("[+] Performans Metrikleri:")
    print(json.dumps(metrics, indent=2))
    
    # Performans raporu oluştur
    report = tracker.generate_performance_report()
    print("\n[+] Performans Raporu:")
    print(json.dumps(report, indent=2))
    
    # Metrikleri dışa aktar
     tracker.export_metrics('mobile_pentest_metrics.json')
```

## 🤖 AI ve Makine Öğrenimi Uygulamaları

### AI-Powered Mobile Security Analysis

```python
#!/usr/bin/env python3
"""
AI-Powered Mobile Security Analyzer
Author: ibrahimsql
Description: Yapay zeka destekli mobil güvenlik analiz sistemi
"""

import numpy as np
import pandas as pd
from sklearn.ensemble import RandomForestClassifier, IsolationForest
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
import joblib
import json
import re
from datetime import datetime

class AIMobileSecurityAnalyzer:
    def __init__(self):
        self.malware_classifier = None
        self.anomaly_detector = None
        self.text_vectorizer = TfidfVectorizer(max_features=1000)
        self.vulnerability_predictor = None
        self.trained = False
        
    def extract_features_from_apk(self, apk_analysis_result):
        """APK analiz sonucundan özellik çıkarımı"""
        features = {
            # Manifest özellikleri
            'permission_count': len(apk_analysis_result.get('permissions', [])),
            'dangerous_permissions': self._count_dangerous_permissions(apk_analysis_result.get('permissions', [])),
            'activity_count': len(apk_analysis_result.get('activities', [])),
            'service_count': len(apk_analysis_result.get('services', [])),
            'receiver_count': len(apk_analysis_result.get('receivers', [])),
            
            # Code özellikleri
            'api_calls_count': len(apk_analysis_result.get('api_calls', [])),
            'suspicious_api_calls': self._count_suspicious_apis(apk_analysis_result.get('api_calls', [])),
            'string_count': len(apk_analysis_result.get('strings', [])),
            'url_count': self._count_urls(apk_analysis_result.get('strings', [])),
            'crypto_usage': self._detect_crypto_usage(apk_analysis_result.get('api_calls', [])),
            
            # Binary özellikleri
            'file_size': apk_analysis_result.get('file_size', 0),
            'dex_count': len(apk_analysis_result.get('dex_files', [])),
            'native_libs': len(apk_analysis_result.get('native_libraries', [])),
            'certificate_valid': apk_analysis_result.get('certificate_valid', True),
            
            # Network özellikleri
            'network_security_config': apk_analysis_result.get('network_security_config', False),
            'cleartext_traffic': apk_analysis_result.get('cleartext_traffic_permitted', True),
            'certificate_pinning': apk_analysis_result.get('certificate_pinning', False)
        }
        
        return list(features.values())
    
    def _count_dangerous_permissions(self, permissions):
        """Tehlikeli izinleri say"""
        dangerous_perms = [
            'android.permission.READ_SMS',
            'android.permission.SEND_SMS',
            'android.permission.READ_CONTACTS',
            'android.permission.ACCESS_FINE_LOCATION',
            'android.permission.RECORD_AUDIO',
            'android.permission.CAMERA',
            'android.permission.READ_PHONE_STATE',
            'android.permission.WRITE_EXTERNAL_STORAGE'
        ]
        return sum(1 for perm in permissions if perm in dangerous_perms)
    
    def _count_suspicious_apis(self, api_calls):
        """Şüpheli API çağrılarını say"""
        suspicious_apis = [
            'Runtime.exec',
            'ProcessBuilder',
            'TelephonyManager.getDeviceId',
            'SmsManager.sendTextMessage',
            'HttpURLConnection',
            'Socket',
            'Class.forName',
            'DexClassLoader'
        ]
        return sum(1 for api in api_calls if any(sus_api in api for sus_api in suspicious_apis))
    
    def _count_urls(self, strings):
        """URL sayısını hesapla"""
        url_pattern = r'https?://[^\s]+'
        return sum(1 for string in strings if re.search(url_pattern, string))
    
    def _detect_crypto_usage(self, api_calls):
        """Kriptografi kullanımını tespit et"""
        crypto_apis = ['Cipher', 'MessageDigest', 'KeyGenerator', 'SecretKey']
        return any(crypto_api in ' '.join(api_calls) for crypto_api in crypto_apis)
    
    def train_malware_classifier(self, training_data):
        """Malware sınıflandırıcısını eğit"""
        print("[+] Malware sınıflandırıcısı eğitiliyor...")
        
        # Özellikleri çıkar
        X = []
        y = []
        
        for sample in training_data:
            features = self.extract_features_from_apk(sample['analysis_result'])
            X.append(features)
            y.append(sample['label'])  # 0: benign, 1: malware
        
        X = np.array(X)
        y = np.array(y)
        
        # Veriyi böl
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
        
        # Modeli eğit
        self.malware_classifier = RandomForestClassifier(n_estimators=100, random_state=42)
        self.malware_classifier.fit(X_train, y_train)
        
        # Test et
        y_pred = self.malware_classifier.predict(X_test)
        print("[+] Malware Sınıflandırıcı Performansı:")
        print(classification_report(y_test, y_pred))
        
        # Anomali dedektörünü eğit
        self.anomaly_detector = IsolationForest(contamination=0.1, random_state=42)
        self.anomaly_detector.fit(X_train)
        
        self.trained = True
        print("[+] Model eğitimi tamamlandı")
    
    def predict_malware(self, apk_analysis_result):
        """Malware tahmini yap"""
        if not self.trained:
            return {'error': 'Model henüz eğitilmemiş'}
        
        features = np.array([self.extract_features_from_apk(apk_analysis_result)])
        
        # Malware tahmini
        malware_prob = self.malware_classifier.predict_proba(features)[0]
        malware_prediction = self.malware_classifier.predict(features)[0]
        
        # Anomali tespiti
        anomaly_score = self.anomaly_detector.decision_function(features)[0]
        is_anomaly = self.anomaly_detector.predict(features)[0] == -1
        
        return {
            'malware_probability': {
                'benign': float(malware_prob[0]),
                'malware': float(malware_prob[1])
            },
            'is_malware': bool(malware_prediction),
            'anomaly_score': float(anomaly_score),
            'is_anomaly': bool(is_anomaly),
            'risk_level': self._calculate_risk_level(malware_prob[1], anomaly_score),
            'confidence': float(max(malware_prob))
        }
    
    def _calculate_risk_level(self, malware_prob, anomaly_score):
        """Risk seviyesini hesapla"""
        if malware_prob > 0.8 or anomaly_score < -0.5:
            return 'critical'
        elif malware_prob > 0.6 or anomaly_score < -0.3:
            return 'high'
        elif malware_prob > 0.4 or anomaly_score < -0.1:
            return 'medium'
        else:
            return 'low'
    
    def analyze_app_behavior(self, dynamic_analysis_data):
        """Uygulama davranışını analiz et"""
        behavior_features = {
            'network_connections': len(dynamic_analysis_data.get('network_connections', [])),
            'file_operations': len(dynamic_analysis_data.get('file_operations', [])),
            'system_calls': len(dynamic_analysis_data.get('system_calls', [])),
            'api_calls_runtime': len(dynamic_analysis_data.get('api_calls', [])),
            'permission_requests': len(dynamic_analysis_data.get('permission_requests', [])),
            'suspicious_activities': self._detect_suspicious_activities(dynamic_analysis_data)
        }
        
        # Davranış anomalilerini tespit et
        anomalies = []
        
        # Ağ bağlantı anomalileri
        if behavior_features['network_connections'] > 50:
            anomalies.append({
                'type': 'excessive_network_activity',
                'severity': 'medium',
                'description': f"Aşırı ağ bağlantısı: {behavior_features['network_connections']}"
            })
        
        # Dosya işlem anomalileri
        if behavior_features['file_operations'] > 100:
            anomalies.append({
                'type': 'excessive_file_operations',
                'severity': 'medium',
                'description': f"Aşırı dosya işlemi: {behavior_features['file_operations']}"
            })
        
        # Şüpheli aktivite tespiti
        if behavior_features['suspicious_activities'] > 0:
            anomalies.append({
                'type': 'suspicious_behavior',
                'severity': 'high',
                'description': f"Şüpheli aktivite tespit edildi: {behavior_features['suspicious_activities']}"
            })
        
        return {
            'behavior_features': behavior_features,
            'anomalies': anomalies,
            'risk_score': self._calculate_behavior_risk_score(behavior_features, anomalies)
        }
    
    def _detect_suspicious_activities(self, dynamic_data):
        """Şüpheli aktiviteleri tespit et"""
        suspicious_count = 0
        
        # Şüpheli API çağrıları
        suspicious_apis = ['exec', 'su', 'chmod', 'mount']
        api_calls = dynamic_data.get('api_calls', [])
        for api in api_calls:
            if any(sus_api in api.lower() for sus_api in suspicious_apis):
                suspicious_count += 1
        
        # Şüpheli dosya erişimleri
        file_ops = dynamic_data.get('file_operations', [])
        suspicious_paths = ['/system/', '/data/data/', '/sdcard/']
        for file_op in file_ops:
            if any(sus_path in file_op.get('path', '') for sus_path in suspicious_paths):
                suspicious_count += 1
        
        return suspicious_count
    
    def _calculate_behavior_risk_score(self, features, anomalies):
        """Davranış risk skorunu hesapla"""
        base_score = 0
        
        # Özellik bazlı skor
        base_score += min(features['network_connections'] / 10, 10)
        base_score += min(features['file_operations'] / 20, 10)
        base_score += features['suspicious_activities'] * 5
        
        # Anomali bazlı skor
        for anomaly in anomalies:
            if anomaly['severity'] == 'critical':
                base_score += 20
            elif anomaly['severity'] == 'high':
                base_score += 15
            elif anomaly['severity'] == 'medium':
                base_score += 10
            else:
                base_score += 5
        
        return min(base_score, 100)
    
    def generate_ai_security_report(self, app_analysis):
        """AI destekli güvenlik raporu oluştur"""
        report = {
            'analysis_timestamp': datetime.now().isoformat(),
            'app_info': app_analysis.get('app_info', {}),
            'ai_predictions': {},
            'risk_assessment': {},
            'recommendations': []
        }
        
        # Malware tahmini
        if 'static_analysis' in app_analysis:
            malware_prediction = self.predict_malware(app_analysis['static_analysis'])
            report['ai_predictions']['malware_detection'] = malware_prediction
        
        # Davranış analizi
        if 'dynamic_analysis' in app_analysis:
            behavior_analysis = self.analyze_app_behavior(app_analysis['dynamic_analysis'])
            report['ai_predictions']['behavior_analysis'] = behavior_analysis
        
        # Risk değerlendirmesi
        overall_risk = self._calculate_overall_risk(report['ai_predictions'])
        report['risk_assessment'] = overall_risk
        
        # Öneriler
        recommendations = self._generate_recommendations(report['ai_predictions'], overall_risk)
        report['recommendations'] = recommendations
        
        return report
    
    def _calculate_overall_risk(self, predictions):
        """Genel risk değerlendirmesi"""
        risk_factors = []
        
        # Malware riski
        if 'malware_detection' in predictions:
            malware_risk = predictions['malware_detection']['malware_probability']['malware']
            risk_factors.append(malware_risk * 100)
        
        # Davranış riski
        if 'behavior_analysis' in predictions:
            behavior_risk = predictions['behavior_analysis']['risk_score']
            risk_factors.append(behavior_risk)
        
        if not risk_factors:
            return {'overall_score': 0, 'level': 'unknown'}
        
        overall_score = sum(risk_factors) / len(risk_factors)
        
        if overall_score >= 80:
            level = 'critical'
        elif overall_score >= 60:
            level = 'high'
        elif overall_score >= 40:
            level = 'medium'
        else:
            level = 'low'
        
        return {
            'overall_score': round(overall_score, 2),
            'level': level,
            'factors': risk_factors
        }
    
    def _generate_recommendations(self, predictions, risk_assessment):
        """Güvenlik önerileri oluştur"""
        recommendations = []
        
        # Malware tespiti önerileri
        if 'malware_detection' in predictions:
            malware_data = predictions['malware_detection']
            if malware_data['is_malware']:
                recommendations.append({
                    'type': 'critical',
                    'title': 'Malware Tespit Edildi',
                    'description': 'Uygulama malware olarak sınıflandırıldı. Derhal kaldırılmalı.',
                    'action': 'Uygulamayı sistemden kaldırın ve güvenlik taraması yapın.'
                })
            
            if malware_data['is_anomaly']:
                recommendations.append({
                    'type': 'warning',
                    'title': 'Anormal Davranış',
                    'description': 'Uygulama normal davranış kalıplarından sapıyor.',
                    'action': 'Uygulamayı yakından izleyin ve şüpheli aktiviteleri kontrol edin.'
                })
        
        # Davranış analizi önerileri
        if 'behavior_analysis' in predictions:
            behavior_data = predictions['behavior_analysis']
            for anomaly in behavior_data.get('anomalies', []):
                recommendations.append({
                    'type': anomaly['severity'],
                    'title': f"Davranış Anomalisi: {anomaly['type']}",
                    'description': anomaly['description'],
                    'action': 'Uygulama izinlerini gözden geçirin ve gereksiz izinleri kaldırın.'
                })
        
        # Genel risk seviyesi önerileri
        if risk_assessment['level'] == 'critical':
            recommendations.append({
                'type': 'critical',
                'title': 'Kritik Güvenlik Riski',
                'description': 'Uygulama yüksek güvenlik riski taşıyor.',
                'action': 'Uygulamayı derhal kaldırın ve sistem güvenliğini kontrol edin.'
            })
        elif risk_assessment['level'] == 'high':
            recommendations.append({
                'type': 'warning',
                'title': 'Yüksek Güvenlik Riski',
                'description': 'Uygulama güvenlik riski taşıyor.',
                'action': 'Uygulamayı dikkatli kullanın ve düzenli güvenlik kontrolleri yapın.'
            })
        
        return recommendations
    
    def save_model(self, filepath):
        """Modeli kaydet"""
        if self.trained:
            model_data = {
                'malware_classifier': self.malware_classifier,
                'anomaly_detector': self.anomaly_detector,
                'text_vectorizer': self.text_vectorizer,
                'trained': self.trained
            }
            joblib.dump(model_data, filepath)
            print(f"[+] Model kaydedildi: {filepath}")
        else:
            print("[-] Model henüz eğitilmemiş")
    
    def load_model(self, filepath):
        """Modeli yükle"""
        try:
            model_data = joblib.load(filepath)
            self.malware_classifier = model_data['malware_classifier']
            self.anomaly_detector = model_data['anomaly_detector']
            self.text_vectorizer = model_data['text_vectorizer']
            self.trained = model_data['trained']
            print(f"[+] Model yüklendi: {filepath}")
        except Exception as e:
            print(f"[-] Model yükleme hatası: {e}")

# Kullanım örneği
if __name__ == "__main__":
    ai_analyzer = AIMobileSecurityAnalyzer()
    
    # Örnek eğitim verisi (gerçek uygulamada büyük veri seti kullanılır)
    training_data = [
        {
            'analysis_result': {
                'permissions': ['android.permission.INTERNET', 'android.permission.READ_SMS'],
                'activities': ['MainActivity'],
                'services': [],
                'receivers': [],
                'api_calls': ['HttpURLConnection', 'SmsManager.sendTextMessage'],
                'strings': ['http://malicious-site.com'],
                'file_size': 5000000,
                'dex_files': ['classes.dex'],
                'native_libraries': [],
                'certificate_valid': False,
                'network_security_config': False,
                'cleartext_traffic_permitted': True,
                'certificate_pinning': False
            },
            'label': 1  # malware
        },
        # Daha fazla eğitim verisi...
    ]
    
    # Modeli eğit (gerçek uygulamada büyük veri seti gerekli)
    # ai_analyzer.train_malware_classifier(training_data)
    
    # Örnek analiz
    sample_analysis = {
        'permissions': ['android.permission.INTERNET'],
        'activities': ['MainActivity'],
        'services': [],
        'receivers': [],
        'api_calls': ['HttpURLConnection'],
        'strings': ['https://example.com'],
        'file_size': 2000000,
        'dex_files': ['classes.dex'],
        'native_libraries': [],
        'certificate_valid': True,
        'network_security_config': True,
        'cleartext_traffic_permitted': False,
        'certificate_pinning': True
    }
    
    print("[+] AI Destekli Mobil Güvenlik Analizi Sistemi Hazır")
```

## 📚 Kaynaklar ve Referanslar

### 📖 Kitaplar
- "Mobile Application Security" - Himanshu Dwivedi
- "Android Security Internals" - Nikolay Elenkov
- "iOS Application Security" - David Thiel
- "The Mobile Application Hacker's Handbook" - Dominic Chell
- "Android Hacker's Handbook" - Joshua J. Drake

### 🌐 Çevrimiçi Kaynaklar
- [OWASP Mobile Security](https://owasp.org/www-project-mobile-security/)
- [NIST Mobile Security Guidelines](https://csrc.nist.gov/publications/detail/sp/800-124/rev-1/final)
- [Android Security Documentation](https://source.android.com/security)
- [iOS Security Guide](https://support.apple.com/guide/security/welcome/web)
- [Mobile Security Framework (MobSF)](https://github.com/MobSF/Mobile-Security-Framework-MobSF)

### 🛠️ Araç Dokümantasyonları
- [Frida Documentation](https://frida.re/docs/)
- [Objection Guide](https://github.com/sensepost/objection)
- [APKTool Documentation](https://ibotpeaches.github.io/Apktool/)
- [Jadx Decompiler](https://github.com/skylot/jadx)
- [Burp Suite Mobile Assistant](https://portswigger.net/burp/documentation/desktop/mobile)

### 🎓 Sertifikasyon Programları
- **GMOB (GIAC Mobile Device Security Analyst)**
- **CISSP (Mobile Security Domain)**
- **CEH (Mobile Platform Security)**
- **OSCP (Mobile Penetration Testing)**
- **SANS Mobile Security Courses**

### 🏆 CTF Platformları
- [DIVA Android](https://github.com/payatu/diva-android)
- [InsecureBankv2](https://github.com/dineshshetty/Android-InsecureBankv2)
- [DVHMA](https://github.com/logicalhacking/DVHMA)
- [iGoat-Swift](https://github.com/OWASP/igoat-swift)
- [UnCrackable Mobile Apps](https://github.com/OWASP/owasp-mstg/tree/master/Crackmes)

### ⚖️ Yasal ve Etik Kaynaklar
- **Mobile Penetration Testing Ethics**
- **GDPR Mobile Privacy Compliance**
- **Mobile App Store Security Policies**
- **Mobile Device Management (MDM) Legal Framework**
- **Mobile Forensics Legal Guidelines**

### 🔬 Araştırma ve Akademik Kaynaklar
- **IEEE Mobile Security Papers**
- **ACM Mobile Computing Security**
- **USENIX Mobile Security Research**
- **Black Hat Mobile Security Presentations**
- **DEF CON Mobile Hacking Village**

### 📰 Güvenlik Haberleri ve Bloglar
- **Android Security Bulletin**
- **iOS Security Updates**
- **Mobile Threat Intelligence Reports**
- **Zimperium Mobile Security Blog**
- **Lookout Mobile Security Research**

---

## 🎯 Level 2 Tamamlama Kriterleri

### ✅ Teorik Bilgi Tamamlama
- [ ] OWASP Mobile Top 10 kavramları
- [ ] Android ve iOS güvenlik mimarileri
- [ ] Mobil uygulama güvenlik best practices
- [ ] Mobil malware analiz teknikleri
- [ ] Mobil forensics temelleri

### ✅ Pratik Beceri Tamamlama
- [ ] Android APK statik analizi
- [ ] iOS IPA güvenlik analizi
- [ ] Frida ile dinamik analiz
- [ ] Mobil ağ trafiği analizi
- [ ] Mobil penetrasyon testi raporu hazırlama

### ✅ Teknik Yetkinlik Tamamlama
- [ ] Mobil güvenlik araçları kullanımı
- [ ] Mobil uygulama reverse engineering
- [ ] Mobil exploit geliştirme
- [ ] Mobil güvenlik otomasyonu
- [ ] AI destekli mobil güvenlik analizi

**🎉 Level 2 Tamamlandı! Artık Level 3'e geçmeye hazırsınız.**
