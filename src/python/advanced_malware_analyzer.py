#!/usr/bin/env python3
"""
Advanced Malware Analysis Framework
Author: ibrahimsql
Description: Comprehensive malware analysis and classification system
"""

import os
import sys
import json
import hashlib
import subprocess
import time
import requests
import yara
import pefile
import magic
from datetime import datetime
from pathlib import Path
import sqlite3
import logging
from typing import Dict, List, Optional, Tuple
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.feature_extraction.text import TfidfVectorizer
import pickle

class AdvancedMalwareAnalyzer:
    def __init__(self, config_path: str = "config.json"):
        self.config = self._load_config(config_path)
        self.db_path = self.config.get('database_path', 'malware_analysis.db')
        self.yara_rules_path = self.config.get('yara_rules_path', 'rules/')
        self.sandbox_path = self.config.get('sandbox_path', '/tmp/sandbox')
        self.analysis_results = {}
        self.logger = self._setup_logging()
        self._init_database()
        self._load_yara_rules()
        
    def _load_config(self, config_path: str) -> Dict:
        """Load configuration file"""
        try:
            with open(config_path, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            return self._create_default_config(config_path)
    
    def _create_default_config(self, config_path: str) -> Dict:
        """Create default configuration"""
        default_config = {
            'database_path': 'malware_analysis.db',
            'yara_rules_path': 'rules/',
            'sandbox_path': '/tmp/sandbox',
            'virustotal_api_key': '',
            'analysis_timeout': 300,
            'enable_network_analysis': True,
            'enable_memory_analysis': True,
            'log_level': 'INFO'
        }
        
        with open(config_path, 'w') as f:
            json.dump(default_config, f, indent=2)
        
        return default_config
    
    def _setup_logging(self) -> logging.Logger:
        """Setup logging system"""
        logger = logging.getLogger('MalwareAnalyzer')
        logger.setLevel(getattr(logging, self.config.get('log_level', 'INFO')))
        
        handler = logging.StreamHandler()
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        
        return logger
    
    def _init_database(self):
        """Initialize database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Malware samples table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS malware_samples (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                md5_hash TEXT UNIQUE,
                sha1_hash TEXT,
                sha256_hash TEXT,
                file_size INTEGER,
                file_type TEXT,
                first_seen TIMESTAMP,
                last_analyzed TIMESTAMP,
                family TEXT,
                classification TEXT,
                threat_level INTEGER
            )
        ''')
        
        # Analysis results tablosu
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS analysis_results (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                sample_id INTEGER,
                analysis_type TEXT,
                analysis_date TIMESTAMP,
                results TEXT,
                FOREIGN KEY (sample_id) REFERENCES malware_samples (id)
            )
        ''')
        
        # IOCs tablosu
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS iocs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                sample_id INTEGER,
                ioc_type TEXT,
                ioc_value TEXT,
                confidence REAL,
                FOREIGN KEY (sample_id) REFERENCES malware_samples (id)
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def _load_yara_rules(self):
        """YARA kurallarını yükle"""
        try:
            rules_files = []
            if os.path.exists(self.yara_rules_path):
                for root, dirs, files in os.walk(self.yara_rules_path):
                    for file in files:
                        if file.endswith('.yar') or file.endswith('.yara'):
                            rules_files.append(os.path.join(root, file))
            
            if rules_files:
                self.yara_rules = yara.compile(filepaths={
                    f'rule_{i}': path for i, path in enumerate(rules_files)
                })
                self.logger.info(f"Loaded {len(rules_files)} YARA rule files")
            else:
                self.yara_rules = None
                self.logger.warning("No YARA rules found")
                
        except Exception as e:
            self.logger.error(f"Error loading YARA rules: {e}")
            self.yara_rules = None
    
    def analyze_sample(self, file_path: str) -> Dict:
        """Malware örneğini kapsamlı analiz et"""
        self.logger.info(f"Starting analysis of {file_path}")
        
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"Sample file not found: {file_path}")
        
        # Temel dosya bilgileri
        basic_info = self._get_basic_file_info(file_path)
        
        # Veritabanında kontrol et
        sample_id = self._get_or_create_sample_record(basic_info)
        
        analysis_results = {
            'sample_id': sample_id,
            'basic_info': basic_info,
            'static_analysis': self._perform_static_analysis(file_path),
            'dynamic_analysis': self._perform_dynamic_analysis(file_path),
            'network_analysis': self._perform_network_analysis(file_path),
            'behavioral_analysis': self._perform_behavioral_analysis(file_path),
            'threat_intelligence': self._gather_threat_intelligence(basic_info),
            'classification': self._classify_malware(file_path),
            'iocs': self._extract_iocs(file_path),
            'analysis_timestamp': datetime.now().isoformat()
        }
        
        # Sonuçları veritabanına kaydet
        self._save_analysis_results(sample_id, analysis_results)
        
        # Threat level hesapla
        threat_level = self._calculate_threat_level(analysis_results)
        self._update_sample_threat_level(sample_id, threat_level)
        
        self.logger.info(f"Analysis completed for {file_path}")
        return analysis_results
    
    def _get_basic_file_info(self, file_path: str) -> Dict:
        """Temel dosya bilgilerini al"""
        with open(file_path, 'rb') as f:
            content = f.read()
        
        return {
            'file_path': file_path,
            'file_size': len(content),
            'md5_hash': hashlib.md5(content).hexdigest(),
            'sha1_hash': hashlib.sha1(content).hexdigest(),
            'sha256_hash': hashlib.sha256(content).hexdigest(),
            'file_type': magic.from_buffer(content),
            'first_seen': datetime.now().isoformat()
        }
    
    def _get_or_create_sample_record(self, basic_info: Dict) -> int:
        """Örnek kaydını al veya oluştur"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Mevcut kaydı kontrol et
        cursor.execute(
            'SELECT id FROM malware_samples WHERE md5_hash = ?',
            (basic_info['md5_hash'],)
        )
        
        result = cursor.fetchone()
        if result:
            sample_id = result[0]
            # Son analiz tarihini güncelle
            cursor.execute(
                'UPDATE malware_samples SET last_analyzed = ? WHERE id = ?',
                (datetime.now(), sample_id)
            )
        else:
            # Yeni kayıt oluştur
            cursor.execute('''
                INSERT INTO malware_samples 
                (md5_hash, sha1_hash, sha256_hash, file_size, file_type, first_seen, last_analyzed)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', (
                basic_info['md5_hash'],
                basic_info['sha1_hash'],
                basic_info['sha256_hash'],
                basic_info['file_size'],
                basic_info['file_type'],
                basic_info['first_seen'],
                datetime.now()
            ))
            sample_id = cursor.lastrowid
        
        conn.commit()
        conn.close()
        return sample_id
    
    def _perform_static_analysis(self, file_path: str) -> Dict:
        """Statik analiz gerçekleştir"""
        results = {
            'pe_analysis': None,
            'strings_analysis': None,
            'yara_matches': None,
            'entropy_analysis': None,
            'imports_analysis': None,
            'sections_analysis': None
        }
        
        try:
            # PE analizi
            if file_path.lower().endswith(('.exe', '.dll', '.sys')):
                results['pe_analysis'] = self._analyze_pe_file(file_path)
            
            # Strings analizi
            results['strings_analysis'] = self._extract_strings(file_path)
            
            # YARA kuralları
            if self.yara_rules:
                matches = self.yara_rules.match(file_path)
                results['yara_matches'] = [{
                    'rule': match.rule,
                    'tags': match.tags,
                    'strings': [(s.identifier, s.instances) for s in match.strings]
                } for match in matches]
            
            # Entropy analizi
            results['entropy_analysis'] = self._calculate_entropy(file_path)
            
        except Exception as e:
            self.logger.error(f"Static analysis error: {e}")
        
        return results
    
    def _analyze_pe_file(self, file_path: str) -> Dict:
        """PE dosya analizi"""
        try:
            pe = pefile.PE(file_path)
            
            return {
                'machine': hex(pe.FILE_HEADER.Machine),
                'timestamp': pe.FILE_HEADER.TimeDateStamp,
                'characteristics': hex(pe.FILE_HEADER.Characteristics),
                'entry_point': hex(pe.OPTIONAL_HEADER.AddressOfEntryPoint),
                'image_base': hex(pe.OPTIONAL_HEADER.ImageBase),
                'sections': [{
                    'name': section.Name.decode('utf-8', errors='ignore').strip('\x00'),
                    'virtual_address': hex(section.VirtualAddress),
                    'virtual_size': section.Misc_VirtualSize,
                    'raw_size': section.SizeOfRawData,
                    'characteristics': hex(section.Characteristics),
                    'entropy': section.get_entropy()
                } for section in pe.sections],
                'imports': self._extract_pe_imports(pe),
                'exports': self._extract_pe_exports(pe)
            }
        except Exception as e:
            self.logger.error(f"PE analysis error: {e}")
            return {}
    
    def _extract_pe_imports(self, pe) -> List[Dict]:
        """PE import tablosunu çıkar"""
        imports = []
        try:
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    dll_imports = []
                    for imp in entry.imports:
                        if imp.name:
                            dll_imports.append({
                                'name': imp.name.decode('utf-8', errors='ignore'),
                                'address': hex(imp.address) if imp.address else None
                            })
                    imports.append({
                        'dll': entry.dll.decode('utf-8', errors='ignore'),
                        'functions': dll_imports
                    })
        except Exception as e:
            self.logger.error(f"Import extraction error: {e}")
        
        return imports
    
    def _extract_pe_exports(self, pe) -> List[Dict]:
        """PE export tablosunu çıkar"""
        exports = []
        try:
            if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
                for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
                    exports.append({
                        'name': exp.name.decode('utf-8', errors='ignore') if exp.name else None,
                        'address': hex(exp.address),
                        'ordinal': exp.ordinal
                    })
        except Exception as e:
            self.logger.error(f"Export extraction error: {e}")
        
        return exports
    
    def _extract_strings(self, file_path: str, min_length: int = 4) -> List[str]:
        """Dosyadan string'leri çıkar"""
        try:
            result = subprocess.run(
                ['strings', '-n', str(min_length), file_path],
                capture_output=True, text=True, timeout=30
            )
            return result.stdout.split('\n')[:1000]  # İlk 1000 string
        except Exception as e:
            self.logger.error(f"String extraction error: {e}")
            return []
    
    def _calculate_entropy(self, file_path: str) -> float:
        """Dosya entropy'sini hesapla"""
        try:
            with open(file_path, 'rb') as f:
                data = f.read()
            
            if not data:
                return 0.0
            
            # Byte frekanslarını hesapla
            byte_counts = [0] * 256
            for byte in data:
                byte_counts[byte] += 1
            
            # Entropy hesapla
            entropy = 0.0
            data_len = len(data)
            
            for count in byte_counts:
                if count > 0:
                    probability = count / data_len
                    entropy -= probability * np.log2(probability)
            
            return entropy
        except Exception as e:
            self.logger.error(f"Entropy calculation error: {e}")
            return 0.0
    
    def _perform_dynamic_analysis(self, file_path: str) -> Dict:
        """Dinamik analiz gerçekleştir"""
        results = {
            'sandbox_execution': None,
            'api_calls': None,
            'file_operations': None,
            'registry_operations': None,
            'network_connections': None,
            'process_creation': None
        }
        
        # Sandbox analizi (simulated)
        self.logger.info("Performing dynamic analysis (sandbox simulation)")
        
        try:
            # Bu kısım gerçek bir sandbox entegrasyonu gerektirir
            # Örnek: Cuckoo Sandbox, VMware vSphere, etc.
            results['sandbox_execution'] = {
                'status': 'simulated',
                'execution_time': 60,
                'exit_code': 0,
                'screenshots_taken': 5
            }
            
            # API call monitoring (simulated)
            results['api_calls'] = self._simulate_api_monitoring()
            
            # File operations monitoring
            results['file_operations'] = self._simulate_file_monitoring()
            
            # Registry operations
            results['registry_operations'] = self._simulate_registry_monitoring()
            
        except Exception as e:
            self.logger.error(f"Dynamic analysis error: {e}")
        
        return results
    
    def _simulate_api_monitoring(self) -> List[Dict]:
        """API çağrı izleme simülasyonu"""
        return [
            {'api': 'CreateFileW', 'args': ['C:\\temp\\malware.exe'], 'return': 'HANDLE'},
            {'api': 'RegOpenKeyExW', 'args': ['HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run'], 'return': 'SUCCESS'},
            {'api': 'InternetOpenW', 'args': ['Mozilla/5.0'], 'return': 'HANDLE'},
            {'api': 'HttpOpenRequestW', 'args': ['GET', '/c2/beacon'], 'return': 'HANDLE'}
        ]
    
    def _simulate_file_monitoring(self) -> List[Dict]:
        """Dosya işlem izleme simülasyonu"""
        return [
            {'operation': 'CREATE', 'path': 'C:\\temp\\payload.exe', 'size': 1024},
            {'operation': 'WRITE', 'path': 'C:\\Users\\victim\\Documents\\data.txt', 'size': 512},
            {'operation': 'DELETE', 'path': 'C:\\Windows\\System32\\drivers\\etc\\hosts', 'size': 0}
        ]
    
    def _simulate_registry_monitoring(self) -> List[Dict]:
        """Registry işlem izleme simülasyonu"""
        return [
            {'operation': 'SET', 'key': 'HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run', 'value': 'malware.exe'},
            {'operation': 'CREATE', 'key': 'HKCU\\Software\\Malware', 'value': 'config_data'}
        ]
    
    def _perform_network_analysis(self, file_path: str) -> Dict:
        """Ağ analizi gerçekleştir"""
        if not self.config.get('enable_network_analysis', True):
            return {'status': 'disabled'}
        
        results = {
            'dns_requests': [],
            'http_requests': [],
            'tcp_connections': [],
            'suspicious_domains': [],
            'c2_indicators': []
        }
        
        # Network monitoring simülasyonu
        results['dns_requests'] = [
            {'domain': 'malicious-c2.com', 'ip': '192.168.1.100', 'timestamp': datetime.now().isoformat()},
            {'domain': 'update.legitimate-site.com', 'ip': '8.8.8.8', 'timestamp': datetime.now().isoformat()}
        ]
        
        results['http_requests'] = [
            {'url': 'http://malicious-c2.com/beacon', 'method': 'POST', 'user_agent': 'Mozilla/5.0'},
            {'url': 'http://malicious-c2.com/download', 'method': 'GET', 'response_size': 2048}
        ]
        
        return results
    
    def _perform_behavioral_analysis(self, file_path: str) -> Dict:
        """Davranışsal analiz gerçekleştir"""
        results = {
            'behavior_patterns': [],
            'persistence_mechanisms': [],
            'evasion_techniques': [],
            'payload_delivery': [],
            'data_exfiltration': []
        }
        
        # Davranış pattern analizi
        results['behavior_patterns'] = [
            {'pattern': 'file_encryption', 'confidence': 0.8, 'indicators': ['crypto_api_calls', 'file_extension_changes']},
            {'pattern': 'keylogging', 'confidence': 0.6, 'indicators': ['keyboard_hooks', 'log_file_creation']}
        ]
        
        results['persistence_mechanisms'] = [
            {'mechanism': 'registry_run_key', 'location': 'HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run'},
            {'mechanism': 'scheduled_task', 'name': 'SystemUpdate'}
        ]
        
        return results
    
    def _gather_threat_intelligence(self, basic_info: Dict) -> Dict:
        """Tehdit istihbaratı topla"""
        results = {
            'virustotal_report': None,
            'known_campaigns': [],
            'attribution': None,
            'similar_samples': []
        }
        
        # VirusTotal API sorgusu (API key gerekli)
        if self.config.get('virustotal_api_key'):
            try:
                vt_report = self._query_virustotal(basic_info['sha256_hash'])
                results['virustotal_report'] = vt_report
            except Exception as e:
                self.logger.error(f"VirusTotal query error: {e}")
        
        return results
    
    def _query_virustotal(self, file_hash: str) -> Dict:
        """VirusTotal API sorgusu"""
        api_key = self.config.get('virustotal_api_key')
        if not api_key:
            return {'error': 'API key not configured'}
        
        url = f"https://www.virustotal.com/vtapi/v2/file/report"
        params = {
            'apikey': api_key,
            'resource': file_hash
        }
        
        try:
            response = requests.get(url, params=params, timeout=30)
            return response.json()
        except Exception as e:
            return {'error': str(e)}
    
    def _classify_malware(self, file_path: str) -> Dict:
        """Malware sınıflandırması"""
        # Machine learning tabanlı sınıflandırma
        features = self._extract_ml_features(file_path)
        
        # Basit kural tabanlı sınıflandırma
        classification = {
            'family': 'unknown',
            'type': 'unknown',
            'confidence': 0.0,
            'ml_prediction': None
        }
        
        # Örnek sınıflandırma kuralları
        if 'crypto' in str(features).lower():
            classification['type'] = 'ransomware'
            classification['confidence'] = 0.7
        elif 'keylog' in str(features).lower():
            classification['type'] = 'keylogger'
            classification['confidence'] = 0.6
        elif 'bot' in str(features).lower():
            classification['type'] = 'botnet'
            classification['confidence'] = 0.5
        
        return classification
    
    def _extract_ml_features(self, file_path: str) -> Dict:
        """Machine learning için özellik çıkarımı"""
        features = {
            'file_size': 0,
            'entropy': 0.0,
            'pe_characteristics': [],
            'import_count': 0,
            'section_count': 0,
            'string_features': []
        }
        
        try:
            # Dosya boyutu
            features['file_size'] = os.path.getsize(file_path)
            
            # Entropy
            features['entropy'] = self._calculate_entropy(file_path)
            
            # PE özellikleri
            if file_path.lower().endswith(('.exe', '.dll', '.sys')):
                pe_info = self._analyze_pe_file(file_path)
                if pe_info:
                    features['import_count'] = len(pe_info.get('imports', []))
                    features['section_count'] = len(pe_info.get('sections', []))
            
            # String özellikleri
            strings = self._extract_strings(file_path)
            features['string_features'] = strings[:100]  # İlk 100 string
            
        except Exception as e:
            self.logger.error(f"Feature extraction error: {e}")
        
        return features
    
    def _extract_iocs(self, file_path: str) -> List[Dict]:
        """IOC (Indicators of Compromise) çıkarımı"""
        iocs = []
        
        try:
            # String'lerden IOC çıkarımı
            strings = self._extract_strings(file_path)
            
            for string in strings:
                # IP adresleri
                import re
                ip_pattern = r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b'
                ips = re.findall(ip_pattern, string)
                for ip in ips:
                    iocs.append({
                        'type': 'ip',
                        'value': ip,
                        'confidence': 0.7,
                        'source': 'strings'
                    })
                
                # Domain adları
                domain_pattern = r'\b[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.[a-zA-Z]{2,}\b'
                domains = re.findall(domain_pattern, string)
                for domain in domains:
                    if '.' in domain and len(domain) > 4:
                        iocs.append({
                            'type': 'domain',
                            'value': domain,
                            'confidence': 0.6,
                            'source': 'strings'
                        })
                
                # URL'ler
                url_pattern = r'https?://[^\s<>"]+'
                urls = re.findall(url_pattern, string)
                for url in urls:
                    iocs.append({
                        'type': 'url',
                        'value': url,
                        'confidence': 0.8,
                        'source': 'strings'
                    })
        
        except Exception as e:
            self.logger.error(f"IOC extraction error: {e}")
        
        return iocs[:50]  # İlk 50 IOC
    
    def _save_analysis_results(self, sample_id: int, results: Dict):
        """Analiz sonuçlarını veritabanına kaydet"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Ana analiz sonucu
        cursor.execute('''
            INSERT INTO analysis_results (sample_id, analysis_type, analysis_date, results)
            VALUES (?, ?, ?, ?)
        ''', (
            sample_id,
            'comprehensive',
            datetime.now(),
            json.dumps(results, default=str)
        ))
        
        # IOC'leri kaydet
        for ioc in results.get('iocs', []):
            cursor.execute('''
                INSERT INTO iocs (sample_id, ioc_type, ioc_value, confidence)
                VALUES (?, ?, ?, ?)
            ''', (
                sample_id,
                ioc['type'],
                ioc['value'],
                ioc['confidence']
            ))
        
        conn.commit()
        conn.close()
    
    def _calculate_threat_level(self, analysis_results: Dict) -> int:
        """Tehdit seviyesini hesapla (1-10)"""
        threat_score = 0
        
        # YARA kuralı eşleşmeleri
        yara_matches = analysis_results.get('static_analysis', {}).get('yara_matches', [])
        threat_score += len(yara_matches) * 2
        
        # Entropy skoru
        entropy = analysis_results.get('static_analysis', {}).get('entropy_analysis', 0)
        if entropy > 7.0:
            threat_score += 3
        elif entropy > 6.0:
            threat_score += 2
        
        # Şüpheli davranışlar
        behaviors = analysis_results.get('behavioral_analysis', {}).get('behavior_patterns', [])
        threat_score += len(behaviors)
        
        # IOC sayısı
        iocs = analysis_results.get('iocs', [])
        threat_score += len(iocs) // 5
        
        # Network aktivitesi
        network_analysis = analysis_results.get('network_analysis', {})
        if network_analysis.get('c2_indicators'):
            threat_score += 5
        
        return min(threat_score, 10)  # Maksimum 10
    
    def _update_sample_threat_level(self, sample_id: int, threat_level: int):
        """Örnek tehdit seviyesini güncelle"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute(
            'UPDATE malware_samples SET threat_level = ? WHERE id = ?',
            (threat_level, sample_id)
        )
        
        conn.commit()
        conn.close()
    
    def generate_report(self, sample_id: int) -> str:
        """Analiz raporu oluştur"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Örnek bilgilerini al
        cursor.execute(
            'SELECT * FROM malware_samples WHERE id = ?',
            (sample_id,)
        )
        sample = cursor.fetchone()
        
        if not sample:
            return "Sample not found"
        
        # Analiz sonuçlarını al
        cursor.execute(
            'SELECT * FROM analysis_results WHERE sample_id = ? ORDER BY analysis_date DESC LIMIT 1',
            (sample_id,)
        )
        analysis = cursor.fetchone()
        
        # IOC'leri al
        cursor.execute(
            'SELECT * FROM iocs WHERE sample_id = ?',
            (sample_id,)
        )
        iocs = cursor.fetchall()
        
        conn.close()
        
        # Rapor oluştur
        report = f"""
# Malware Analysis Report

## Sample Information
- **MD5**: {sample[1]}
- **SHA1**: {sample[2]}
- **SHA256**: {sample[3]}
- **File Size**: {sample[4]} bytes
- **File Type**: {sample[5]}
- **First Seen**: {sample[6]}
- **Last Analyzed**: {sample[7]}
- **Threat Level**: {sample[10]}/10

## Analysis Summary
{json.dumps(json.loads(analysis[4]) if analysis else {}, indent=2)}

## Indicators of Compromise (IOCs)
"""
        
        for ioc in iocs:
            report += f"- **{ioc[2]}**: {ioc[3]} (Confidence: {ioc[4]})\n"
        
        return report
    
    def batch_analyze(self, directory_path: str) -> List[Dict]:
        """Toplu analiz"""
        results = []
        
        if not os.path.exists(directory_path):
            raise FileNotFoundError(f"Directory not found: {directory_path}")
        
        for root, dirs, files in os.walk(directory_path):
            for file in files:
                file_path = os.path.join(root, file)
                try:
                    self.logger.info(f"Analyzing {file_path}")
                    result = self.analyze_sample(file_path)
                    results.append(result)
                except Exception as e:
                    self.logger.error(f"Error analyzing {file_path}: {e}")
                    results.append({
                        'file_path': file_path,
                        'error': str(e)
                    })
        
        return results

# Kullanım örneği
if __name__ == "__main__":
    analyzer = AdvancedMalwareAnalyzer()
    
    # Tek dosya analizi
    # result = analyzer.analyze_sample("/path/to/malware/sample.exe")
    # print(json.dumps(result, indent=2, default=str))
    
    # Rapor oluşturma
    # report = analyzer.generate_report(1)
    # print(report)
    
    # Toplu analiz
    # results = analyzer.batch_analyze("/path/to/malware/samples/")
    # print(f"Analyzed {len(results)} samples")
    
    print("Advanced Malware Analyzer initialized successfully!")